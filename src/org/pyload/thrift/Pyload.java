/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.pyload.thrift;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class Pyload {

  public interface Iface {

    public String getConfigValue(String category, String option, String section) throws TException;

    public void setConfigValue(String category, String option, String value, String section) throws TException;

    public Map<String,ConfigSection> getConfig() throws TException;

    public Map<String,ConfigSection> getPluginConfig() throws TException;

    public void pauseServer() throws TException;

    public void unpauseServer() throws TException;

    public boolean togglePause() throws TException;

    public ServerStatus statusServer() throws TException;

    public long freeSpace() throws TException;

    public String getServerVersion() throws TException;

    public void kill() throws TException;

    public void restart() throws TException;

    public List<String> getLog(int offset) throws TException;

    public boolean isTimeDownload() throws TException;

    public boolean isTimeReconnect() throws TException;

    public boolean toggleReconnect() throws TException;

    public Map<String,List<String>> generatePackages(List<String> links) throws TException;

    public Map<String,List<String>> checkURLs(List<String> urls) throws TException;

    public Map<String,List<String>> parseURLs(String html) throws TException;

    public OnlineCheck checkOnlineStatus(List<String> urls) throws TException;

    public OnlineCheck checkOnlineStatusContainer(List<String> urls, String filename, ByteBuffer data) throws TException;

    public OnlineCheck pollResults(int rid) throws TException;

    public List<DownloadInfo> statusDownloads() throws TException;

    public PackageData getPackageData(int pid) throws PackageDoesNotExists, TException;

    public PackageData getPackageInfo(int pid) throws PackageDoesNotExists, TException;

    public FileData getFileData(int fid) throws FileDoesNotExists, TException;

    public List<PackageData> getQueue() throws TException;

    public List<PackageData> getCollector() throws TException;

    public List<PackageData> getQueueData() throws TException;

    public List<PackageData> getCollectorData() throws TException;

    public Map<Short,Integer> getPackageOrder(Destination destination) throws TException;

    public Map<Short,Integer> getFileOrder(int pid) throws TException;

    public List<Integer> generateAndAddPackages(List<String> links, Destination dest) throws TException;

    public int addPackage(String name, List<String> links, Destination dest) throws TException;

    public void addFiles(int pid, List<String> links) throws TException;

    public void uploadContainer(String filename, ByteBuffer data) throws TException;

    public void deleteFiles(List<Integer> fids) throws TException;

    public void deletePackages(List<Integer> pids) throws TException;

    public void pushToQueue(int pid) throws TException;

    public void pullFromQueue(int pid) throws TException;

    public void restartPackage(int pid) throws TException;

    public void restartFile(int fid) throws TException;

    public void recheckPackage(int pid) throws TException;

    public void stopAllDownloads() throws TException;

    public void stopDownloads(List<Integer> fids) throws TException;

    public void setPackageName(int pid, String name) throws TException;

    public void movePackage(Destination destination, int pid) throws TException;

    public void moveFiles(List<Integer> fids, int pid) throws TException;

    public void orderPackage(int pid, short position) throws TException;

    public void orderFile(int fid, short position) throws TException;

    public void setPackageData(int pid, Map<String,String> data) throws PackageDoesNotExists, TException;

    public void deleteFinished() throws TException;

    public void restartFailed() throws TException;

    public boolean isCaptchaWaiting() throws TException;

    public CaptchaTask getCaptchaTask(boolean exclusive) throws TException;

    public String getCaptchaTaskStatus(int tid) throws TException;

    public void setCaptchaResult(int tid, String result) throws TException;

    public List<Event> getEvents(String uuid) throws TException;

    public List<AccountInfo> getAccounts(boolean refresh) throws TException;

    public List<String> getAccountTypes() throws TException;

    public void updateAccount(String plugin, String account, String password, Map<String,String> options) throws TException;

    public void removeAccount(String plugin, String account) throws TException;

    public boolean login(String username, String password) throws TException;

    public UserData getUserData(String username, String password) throws TException;

    public Map<String,Map<String,String>> getServices() throws TException;

    public boolean hasService(String plugin, String func) throws TException;

    public String call(ServiceCall info) throws ServiceDoesNotExists, ServiceException, TException;

    public Map<String,Map<String,String>> getAllInfo() throws TException;

    public Map<String,String> getInfoByPlugin(String plugin) throws TException;

  }

  public interface AsyncIface {

    public void getConfigValue(String category, String option, String section, AsyncMethodCallback<AsyncClient.getConfigValue_call> resultHandler) throws TException;

    public void setConfigValue(String category, String option, String value, String section, AsyncMethodCallback<AsyncClient.setConfigValue_call> resultHandler) throws TException;

    public void getConfig(AsyncMethodCallback<AsyncClient.getConfig_call> resultHandler) throws TException;

    public void getPluginConfig(AsyncMethodCallback<AsyncClient.getPluginConfig_call> resultHandler) throws TException;

    public void pauseServer(AsyncMethodCallback<AsyncClient.pauseServer_call> resultHandler) throws TException;

    public void unpauseServer(AsyncMethodCallback<AsyncClient.unpauseServer_call> resultHandler) throws TException;

    public void togglePause(AsyncMethodCallback<AsyncClient.togglePause_call> resultHandler) throws TException;

    public void statusServer(AsyncMethodCallback<AsyncClient.statusServer_call> resultHandler) throws TException;

    public void freeSpace(AsyncMethodCallback<AsyncClient.freeSpace_call> resultHandler) throws TException;

    public void getServerVersion(AsyncMethodCallback<AsyncClient.getServerVersion_call> resultHandler) throws TException;

    public void kill(AsyncMethodCallback<AsyncClient.kill_call> resultHandler) throws TException;

    public void restart(AsyncMethodCallback<AsyncClient.restart_call> resultHandler) throws TException;

    public void getLog(int offset, AsyncMethodCallback<AsyncClient.getLog_call> resultHandler) throws TException;

    public void isTimeDownload(AsyncMethodCallback<AsyncClient.isTimeDownload_call> resultHandler) throws TException;

    public void isTimeReconnect(AsyncMethodCallback<AsyncClient.isTimeReconnect_call> resultHandler) throws TException;

    public void toggleReconnect(AsyncMethodCallback<AsyncClient.toggleReconnect_call> resultHandler) throws TException;

    public void generatePackages(List<String> links, AsyncMethodCallback<AsyncClient.generatePackages_call> resultHandler) throws TException;

    public void checkURLs(List<String> urls, AsyncMethodCallback<AsyncClient.checkURLs_call> resultHandler) throws TException;

    public void parseURLs(String html, AsyncMethodCallback<AsyncClient.parseURLs_call> resultHandler) throws TException;

    public void checkOnlineStatus(List<String> urls, AsyncMethodCallback<AsyncClient.checkOnlineStatus_call> resultHandler) throws TException;

    public void checkOnlineStatusContainer(List<String> urls, String filename, ByteBuffer data, AsyncMethodCallback<AsyncClient.checkOnlineStatusContainer_call> resultHandler) throws TException;

    public void pollResults(int rid, AsyncMethodCallback<AsyncClient.pollResults_call> resultHandler) throws TException;

    public void statusDownloads(AsyncMethodCallback<AsyncClient.statusDownloads_call> resultHandler) throws TException;

    public void getPackageData(int pid, AsyncMethodCallback<AsyncClient.getPackageData_call> resultHandler) throws TException;

    public void getPackageInfo(int pid, AsyncMethodCallback<AsyncClient.getPackageInfo_call> resultHandler) throws TException;

    public void getFileData(int fid, AsyncMethodCallback<AsyncClient.getFileData_call> resultHandler) throws TException;

    public void getQueue(AsyncMethodCallback<AsyncClient.getQueue_call> resultHandler) throws TException;

    public void getCollector(AsyncMethodCallback<AsyncClient.getCollector_call> resultHandler) throws TException;

    public void getQueueData(AsyncMethodCallback<AsyncClient.getQueueData_call> resultHandler) throws TException;

    public void getCollectorData(AsyncMethodCallback<AsyncClient.getCollectorData_call> resultHandler) throws TException;

    public void getPackageOrder(Destination destination, AsyncMethodCallback<AsyncClient.getPackageOrder_call> resultHandler) throws TException;

    public void getFileOrder(int pid, AsyncMethodCallback<AsyncClient.getFileOrder_call> resultHandler) throws TException;

    public void generateAndAddPackages(List<String> links, Destination dest, AsyncMethodCallback<AsyncClient.generateAndAddPackages_call> resultHandler) throws TException;

    public void addPackage(String name, List<String> links, Destination dest, AsyncMethodCallback<AsyncClient.addPackage_call> resultHandler) throws TException;

    public void addFiles(int pid, List<String> links, AsyncMethodCallback<AsyncClient.addFiles_call> resultHandler) throws TException;

    public void uploadContainer(String filename, ByteBuffer data, AsyncMethodCallback<AsyncClient.uploadContainer_call> resultHandler) throws TException;

    public void deleteFiles(List<Integer> fids, AsyncMethodCallback<AsyncClient.deleteFiles_call> resultHandler) throws TException;

    public void deletePackages(List<Integer> pids, AsyncMethodCallback<AsyncClient.deletePackages_call> resultHandler) throws TException;

    public void pushToQueue(int pid, AsyncMethodCallback<AsyncClient.pushToQueue_call> resultHandler) throws TException;

    public void pullFromQueue(int pid, AsyncMethodCallback<AsyncClient.pullFromQueue_call> resultHandler) throws TException;

    public void restartPackage(int pid, AsyncMethodCallback<AsyncClient.restartPackage_call> resultHandler) throws TException;

    public void restartFile(int fid, AsyncMethodCallback<AsyncClient.restartFile_call> resultHandler) throws TException;

    public void recheckPackage(int pid, AsyncMethodCallback<AsyncClient.recheckPackage_call> resultHandler) throws TException;

    public void stopAllDownloads(AsyncMethodCallback<AsyncClient.stopAllDownloads_call> resultHandler) throws TException;

    public void stopDownloads(List<Integer> fids, AsyncMethodCallback<AsyncClient.stopDownloads_call> resultHandler) throws TException;

    public void setPackageName(int pid, String name, AsyncMethodCallback<AsyncClient.setPackageName_call> resultHandler) throws TException;

    public void movePackage(Destination destination, int pid, AsyncMethodCallback<AsyncClient.movePackage_call> resultHandler) throws TException;

    public void moveFiles(List<Integer> fids, int pid, AsyncMethodCallback<AsyncClient.moveFiles_call> resultHandler) throws TException;

    public void orderPackage(int pid, short position, AsyncMethodCallback<AsyncClient.orderPackage_call> resultHandler) throws TException;

    public void orderFile(int fid, short position, AsyncMethodCallback<AsyncClient.orderFile_call> resultHandler) throws TException;

    public void setPackageData(int pid, Map<String,String> data, AsyncMethodCallback<AsyncClient.setPackageData_call> resultHandler) throws TException;

    public void deleteFinished(AsyncMethodCallback<AsyncClient.deleteFinished_call> resultHandler) throws TException;

    public void restartFailed(AsyncMethodCallback<AsyncClient.restartFailed_call> resultHandler) throws TException;

    public void isCaptchaWaiting(AsyncMethodCallback<AsyncClient.isCaptchaWaiting_call> resultHandler) throws TException;

    public void getCaptchaTask(boolean exclusive, AsyncMethodCallback<AsyncClient.getCaptchaTask_call> resultHandler) throws TException;

    public void getCaptchaTaskStatus(int tid, AsyncMethodCallback<AsyncClient.getCaptchaTaskStatus_call> resultHandler) throws TException;

    public void setCaptchaResult(int tid, String result, AsyncMethodCallback<AsyncClient.setCaptchaResult_call> resultHandler) throws TException;

    public void getEvents(String uuid, AsyncMethodCallback<AsyncClient.getEvents_call> resultHandler) throws TException;

    public void getAccounts(boolean refresh, AsyncMethodCallback<AsyncClient.getAccounts_call> resultHandler) throws TException;

    public void getAccountTypes(AsyncMethodCallback<AsyncClient.getAccountTypes_call> resultHandler) throws TException;

    public void updateAccount(String plugin, String account, String password, Map<String,String> options, AsyncMethodCallback<AsyncClient.updateAccount_call> resultHandler) throws TException;

    public void removeAccount(String plugin, String account, AsyncMethodCallback<AsyncClient.removeAccount_call> resultHandler) throws TException;

    public void login(String username, String password, AsyncMethodCallback<AsyncClient.login_call> resultHandler) throws TException;

    public void getUserData(String username, String password, AsyncMethodCallback<AsyncClient.getUserData_call> resultHandler) throws TException;

    public void getServices(AsyncMethodCallback<AsyncClient.getServices_call> resultHandler) throws TException;

    public void hasService(String plugin, String func, AsyncMethodCallback<AsyncClient.hasService_call> resultHandler) throws TException;

    public void call(ServiceCall info, AsyncMethodCallback<AsyncClient.call_call> resultHandler) throws TException;

    public void getAllInfo(AsyncMethodCallback<AsyncClient.getAllInfo_call> resultHandler) throws TException;

    public void getInfoByPlugin(String plugin, AsyncMethodCallback<AsyncClient.getInfoByPlugin_call> resultHandler) throws TException;

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public String getConfigValue(String category, String option, String section) throws TException
    {
      send_getConfigValue(category, option, section);
      return recv_getConfigValue();
    }

    public void send_getConfigValue(String category, String option, String section) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getConfigValue", TMessageType.CALL, ++seqid_));
      getConfigValue_args args = new getConfigValue_args();
      args.setCategory(category);
      args.setOption(option);
      args.setSection(section);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getConfigValue() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getConfigValue failed: out of sequence response");
      }
      getConfigValue_result result = new getConfigValue_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfigValue failed: unknown result");
    }

    public void setConfigValue(String category, String option, String value, String section) throws TException
    {
      send_setConfigValue(category, option, value, section);
      recv_setConfigValue();
    }

    public void send_setConfigValue(String category, String option, String value, String section) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setConfigValue", TMessageType.CALL, ++seqid_));
      setConfigValue_args args = new setConfigValue_args();
      args.setCategory(category);
      args.setOption(option);
      args.setValue(value);
      args.setSection(section);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setConfigValue() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setConfigValue failed: out of sequence response");
      }
      setConfigValue_result result = new setConfigValue_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public Map<String,ConfigSection> getConfig() throws TException
    {
      send_getConfig();
      return recv_getConfig();
    }

    public void send_getConfig() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, ++seqid_));
      getConfig_args args = new getConfig_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,ConfigSection> recv_getConfig() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getConfig failed: out of sequence response");
      }
      getConfig_result result = new getConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConfig failed: unknown result");
    }

    public Map<String,ConfigSection> getPluginConfig() throws TException
    {
      send_getPluginConfig();
      return recv_getPluginConfig();
    }

    public void send_getPluginConfig() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getPluginConfig", TMessageType.CALL, ++seqid_));
      getPluginConfig_args args = new getPluginConfig_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,ConfigSection> recv_getPluginConfig() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getPluginConfig failed: out of sequence response");
      }
      getPluginConfig_result result = new getPluginConfig_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPluginConfig failed: unknown result");
    }

    public void pauseServer() throws TException
    {
      send_pauseServer();
      recv_pauseServer();
    }

    public void send_pauseServer() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pauseServer", TMessageType.CALL, ++seqid_));
      pauseServer_args args = new pauseServer_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_pauseServer() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "pauseServer failed: out of sequence response");
      }
      pauseServer_result result = new pauseServer_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void unpauseServer() throws TException
    {
      send_unpauseServer();
      recv_unpauseServer();
    }

    public void send_unpauseServer() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("unpauseServer", TMessageType.CALL, ++seqid_));
      unpauseServer_args args = new unpauseServer_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_unpauseServer() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "unpauseServer failed: out of sequence response");
      }
      unpauseServer_result result = new unpauseServer_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public boolean togglePause() throws TException
    {
      send_togglePause();
      return recv_togglePause();
    }

    public void send_togglePause() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("togglePause", TMessageType.CALL, ++seqid_));
      togglePause_args args = new togglePause_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_togglePause() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "togglePause failed: out of sequence response");
      }
      togglePause_result result = new togglePause_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "togglePause failed: unknown result");
    }

    public ServerStatus statusServer() throws TException
    {
      send_statusServer();
      return recv_statusServer();
    }

    public void send_statusServer() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("statusServer", TMessageType.CALL, ++seqid_));
      statusServer_args args = new statusServer_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ServerStatus recv_statusServer() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "statusServer failed: out of sequence response");
      }
      statusServer_result result = new statusServer_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "statusServer failed: unknown result");
    }

    public long freeSpace() throws TException
    {
      send_freeSpace();
      return recv_freeSpace();
    }

    public void send_freeSpace() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("freeSpace", TMessageType.CALL, ++seqid_));
      freeSpace_args args = new freeSpace_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_freeSpace() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "freeSpace failed: out of sequence response");
      }
      freeSpace_result result = new freeSpace_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "freeSpace failed: unknown result");
    }

    public String getServerVersion() throws TException
    {
      send_getServerVersion();
      return recv_getServerVersion();
    }

    public void send_getServerVersion() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getServerVersion", TMessageType.CALL, ++seqid_));
      getServerVersion_args args = new getServerVersion_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getServerVersion() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getServerVersion failed: out of sequence response");
      }
      getServerVersion_result result = new getServerVersion_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getServerVersion failed: unknown result");
    }

    public void kill() throws TException
    {
      send_kill();
      recv_kill();
    }

    public void send_kill() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("kill", TMessageType.CALL, ++seqid_));
      kill_args args = new kill_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_kill() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "kill failed: out of sequence response");
      }
      kill_result result = new kill_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void restart() throws TException
    {
      send_restart();
      recv_restart();
    }

    public void send_restart() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("restart", TMessageType.CALL, ++seqid_));
      restart_args args = new restart_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_restart() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "restart failed: out of sequence response");
      }
      restart_result result = new restart_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public List<String> getLog(int offset) throws TException
    {
      send_getLog(offset);
      return recv_getLog();
    }

    public void send_getLog(int offset) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getLog", TMessageType.CALL, ++seqid_));
      getLog_args args = new getLog_args();
      args.setOffset(offset);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getLog() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getLog failed: out of sequence response");
      }
      getLog_result result = new getLog_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getLog failed: unknown result");
    }

    public boolean isTimeDownload() throws TException
    {
      send_isTimeDownload();
      return recv_isTimeDownload();
    }

    public void send_isTimeDownload() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("isTimeDownload", TMessageType.CALL, ++seqid_));
      isTimeDownload_args args = new isTimeDownload_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_isTimeDownload() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "isTimeDownload failed: out of sequence response");
      }
      isTimeDownload_result result = new isTimeDownload_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "isTimeDownload failed: unknown result");
    }

    public boolean isTimeReconnect() throws TException
    {
      send_isTimeReconnect();
      return recv_isTimeReconnect();
    }

    public void send_isTimeReconnect() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("isTimeReconnect", TMessageType.CALL, ++seqid_));
      isTimeReconnect_args args = new isTimeReconnect_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_isTimeReconnect() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "isTimeReconnect failed: out of sequence response");
      }
      isTimeReconnect_result result = new isTimeReconnect_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "isTimeReconnect failed: unknown result");
    }

    public boolean toggleReconnect() throws TException
    {
      send_toggleReconnect();
      return recv_toggleReconnect();
    }

    public void send_toggleReconnect() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("toggleReconnect", TMessageType.CALL, ++seqid_));
      toggleReconnect_args args = new toggleReconnect_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_toggleReconnect() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "toggleReconnect failed: out of sequence response");
      }
      toggleReconnect_result result = new toggleReconnect_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "toggleReconnect failed: unknown result");
    }

    public Map<String,List<String>> generatePackages(List<String> links) throws TException
    {
      send_generatePackages(links);
      return recv_generatePackages();
    }

    public void send_generatePackages(List<String> links) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("generatePackages", TMessageType.CALL, ++seqid_));
      generatePackages_args args = new generatePackages_args();
      args.setLinks(links);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,List<String>> recv_generatePackages() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "generatePackages failed: out of sequence response");
      }
      generatePackages_result result = new generatePackages_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "generatePackages failed: unknown result");
    }

    public Map<String,List<String>> checkURLs(List<String> urls) throws TException
    {
      send_checkURLs(urls);
      return recv_checkURLs();
    }

    public void send_checkURLs(List<String> urls) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkURLs", TMessageType.CALL, ++seqid_));
      checkURLs_args args = new checkURLs_args();
      args.setUrls(urls);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,List<String>> recv_checkURLs() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "checkURLs failed: out of sequence response");
      }
      checkURLs_result result = new checkURLs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "checkURLs failed: unknown result");
    }

    public Map<String,List<String>> parseURLs(String html) throws TException
    {
      send_parseURLs(html);
      return recv_parseURLs();
    }

    public void send_parseURLs(String html) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("parseURLs", TMessageType.CALL, ++seqid_));
      parseURLs_args args = new parseURLs_args();
      args.setHtml(html);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,List<String>> recv_parseURLs() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "parseURLs failed: out of sequence response");
      }
      parseURLs_result result = new parseURLs_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "parseURLs failed: unknown result");
    }

    public OnlineCheck checkOnlineStatus(List<String> urls) throws TException
    {
      send_checkOnlineStatus(urls);
      return recv_checkOnlineStatus();
    }

    public void send_checkOnlineStatus(List<String> urls) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkOnlineStatus", TMessageType.CALL, ++seqid_));
      checkOnlineStatus_args args = new checkOnlineStatus_args();
      args.setUrls(urls);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public OnlineCheck recv_checkOnlineStatus() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "checkOnlineStatus failed: out of sequence response");
      }
      checkOnlineStatus_result result = new checkOnlineStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "checkOnlineStatus failed: unknown result");
    }

    public OnlineCheck checkOnlineStatusContainer(List<String> urls, String filename, ByteBuffer data) throws TException
    {
      send_checkOnlineStatusContainer(urls, filename, data);
      return recv_checkOnlineStatusContainer();
    }

    public void send_checkOnlineStatusContainer(List<String> urls, String filename, ByteBuffer data) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkOnlineStatusContainer", TMessageType.CALL, ++seqid_));
      checkOnlineStatusContainer_args args = new checkOnlineStatusContainer_args();
      args.setUrls(urls);
      args.setFilename(filename);
      args.setData(data);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public OnlineCheck recv_checkOnlineStatusContainer() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "checkOnlineStatusContainer failed: out of sequence response");
      }
      checkOnlineStatusContainer_result result = new checkOnlineStatusContainer_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "checkOnlineStatusContainer failed: unknown result");
    }

    public OnlineCheck pollResults(int rid) throws TException
    {
      send_pollResults(rid);
      return recv_pollResults();
    }

    public void send_pollResults(int rid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pollResults", TMessageType.CALL, ++seqid_));
      pollResults_args args = new pollResults_args();
      args.setRid(rid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public OnlineCheck recv_pollResults() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "pollResults failed: out of sequence response");
      }
      pollResults_result result = new pollResults_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "pollResults failed: unknown result");
    }

    public List<DownloadInfo> statusDownloads() throws TException
    {
      send_statusDownloads();
      return recv_statusDownloads();
    }

    public void send_statusDownloads() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("statusDownloads", TMessageType.CALL, ++seqid_));
      statusDownloads_args args = new statusDownloads_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<DownloadInfo> recv_statusDownloads() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "statusDownloads failed: out of sequence response");
      }
      statusDownloads_result result = new statusDownloads_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "statusDownloads failed: unknown result");
    }

    public PackageData getPackageData(int pid) throws PackageDoesNotExists, TException
    {
      send_getPackageData(pid);
      return recv_getPackageData();
    }

    public void send_getPackageData(int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getPackageData", TMessageType.CALL, ++seqid_));
      getPackageData_args args = new getPackageData_args();
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public PackageData recv_getPackageData() throws PackageDoesNotExists, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getPackageData failed: out of sequence response");
      }
      getPackageData_result result = new getPackageData_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPackageData failed: unknown result");
    }

    public PackageData getPackageInfo(int pid) throws PackageDoesNotExists, TException
    {
      send_getPackageInfo(pid);
      return recv_getPackageInfo();
    }

    public void send_getPackageInfo(int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getPackageInfo", TMessageType.CALL, ++seqid_));
      getPackageInfo_args args = new getPackageInfo_args();
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public PackageData recv_getPackageInfo() throws PackageDoesNotExists, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getPackageInfo failed: out of sequence response");
      }
      getPackageInfo_result result = new getPackageInfo_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPackageInfo failed: unknown result");
    }

    public FileData getFileData(int fid) throws FileDoesNotExists, TException
    {
      send_getFileData(fid);
      return recv_getFileData();
    }

    public void send_getFileData(int fid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getFileData", TMessageType.CALL, ++seqid_));
      getFileData_args args = new getFileData_args();
      args.setFid(fid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public FileData recv_getFileData() throws FileDoesNotExists, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getFileData failed: out of sequence response");
      }
      getFileData_result result = new getFileData_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getFileData failed: unknown result");
    }

    public List<PackageData> getQueue() throws TException
    {
      send_getQueue();
      return recv_getQueue();
    }

    public void send_getQueue() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getQueue", TMessageType.CALL, ++seqid_));
      getQueue_args args = new getQueue_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<PackageData> recv_getQueue() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getQueue failed: out of sequence response");
      }
      getQueue_result result = new getQueue_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getQueue failed: unknown result");
    }

    public List<PackageData> getCollector() throws TException
    {
      send_getCollector();
      return recv_getCollector();
    }

    public void send_getCollector() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getCollector", TMessageType.CALL, ++seqid_));
      getCollector_args args = new getCollector_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<PackageData> recv_getCollector() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getCollector failed: out of sequence response");
      }
      getCollector_result result = new getCollector_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getCollector failed: unknown result");
    }

    public List<PackageData> getQueueData() throws TException
    {
      send_getQueueData();
      return recv_getQueueData();
    }

    public void send_getQueueData() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getQueueData", TMessageType.CALL, ++seqid_));
      getQueueData_args args = new getQueueData_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<PackageData> recv_getQueueData() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getQueueData failed: out of sequence response");
      }
      getQueueData_result result = new getQueueData_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getQueueData failed: unknown result");
    }

    public List<PackageData> getCollectorData() throws TException
    {
      send_getCollectorData();
      return recv_getCollectorData();
    }

    public void send_getCollectorData() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getCollectorData", TMessageType.CALL, ++seqid_));
      getCollectorData_args args = new getCollectorData_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<PackageData> recv_getCollectorData() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getCollectorData failed: out of sequence response");
      }
      getCollectorData_result result = new getCollectorData_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getCollectorData failed: unknown result");
    }

    public Map<Short,Integer> getPackageOrder(Destination destination) throws TException
    {
      send_getPackageOrder(destination);
      return recv_getPackageOrder();
    }

    public void send_getPackageOrder(Destination destination) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getPackageOrder", TMessageType.CALL, ++seqid_));
      getPackageOrder_args args = new getPackageOrder_args();
      args.setDestination(destination);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<Short,Integer> recv_getPackageOrder() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getPackageOrder failed: out of sequence response");
      }
      getPackageOrder_result result = new getPackageOrder_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPackageOrder failed: unknown result");
    }

    public Map<Short,Integer> getFileOrder(int pid) throws TException
    {
      send_getFileOrder(pid);
      return recv_getFileOrder();
    }

    public void send_getFileOrder(int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getFileOrder", TMessageType.CALL, ++seqid_));
      getFileOrder_args args = new getFileOrder_args();
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<Short,Integer> recv_getFileOrder() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getFileOrder failed: out of sequence response");
      }
      getFileOrder_result result = new getFileOrder_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getFileOrder failed: unknown result");
    }

    public List<Integer> generateAndAddPackages(List<String> links, Destination dest) throws TException
    {
      send_generateAndAddPackages(links, dest);
      return recv_generateAndAddPackages();
    }

    public void send_generateAndAddPackages(List<String> links, Destination dest) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("generateAndAddPackages", TMessageType.CALL, ++seqid_));
      generateAndAddPackages_args args = new generateAndAddPackages_args();
      args.setLinks(links);
      args.setDest(dest);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Integer> recv_generateAndAddPackages() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "generateAndAddPackages failed: out of sequence response");
      }
      generateAndAddPackages_result result = new generateAndAddPackages_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "generateAndAddPackages failed: unknown result");
    }

    public int addPackage(String name, List<String> links, Destination dest) throws TException
    {
      send_addPackage(name, links, dest);
      return recv_addPackage();
    }

    public void send_addPackage(String name, List<String> links, Destination dest) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("addPackage", TMessageType.CALL, ++seqid_));
      addPackage_args args = new addPackage_args();
      args.setName(name);
      args.setLinks(links);
      args.setDest(dest);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_addPackage() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "addPackage failed: out of sequence response");
      }
      addPackage_result result = new addPackage_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "addPackage failed: unknown result");
    }

    public void addFiles(int pid, List<String> links) throws TException
    {
      send_addFiles(pid, links);
      recv_addFiles();
    }

    public void send_addFiles(int pid, List<String> links) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("addFiles", TMessageType.CALL, ++seqid_));
      addFiles_args args = new addFiles_args();
      args.setPid(pid);
      args.setLinks(links);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_addFiles() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "addFiles failed: out of sequence response");
      }
      addFiles_result result = new addFiles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void uploadContainer(String filename, ByteBuffer data) throws TException
    {
      send_uploadContainer(filename, data);
      recv_uploadContainer();
    }

    public void send_uploadContainer(String filename, ByteBuffer data) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("uploadContainer", TMessageType.CALL, ++seqid_));
      uploadContainer_args args = new uploadContainer_args();
      args.setFilename(filename);
      args.setData(data);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_uploadContainer() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "uploadContainer failed: out of sequence response");
      }
      uploadContainer_result result = new uploadContainer_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void deleteFiles(List<Integer> fids) throws TException
    {
      send_deleteFiles(fids);
      recv_deleteFiles();
    }

    public void send_deleteFiles(List<Integer> fids) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteFiles", TMessageType.CALL, ++seqid_));
      deleteFiles_args args = new deleteFiles_args();
      args.setFids(fids);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteFiles() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteFiles failed: out of sequence response");
      }
      deleteFiles_result result = new deleteFiles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void deletePackages(List<Integer> pids) throws TException
    {
      send_deletePackages(pids);
      recv_deletePackages();
    }

    public void send_deletePackages(List<Integer> pids) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deletePackages", TMessageType.CALL, ++seqid_));
      deletePackages_args args = new deletePackages_args();
      args.setPids(pids);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deletePackages() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deletePackages failed: out of sequence response");
      }
      deletePackages_result result = new deletePackages_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void pushToQueue(int pid) throws TException
    {
      send_pushToQueue(pid);
      recv_pushToQueue();
    }

    public void send_pushToQueue(int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pushToQueue", TMessageType.CALL, ++seqid_));
      pushToQueue_args args = new pushToQueue_args();
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_pushToQueue() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "pushToQueue failed: out of sequence response");
      }
      pushToQueue_result result = new pushToQueue_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void pullFromQueue(int pid) throws TException
    {
      send_pullFromQueue(pid);
      recv_pullFromQueue();
    }

    public void send_pullFromQueue(int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pullFromQueue", TMessageType.CALL, ++seqid_));
      pullFromQueue_args args = new pullFromQueue_args();
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_pullFromQueue() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "pullFromQueue failed: out of sequence response");
      }
      pullFromQueue_result result = new pullFromQueue_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void restartPackage(int pid) throws TException
    {
      send_restartPackage(pid);
      recv_restartPackage();
    }

    public void send_restartPackage(int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("restartPackage", TMessageType.CALL, ++seqid_));
      restartPackage_args args = new restartPackage_args();
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_restartPackage() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "restartPackage failed: out of sequence response");
      }
      restartPackage_result result = new restartPackage_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void restartFile(int fid) throws TException
    {
      send_restartFile(fid);
      recv_restartFile();
    }

    public void send_restartFile(int fid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("restartFile", TMessageType.CALL, ++seqid_));
      restartFile_args args = new restartFile_args();
      args.setFid(fid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_restartFile() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "restartFile failed: out of sequence response");
      }
      restartFile_result result = new restartFile_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void recheckPackage(int pid) throws TException
    {
      send_recheckPackage(pid);
      recv_recheckPackage();
    }

    public void send_recheckPackage(int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("recheckPackage", TMessageType.CALL, ++seqid_));
      recheckPackage_args args = new recheckPackage_args();
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_recheckPackage() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "recheckPackage failed: out of sequence response");
      }
      recheckPackage_result result = new recheckPackage_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void stopAllDownloads() throws TException
    {
      send_stopAllDownloads();
      recv_stopAllDownloads();
    }

    public void send_stopAllDownloads() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("stopAllDownloads", TMessageType.CALL, ++seqid_));
      stopAllDownloads_args args = new stopAllDownloads_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_stopAllDownloads() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "stopAllDownloads failed: out of sequence response");
      }
      stopAllDownloads_result result = new stopAllDownloads_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void stopDownloads(List<Integer> fids) throws TException
    {
      send_stopDownloads(fids);
      recv_stopDownloads();
    }

    public void send_stopDownloads(List<Integer> fids) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("stopDownloads", TMessageType.CALL, ++seqid_));
      stopDownloads_args args = new stopDownloads_args();
      args.setFids(fids);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_stopDownloads() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "stopDownloads failed: out of sequence response");
      }
      stopDownloads_result result = new stopDownloads_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void setPackageName(int pid, String name) throws TException
    {
      send_setPackageName(pid, name);
      recv_setPackageName();
    }

    public void send_setPackageName(int pid, String name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setPackageName", TMessageType.CALL, ++seqid_));
      setPackageName_args args = new setPackageName_args();
      args.setPid(pid);
      args.setName(name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setPackageName() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setPackageName failed: out of sequence response");
      }
      setPackageName_result result = new setPackageName_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void movePackage(Destination destination, int pid) throws TException
    {
      send_movePackage(destination, pid);
      recv_movePackage();
    }

    public void send_movePackage(Destination destination, int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("movePackage", TMessageType.CALL, ++seqid_));
      movePackage_args args = new movePackage_args();
      args.setDestination(destination);
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_movePackage() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "movePackage failed: out of sequence response");
      }
      movePackage_result result = new movePackage_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void moveFiles(List<Integer> fids, int pid) throws TException
    {
      send_moveFiles(fids, pid);
      recv_moveFiles();
    }

    public void send_moveFiles(List<Integer> fids, int pid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("moveFiles", TMessageType.CALL, ++seqid_));
      moveFiles_args args = new moveFiles_args();
      args.setFids(fids);
      args.setPid(pid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_moveFiles() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "moveFiles failed: out of sequence response");
      }
      moveFiles_result result = new moveFiles_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void orderPackage(int pid, short position) throws TException
    {
      send_orderPackage(pid, position);
      recv_orderPackage();
    }

    public void send_orderPackage(int pid, short position) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("orderPackage", TMessageType.CALL, ++seqid_));
      orderPackage_args args = new orderPackage_args();
      args.setPid(pid);
      args.setPosition(position);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_orderPackage() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "orderPackage failed: out of sequence response");
      }
      orderPackage_result result = new orderPackage_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void orderFile(int fid, short position) throws TException
    {
      send_orderFile(fid, position);
      recv_orderFile();
    }

    public void send_orderFile(int fid, short position) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("orderFile", TMessageType.CALL, ++seqid_));
      orderFile_args args = new orderFile_args();
      args.setFid(fid);
      args.setPosition(position);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_orderFile() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "orderFile failed: out of sequence response");
      }
      orderFile_result result = new orderFile_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void setPackageData(int pid, Map<String,String> data) throws PackageDoesNotExists, TException
    {
      send_setPackageData(pid, data);
      recv_setPackageData();
    }

    public void send_setPackageData(int pid, Map<String,String> data) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setPackageData", TMessageType.CALL, ++seqid_));
      setPackageData_args args = new setPackageData_args();
      args.setPid(pid);
      args.setData(data);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setPackageData() throws PackageDoesNotExists, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setPackageData failed: out of sequence response");
      }
      setPackageData_result result = new setPackageData_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.e != null) {
        throw result.e;
      }
      return;
    }

    public void deleteFinished() throws TException
    {
      send_deleteFinished();
      recv_deleteFinished();
    }

    public void send_deleteFinished() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteFinished", TMessageType.CALL, ++seqid_));
      deleteFinished_args args = new deleteFinished_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteFinished() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteFinished failed: out of sequence response");
      }
      deleteFinished_result result = new deleteFinished_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void restartFailed() throws TException
    {
      send_restartFailed();
      recv_restartFailed();
    }

    public void send_restartFailed() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("restartFailed", TMessageType.CALL, ++seqid_));
      restartFailed_args args = new restartFailed_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_restartFailed() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "restartFailed failed: out of sequence response");
      }
      restartFailed_result result = new restartFailed_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public boolean isCaptchaWaiting() throws TException
    {
      send_isCaptchaWaiting();
      return recv_isCaptchaWaiting();
    }

    public void send_isCaptchaWaiting() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("isCaptchaWaiting", TMessageType.CALL, ++seqid_));
      isCaptchaWaiting_args args = new isCaptchaWaiting_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_isCaptchaWaiting() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "isCaptchaWaiting failed: out of sequence response");
      }
      isCaptchaWaiting_result result = new isCaptchaWaiting_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "isCaptchaWaiting failed: unknown result");
    }

    public CaptchaTask getCaptchaTask(boolean exclusive) throws TException
    {
      send_getCaptchaTask(exclusive);
      return recv_getCaptchaTask();
    }

    public void send_getCaptchaTask(boolean exclusive) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getCaptchaTask", TMessageType.CALL, ++seqid_));
      getCaptchaTask_args args = new getCaptchaTask_args();
      args.setExclusive(exclusive);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public CaptchaTask recv_getCaptchaTask() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getCaptchaTask failed: out of sequence response");
      }
      getCaptchaTask_result result = new getCaptchaTask_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getCaptchaTask failed: unknown result");
    }

    public String getCaptchaTaskStatus(int tid) throws TException
    {
      send_getCaptchaTaskStatus(tid);
      return recv_getCaptchaTaskStatus();
    }

    public void send_getCaptchaTaskStatus(int tid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getCaptchaTaskStatus", TMessageType.CALL, ++seqid_));
      getCaptchaTaskStatus_args args = new getCaptchaTaskStatus_args();
      args.setTid(tid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getCaptchaTaskStatus() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getCaptchaTaskStatus failed: out of sequence response");
      }
      getCaptchaTaskStatus_result result = new getCaptchaTaskStatus_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getCaptchaTaskStatus failed: unknown result");
    }

    public void setCaptchaResult(int tid, String result) throws TException
    {
      send_setCaptchaResult(tid, result);
      recv_setCaptchaResult();
    }

    public void send_setCaptchaResult(int tid, String result) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setCaptchaResult", TMessageType.CALL, ++seqid_));
      setCaptchaResult_args args = new setCaptchaResult_args();
      args.setTid(tid);
      args.setResult(result);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setCaptchaResult() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setCaptchaResult failed: out of sequence response");
      }
      setCaptchaResult_result result = new setCaptchaResult_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public List<Event> getEvents(String uuid) throws TException
    {
      send_getEvents(uuid);
      return recv_getEvents();
    }

    public void send_getEvents(String uuid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getEvents", TMessageType.CALL, ++seqid_));
      getEvents_args args = new getEvents_args();
      args.setUuid(uuid);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Event> recv_getEvents() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getEvents failed: out of sequence response");
      }
      getEvents_result result = new getEvents_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getEvents failed: unknown result");
    }

    public List<AccountInfo> getAccounts(boolean refresh) throws TException
    {
      send_getAccounts(refresh);
      return recv_getAccounts();
    }

    public void send_getAccounts(boolean refresh) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getAccounts", TMessageType.CALL, ++seqid_));
      getAccounts_args args = new getAccounts_args();
      args.setRefresh(refresh);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<AccountInfo> recv_getAccounts() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getAccounts failed: out of sequence response");
      }
      getAccounts_result result = new getAccounts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getAccounts failed: unknown result");
    }

    public List<String> getAccountTypes() throws TException
    {
      send_getAccountTypes();
      return recv_getAccountTypes();
    }

    public void send_getAccountTypes() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getAccountTypes", TMessageType.CALL, ++seqid_));
      getAccountTypes_args args = new getAccountTypes_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getAccountTypes() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getAccountTypes failed: out of sequence response");
      }
      getAccountTypes_result result = new getAccountTypes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getAccountTypes failed: unknown result");
    }

    public void updateAccount(String plugin, String account, String password, Map<String,String> options) throws TException
    {
      send_updateAccount(plugin, account, password, options);
      recv_updateAccount();
    }

    public void send_updateAccount(String plugin, String account, String password, Map<String,String> options) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("updateAccount", TMessageType.CALL, ++seqid_));
      updateAccount_args args = new updateAccount_args();
      args.setPlugin(plugin);
      args.setAccount(account);
      args.setPassword(password);
      args.setOptions(options);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_updateAccount() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "updateAccount failed: out of sequence response");
      }
      updateAccount_result result = new updateAccount_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void removeAccount(String plugin, String account) throws TException
    {
      send_removeAccount(plugin, account);
      recv_removeAccount();
    }

    public void send_removeAccount(String plugin, String account) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("removeAccount", TMessageType.CALL, ++seqid_));
      removeAccount_args args = new removeAccount_args();
      args.setPlugin(plugin);
      args.setAccount(account);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_removeAccount() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "removeAccount failed: out of sequence response");
      }
      removeAccount_result result = new removeAccount_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public boolean login(String username, String password) throws TException
    {
      send_login(username, password);
      return recv_login();
    }

    public void send_login(String username, String password) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("login", TMessageType.CALL, ++seqid_));
      login_args args = new login_args();
      args.setUsername(username);
      args.setPassword(password);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_login() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "login failed: out of sequence response");
      }
      login_result result = new login_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");
    }

    public UserData getUserData(String username, String password) throws TException
    {
      send_getUserData(username, password);
      return recv_getUserData();
    }

    public void send_getUserData(String username, String password) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getUserData", TMessageType.CALL, ++seqid_));
      getUserData_args args = new getUserData_args();
      args.setUsername(username);
      args.setPassword(password);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public UserData recv_getUserData() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getUserData failed: out of sequence response");
      }
      getUserData_result result = new getUserData_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getUserData failed: unknown result");
    }

    public Map<String,Map<String,String>> getServices() throws TException
    {
      send_getServices();
      return recv_getServices();
    }

    public void send_getServices() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getServices", TMessageType.CALL, ++seqid_));
      getServices_args args = new getServices_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,Map<String,String>> recv_getServices() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getServices failed: out of sequence response");
      }
      getServices_result result = new getServices_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getServices failed: unknown result");
    }

    public boolean hasService(String plugin, String func) throws TException
    {
      send_hasService(plugin, func);
      return recv_hasService();
    }

    public void send_hasService(String plugin, String func) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("hasService", TMessageType.CALL, ++seqid_));
      hasService_args args = new hasService_args();
      args.setPlugin(plugin);
      args.setFunc(func);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_hasService() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "hasService failed: out of sequence response");
      }
      hasService_result result = new hasService_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "hasService failed: unknown result");
    }

    public String call(ServiceCall info) throws ServiceDoesNotExists, ServiceException, TException
    {
      send_call(info);
      return recv_call();
    }

    public void send_call(ServiceCall info) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("call", TMessageType.CALL, ++seqid_));
      call_args args = new call_args();
      args.setInfo(info);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_call() throws ServiceDoesNotExists, ServiceException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "call failed: out of sequence response");
      }
      call_result result = new call_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex != null) {
        throw result.ex;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "call failed: unknown result");
    }

    public Map<String,Map<String,String>> getAllInfo() throws TException
    {
      send_getAllInfo();
      return recv_getAllInfo();
    }

    public void send_getAllInfo() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getAllInfo", TMessageType.CALL, ++seqid_));
      getAllInfo_args args = new getAllInfo_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,Map<String,String>> recv_getAllInfo() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getAllInfo failed: out of sequence response");
      }
      getAllInfo_result result = new getAllInfo_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getAllInfo failed: unknown result");
    }

    public Map<String,String> getInfoByPlugin(String plugin) throws TException
    {
      send_getInfoByPlugin(plugin);
      return recv_getInfoByPlugin();
    }

    public void send_getInfoByPlugin(String plugin) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getInfoByPlugin", TMessageType.CALL, ++seqid_));
      getInfoByPlugin_args args = new getInfoByPlugin_args();
      args.setPlugin(plugin);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<String,String> recv_getInfoByPlugin() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getInfoByPlugin failed: out of sequence response");
      }
      getInfoByPlugin_result result = new getInfoByPlugin_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getInfoByPlugin failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void getConfigValue(String category, String option, String section, AsyncMethodCallback<getConfigValue_call> resultHandler) throws TException {
      checkReady();
      getConfigValue_call method_call = new getConfigValue_call(category, option, section, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getConfigValue_call extends TAsyncMethodCall {
      private String category;
      private String option;
      private String section;
      public getConfigValue_call(String category, String option, String section, AsyncMethodCallback<getConfigValue_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.category = category;
        this.option = option;
        this.section = section;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getConfigValue", TMessageType.CALL, 0));
        getConfigValue_args args = new getConfigValue_args();
        args.setCategory(category);
        args.setOption(option);
        args.setSection(section);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getConfigValue();
      }
    }

    public void setConfigValue(String category, String option, String value, String section, AsyncMethodCallback<setConfigValue_call> resultHandler) throws TException {
      checkReady();
      setConfigValue_call method_call = new setConfigValue_call(category, option, value, section, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setConfigValue_call extends TAsyncMethodCall {
      private String category;
      private String option;
      private String value;
      private String section;
      public setConfigValue_call(String category, String option, String value, String section, AsyncMethodCallback<setConfigValue_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.category = category;
        this.option = option;
        this.value = value;
        this.section = section;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setConfigValue", TMessageType.CALL, 0));
        setConfigValue_args args = new setConfigValue_args();
        args.setCategory(category);
        args.setOption(option);
        args.setValue(value);
        args.setSection(section);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_setConfigValue();
      }
    }

    public void getConfig(AsyncMethodCallback<getConfig_call> resultHandler) throws TException {
      checkReady();
      getConfig_call method_call = new getConfig_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getConfig_call extends TAsyncMethodCall {
      public getConfig_call(AsyncMethodCallback<getConfig_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getConfig", TMessageType.CALL, 0));
        getConfig_args args = new getConfig_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,ConfigSection> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getConfig();
      }
    }

    public void getPluginConfig(AsyncMethodCallback<getPluginConfig_call> resultHandler) throws TException {
      checkReady();
      getPluginConfig_call method_call = new getPluginConfig_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getPluginConfig_call extends TAsyncMethodCall {
      public getPluginConfig_call(AsyncMethodCallback<getPluginConfig_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPluginConfig", TMessageType.CALL, 0));
        getPluginConfig_args args = new getPluginConfig_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,ConfigSection> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPluginConfig();
      }
    }

    public void pauseServer(AsyncMethodCallback<pauseServer_call> resultHandler) throws TException {
      checkReady();
      pauseServer_call method_call = new pauseServer_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class pauseServer_call extends TAsyncMethodCall {
      public pauseServer_call(AsyncMethodCallback<pauseServer_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("pauseServer", TMessageType.CALL, 0));
        pauseServer_args args = new pauseServer_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_pauseServer();
      }
    }

    public void unpauseServer(AsyncMethodCallback<unpauseServer_call> resultHandler) throws TException {
      checkReady();
      unpauseServer_call method_call = new unpauseServer_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class unpauseServer_call extends TAsyncMethodCall {
      public unpauseServer_call(AsyncMethodCallback<unpauseServer_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("unpauseServer", TMessageType.CALL, 0));
        unpauseServer_args args = new unpauseServer_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_unpauseServer();
      }
    }

    public void togglePause(AsyncMethodCallback<togglePause_call> resultHandler) throws TException {
      checkReady();
      togglePause_call method_call = new togglePause_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class togglePause_call extends TAsyncMethodCall {
      public togglePause_call(AsyncMethodCallback<togglePause_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("togglePause", TMessageType.CALL, 0));
        togglePause_args args = new togglePause_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_togglePause();
      }
    }

    public void statusServer(AsyncMethodCallback<statusServer_call> resultHandler) throws TException {
      checkReady();
      statusServer_call method_call = new statusServer_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class statusServer_call extends TAsyncMethodCall {
      public statusServer_call(AsyncMethodCallback<statusServer_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("statusServer", TMessageType.CALL, 0));
        statusServer_args args = new statusServer_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ServerStatus getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statusServer();
      }
    }

    public void freeSpace(AsyncMethodCallback<freeSpace_call> resultHandler) throws TException {
      checkReady();
      freeSpace_call method_call = new freeSpace_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class freeSpace_call extends TAsyncMethodCall {
      public freeSpace_call(AsyncMethodCallback<freeSpace_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("freeSpace", TMessageType.CALL, 0));
        freeSpace_args args = new freeSpace_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_freeSpace();
      }
    }

    public void getServerVersion(AsyncMethodCallback<getServerVersion_call> resultHandler) throws TException {
      checkReady();
      getServerVersion_call method_call = new getServerVersion_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getServerVersion_call extends TAsyncMethodCall {
      public getServerVersion_call(AsyncMethodCallback<getServerVersion_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getServerVersion", TMessageType.CALL, 0));
        getServerVersion_args args = new getServerVersion_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getServerVersion();
      }
    }

    public void kill(AsyncMethodCallback<kill_call> resultHandler) throws TException {
      checkReady();
      kill_call method_call = new kill_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class kill_call extends TAsyncMethodCall {
      public kill_call(AsyncMethodCallback<kill_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("kill", TMessageType.CALL, 0));
        kill_args args = new kill_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_kill();
      }
    }

    public void restart(AsyncMethodCallback<restart_call> resultHandler) throws TException {
      checkReady();
      restart_call method_call = new restart_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class restart_call extends TAsyncMethodCall {
      public restart_call(AsyncMethodCallback<restart_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("restart", TMessageType.CALL, 0));
        restart_args args = new restart_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_restart();
      }
    }

    public void getLog(int offset, AsyncMethodCallback<getLog_call> resultHandler) throws TException {
      checkReady();
      getLog_call method_call = new getLog_call(offset, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getLog_call extends TAsyncMethodCall {
      private int offset;
      public getLog_call(int offset, AsyncMethodCallback<getLog_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.offset = offset;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getLog", TMessageType.CALL, 0));
        getLog_args args = new getLog_args();
        args.setOffset(offset);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getLog();
      }
    }

    public void isTimeDownload(AsyncMethodCallback<isTimeDownload_call> resultHandler) throws TException {
      checkReady();
      isTimeDownload_call method_call = new isTimeDownload_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class isTimeDownload_call extends TAsyncMethodCall {
      public isTimeDownload_call(AsyncMethodCallback<isTimeDownload_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("isTimeDownload", TMessageType.CALL, 0));
        isTimeDownload_args args = new isTimeDownload_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_isTimeDownload();
      }
    }

    public void isTimeReconnect(AsyncMethodCallback<isTimeReconnect_call> resultHandler) throws TException {
      checkReady();
      isTimeReconnect_call method_call = new isTimeReconnect_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class isTimeReconnect_call extends TAsyncMethodCall {
      public isTimeReconnect_call(AsyncMethodCallback<isTimeReconnect_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("isTimeReconnect", TMessageType.CALL, 0));
        isTimeReconnect_args args = new isTimeReconnect_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_isTimeReconnect();
      }
    }

    public void toggleReconnect(AsyncMethodCallback<toggleReconnect_call> resultHandler) throws TException {
      checkReady();
      toggleReconnect_call method_call = new toggleReconnect_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class toggleReconnect_call extends TAsyncMethodCall {
      public toggleReconnect_call(AsyncMethodCallback<toggleReconnect_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("toggleReconnect", TMessageType.CALL, 0));
        toggleReconnect_args args = new toggleReconnect_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_toggleReconnect();
      }
    }

    public void generatePackages(List<String> links, AsyncMethodCallback<generatePackages_call> resultHandler) throws TException {
      checkReady();
      generatePackages_call method_call = new generatePackages_call(links, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class generatePackages_call extends TAsyncMethodCall {
      private List<String> links;
      public generatePackages_call(List<String> links, AsyncMethodCallback<generatePackages_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.links = links;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("generatePackages", TMessageType.CALL, 0));
        generatePackages_args args = new generatePackages_args();
        args.setLinks(links);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,List<String>> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_generatePackages();
      }
    }

    public void checkURLs(List<String> urls, AsyncMethodCallback<checkURLs_call> resultHandler) throws TException {
      checkReady();
      checkURLs_call method_call = new checkURLs_call(urls, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class checkURLs_call extends TAsyncMethodCall {
      private List<String> urls;
      public checkURLs_call(List<String> urls, AsyncMethodCallback<checkURLs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.urls = urls;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("checkURLs", TMessageType.CALL, 0));
        checkURLs_args args = new checkURLs_args();
        args.setUrls(urls);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,List<String>> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_checkURLs();
      }
    }

    public void parseURLs(String html, AsyncMethodCallback<parseURLs_call> resultHandler) throws TException {
      checkReady();
      parseURLs_call method_call = new parseURLs_call(html, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class parseURLs_call extends TAsyncMethodCall {
      private String html;
      public parseURLs_call(String html, AsyncMethodCallback<parseURLs_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.html = html;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("parseURLs", TMessageType.CALL, 0));
        parseURLs_args args = new parseURLs_args();
        args.setHtml(html);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,List<String>> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_parseURLs();
      }
    }

    public void checkOnlineStatus(List<String> urls, AsyncMethodCallback<checkOnlineStatus_call> resultHandler) throws TException {
      checkReady();
      checkOnlineStatus_call method_call = new checkOnlineStatus_call(urls, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class checkOnlineStatus_call extends TAsyncMethodCall {
      private List<String> urls;
      public checkOnlineStatus_call(List<String> urls, AsyncMethodCallback<checkOnlineStatus_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.urls = urls;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("checkOnlineStatus", TMessageType.CALL, 0));
        checkOnlineStatus_args args = new checkOnlineStatus_args();
        args.setUrls(urls);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public OnlineCheck getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_checkOnlineStatus();
      }
    }

    public void checkOnlineStatusContainer(List<String> urls, String filename, ByteBuffer data, AsyncMethodCallback<checkOnlineStatusContainer_call> resultHandler) throws TException {
      checkReady();
      checkOnlineStatusContainer_call method_call = new checkOnlineStatusContainer_call(urls, filename, data, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class checkOnlineStatusContainer_call extends TAsyncMethodCall {
      private List<String> urls;
      private String filename;
      private ByteBuffer data;
      public checkOnlineStatusContainer_call(List<String> urls, String filename, ByteBuffer data, AsyncMethodCallback<checkOnlineStatusContainer_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.urls = urls;
        this.filename = filename;
        this.data = data;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("checkOnlineStatusContainer", TMessageType.CALL, 0));
        checkOnlineStatusContainer_args args = new checkOnlineStatusContainer_args();
        args.setUrls(urls);
        args.setFilename(filename);
        args.setData(data);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public OnlineCheck getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_checkOnlineStatusContainer();
      }
    }

    public void pollResults(int rid, AsyncMethodCallback<pollResults_call> resultHandler) throws TException {
      checkReady();
      pollResults_call method_call = new pollResults_call(rid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class pollResults_call extends TAsyncMethodCall {
      private int rid;
      public pollResults_call(int rid, AsyncMethodCallback<pollResults_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.rid = rid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("pollResults", TMessageType.CALL, 0));
        pollResults_args args = new pollResults_args();
        args.setRid(rid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public OnlineCheck getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_pollResults();
      }
    }

    public void statusDownloads(AsyncMethodCallback<statusDownloads_call> resultHandler) throws TException {
      checkReady();
      statusDownloads_call method_call = new statusDownloads_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class statusDownloads_call extends TAsyncMethodCall {
      public statusDownloads_call(AsyncMethodCallback<statusDownloads_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("statusDownloads", TMessageType.CALL, 0));
        statusDownloads_args args = new statusDownloads_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<DownloadInfo> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_statusDownloads();
      }
    }

    public void getPackageData(int pid, AsyncMethodCallback<getPackageData_call> resultHandler) throws TException {
      checkReady();
      getPackageData_call method_call = new getPackageData_call(pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getPackageData_call extends TAsyncMethodCall {
      private int pid;
      public getPackageData_call(int pid, AsyncMethodCallback<getPackageData_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPackageData", TMessageType.CALL, 0));
        getPackageData_args args = new getPackageData_args();
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public PackageData getResult() throws PackageDoesNotExists, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPackageData();
      }
    }

    public void getPackageInfo(int pid, AsyncMethodCallback<getPackageInfo_call> resultHandler) throws TException {
      checkReady();
      getPackageInfo_call method_call = new getPackageInfo_call(pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getPackageInfo_call extends TAsyncMethodCall {
      private int pid;
      public getPackageInfo_call(int pid, AsyncMethodCallback<getPackageInfo_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPackageInfo", TMessageType.CALL, 0));
        getPackageInfo_args args = new getPackageInfo_args();
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public PackageData getResult() throws PackageDoesNotExists, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPackageInfo();
      }
    }

    public void getFileData(int fid, AsyncMethodCallback<getFileData_call> resultHandler) throws TException {
      checkReady();
      getFileData_call method_call = new getFileData_call(fid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getFileData_call extends TAsyncMethodCall {
      private int fid;
      public getFileData_call(int fid, AsyncMethodCallback<getFileData_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.fid = fid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getFileData", TMessageType.CALL, 0));
        getFileData_args args = new getFileData_args();
        args.setFid(fid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public FileData getResult() throws FileDoesNotExists, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getFileData();
      }
    }

    public void getQueue(AsyncMethodCallback<getQueue_call> resultHandler) throws TException {
      checkReady();
      getQueue_call method_call = new getQueue_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getQueue_call extends TAsyncMethodCall {
      public getQueue_call(AsyncMethodCallback<getQueue_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getQueue", TMessageType.CALL, 0));
        getQueue_args args = new getQueue_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<PackageData> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getQueue();
      }
    }

    public void getCollector(AsyncMethodCallback<getCollector_call> resultHandler) throws TException {
      checkReady();
      getCollector_call method_call = new getCollector_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getCollector_call extends TAsyncMethodCall {
      public getCollector_call(AsyncMethodCallback<getCollector_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getCollector", TMessageType.CALL, 0));
        getCollector_args args = new getCollector_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<PackageData> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getCollector();
      }
    }

    public void getQueueData(AsyncMethodCallback<getQueueData_call> resultHandler) throws TException {
      checkReady();
      getQueueData_call method_call = new getQueueData_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getQueueData_call extends TAsyncMethodCall {
      public getQueueData_call(AsyncMethodCallback<getQueueData_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getQueueData", TMessageType.CALL, 0));
        getQueueData_args args = new getQueueData_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<PackageData> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getQueueData();
      }
    }

    public void getCollectorData(AsyncMethodCallback<getCollectorData_call> resultHandler) throws TException {
      checkReady();
      getCollectorData_call method_call = new getCollectorData_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getCollectorData_call extends TAsyncMethodCall {
      public getCollectorData_call(AsyncMethodCallback<getCollectorData_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getCollectorData", TMessageType.CALL, 0));
        getCollectorData_args args = new getCollectorData_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<PackageData> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getCollectorData();
      }
    }

    public void getPackageOrder(Destination destination, AsyncMethodCallback<getPackageOrder_call> resultHandler) throws TException {
      checkReady();
      getPackageOrder_call method_call = new getPackageOrder_call(destination, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getPackageOrder_call extends TAsyncMethodCall {
      private Destination destination;
      public getPackageOrder_call(Destination destination, AsyncMethodCallback<getPackageOrder_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.destination = destination;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getPackageOrder", TMessageType.CALL, 0));
        getPackageOrder_args args = new getPackageOrder_args();
        args.setDestination(destination);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<Short,Integer> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getPackageOrder();
      }
    }

    public void getFileOrder(int pid, AsyncMethodCallback<getFileOrder_call> resultHandler) throws TException {
      checkReady();
      getFileOrder_call method_call = new getFileOrder_call(pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getFileOrder_call extends TAsyncMethodCall {
      private int pid;
      public getFileOrder_call(int pid, AsyncMethodCallback<getFileOrder_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getFileOrder", TMessageType.CALL, 0));
        getFileOrder_args args = new getFileOrder_args();
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<Short,Integer> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getFileOrder();
      }
    }

    public void generateAndAddPackages(List<String> links, Destination dest, AsyncMethodCallback<generateAndAddPackages_call> resultHandler) throws TException {
      checkReady();
      generateAndAddPackages_call method_call = new generateAndAddPackages_call(links, dest, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class generateAndAddPackages_call extends TAsyncMethodCall {
      private List<String> links;
      private Destination dest;
      public generateAndAddPackages_call(List<String> links, Destination dest, AsyncMethodCallback<generateAndAddPackages_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.links = links;
        this.dest = dest;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("generateAndAddPackages", TMessageType.CALL, 0));
        generateAndAddPackages_args args = new generateAndAddPackages_args();
        args.setLinks(links);
        args.setDest(dest);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Integer> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_generateAndAddPackages();
      }
    }

    public void addPackage(String name, List<String> links, Destination dest, AsyncMethodCallback<addPackage_call> resultHandler) throws TException {
      checkReady();
      addPackage_call method_call = new addPackage_call(name, links, dest, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class addPackage_call extends TAsyncMethodCall {
      private String name;
      private List<String> links;
      private Destination dest;
      public addPackage_call(String name, List<String> links, Destination dest, AsyncMethodCallback<addPackage_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.name = name;
        this.links = links;
        this.dest = dest;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addPackage", TMessageType.CALL, 0));
        addPackage_args args = new addPackage_args();
        args.setName(name);
        args.setLinks(links);
        args.setDest(dest);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_addPackage();
      }
    }

    public void addFiles(int pid, List<String> links, AsyncMethodCallback<addFiles_call> resultHandler) throws TException {
      checkReady();
      addFiles_call method_call = new addFiles_call(pid, links, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class addFiles_call extends TAsyncMethodCall {
      private int pid;
      private List<String> links;
      public addFiles_call(int pid, List<String> links, AsyncMethodCallback<addFiles_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
        this.links = links;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("addFiles", TMessageType.CALL, 0));
        addFiles_args args = new addFiles_args();
        args.setPid(pid);
        args.setLinks(links);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_addFiles();
      }
    }

    public void uploadContainer(String filename, ByteBuffer data, AsyncMethodCallback<uploadContainer_call> resultHandler) throws TException {
      checkReady();
      uploadContainer_call method_call = new uploadContainer_call(filename, data, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class uploadContainer_call extends TAsyncMethodCall {
      private String filename;
      private ByteBuffer data;
      public uploadContainer_call(String filename, ByteBuffer data, AsyncMethodCallback<uploadContainer_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.filename = filename;
        this.data = data;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("uploadContainer", TMessageType.CALL, 0));
        uploadContainer_args args = new uploadContainer_args();
        args.setFilename(filename);
        args.setData(data);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_uploadContainer();
      }
    }

    public void deleteFiles(List<Integer> fids, AsyncMethodCallback<deleteFiles_call> resultHandler) throws TException {
      checkReady();
      deleteFiles_call method_call = new deleteFiles_call(fids, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteFiles_call extends TAsyncMethodCall {
      private List<Integer> fids;
      public deleteFiles_call(List<Integer> fids, AsyncMethodCallback<deleteFiles_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.fids = fids;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteFiles", TMessageType.CALL, 0));
        deleteFiles_args args = new deleteFiles_args();
        args.setFids(fids);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteFiles();
      }
    }

    public void deletePackages(List<Integer> pids, AsyncMethodCallback<deletePackages_call> resultHandler) throws TException {
      checkReady();
      deletePackages_call method_call = new deletePackages_call(pids, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deletePackages_call extends TAsyncMethodCall {
      private List<Integer> pids;
      public deletePackages_call(List<Integer> pids, AsyncMethodCallback<deletePackages_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pids = pids;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deletePackages", TMessageType.CALL, 0));
        deletePackages_args args = new deletePackages_args();
        args.setPids(pids);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deletePackages();
      }
    }

    public void pushToQueue(int pid, AsyncMethodCallback<pushToQueue_call> resultHandler) throws TException {
      checkReady();
      pushToQueue_call method_call = new pushToQueue_call(pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class pushToQueue_call extends TAsyncMethodCall {
      private int pid;
      public pushToQueue_call(int pid, AsyncMethodCallback<pushToQueue_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("pushToQueue", TMessageType.CALL, 0));
        pushToQueue_args args = new pushToQueue_args();
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_pushToQueue();
      }
    }

    public void pullFromQueue(int pid, AsyncMethodCallback<pullFromQueue_call> resultHandler) throws TException {
      checkReady();
      pullFromQueue_call method_call = new pullFromQueue_call(pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class pullFromQueue_call extends TAsyncMethodCall {
      private int pid;
      public pullFromQueue_call(int pid, AsyncMethodCallback<pullFromQueue_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("pullFromQueue", TMessageType.CALL, 0));
        pullFromQueue_args args = new pullFromQueue_args();
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_pullFromQueue();
      }
    }

    public void restartPackage(int pid, AsyncMethodCallback<restartPackage_call> resultHandler) throws TException {
      checkReady();
      restartPackage_call method_call = new restartPackage_call(pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class restartPackage_call extends TAsyncMethodCall {
      private int pid;
      public restartPackage_call(int pid, AsyncMethodCallback<restartPackage_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("restartPackage", TMessageType.CALL, 0));
        restartPackage_args args = new restartPackage_args();
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_restartPackage();
      }
    }

    public void restartFile(int fid, AsyncMethodCallback<restartFile_call> resultHandler) throws TException {
      checkReady();
      restartFile_call method_call = new restartFile_call(fid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class restartFile_call extends TAsyncMethodCall {
      private int fid;
      public restartFile_call(int fid, AsyncMethodCallback<restartFile_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.fid = fid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("restartFile", TMessageType.CALL, 0));
        restartFile_args args = new restartFile_args();
        args.setFid(fid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_restartFile();
      }
    }

    public void recheckPackage(int pid, AsyncMethodCallback<recheckPackage_call> resultHandler) throws TException {
      checkReady();
      recheckPackage_call method_call = new recheckPackage_call(pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class recheckPackage_call extends TAsyncMethodCall {
      private int pid;
      public recheckPackage_call(int pid, AsyncMethodCallback<recheckPackage_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("recheckPackage", TMessageType.CALL, 0));
        recheckPackage_args args = new recheckPackage_args();
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_recheckPackage();
      }
    }

    public void stopAllDownloads(AsyncMethodCallback<stopAllDownloads_call> resultHandler) throws TException {
      checkReady();
      stopAllDownloads_call method_call = new stopAllDownloads_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class stopAllDownloads_call extends TAsyncMethodCall {
      public stopAllDownloads_call(AsyncMethodCallback<stopAllDownloads_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("stopAllDownloads", TMessageType.CALL, 0));
        stopAllDownloads_args args = new stopAllDownloads_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_stopAllDownloads();
      }
    }

    public void stopDownloads(List<Integer> fids, AsyncMethodCallback<stopDownloads_call> resultHandler) throws TException {
      checkReady();
      stopDownloads_call method_call = new stopDownloads_call(fids, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class stopDownloads_call extends TAsyncMethodCall {
      private List<Integer> fids;
      public stopDownloads_call(List<Integer> fids, AsyncMethodCallback<stopDownloads_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.fids = fids;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("stopDownloads", TMessageType.CALL, 0));
        stopDownloads_args args = new stopDownloads_args();
        args.setFids(fids);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_stopDownloads();
      }
    }

    public void setPackageName(int pid, String name, AsyncMethodCallback<setPackageName_call> resultHandler) throws TException {
      checkReady();
      setPackageName_call method_call = new setPackageName_call(pid, name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setPackageName_call extends TAsyncMethodCall {
      private int pid;
      private String name;
      public setPackageName_call(int pid, String name, AsyncMethodCallback<setPackageName_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
        this.name = name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setPackageName", TMessageType.CALL, 0));
        setPackageName_args args = new setPackageName_args();
        args.setPid(pid);
        args.setName(name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_setPackageName();
      }
    }

    public void movePackage(Destination destination, int pid, AsyncMethodCallback<movePackage_call> resultHandler) throws TException {
      checkReady();
      movePackage_call method_call = new movePackage_call(destination, pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class movePackage_call extends TAsyncMethodCall {
      private Destination destination;
      private int pid;
      public movePackage_call(Destination destination, int pid, AsyncMethodCallback<movePackage_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.destination = destination;
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("movePackage", TMessageType.CALL, 0));
        movePackage_args args = new movePackage_args();
        args.setDestination(destination);
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_movePackage();
      }
    }

    public void moveFiles(List<Integer> fids, int pid, AsyncMethodCallback<moveFiles_call> resultHandler) throws TException {
      checkReady();
      moveFiles_call method_call = new moveFiles_call(fids, pid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class moveFiles_call extends TAsyncMethodCall {
      private List<Integer> fids;
      private int pid;
      public moveFiles_call(List<Integer> fids, int pid, AsyncMethodCallback<moveFiles_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.fids = fids;
        this.pid = pid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("moveFiles", TMessageType.CALL, 0));
        moveFiles_args args = new moveFiles_args();
        args.setFids(fids);
        args.setPid(pid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_moveFiles();
      }
    }

    public void orderPackage(int pid, short position, AsyncMethodCallback<orderPackage_call> resultHandler) throws TException {
      checkReady();
      orderPackage_call method_call = new orderPackage_call(pid, position, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class orderPackage_call extends TAsyncMethodCall {
      private int pid;
      private short position;
      public orderPackage_call(int pid, short position, AsyncMethodCallback<orderPackage_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
        this.position = position;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("orderPackage", TMessageType.CALL, 0));
        orderPackage_args args = new orderPackage_args();
        args.setPid(pid);
        args.setPosition(position);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_orderPackage();
      }
    }

    public void orderFile(int fid, short position, AsyncMethodCallback<orderFile_call> resultHandler) throws TException {
      checkReady();
      orderFile_call method_call = new orderFile_call(fid, position, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class orderFile_call extends TAsyncMethodCall {
      private int fid;
      private short position;
      public orderFile_call(int fid, short position, AsyncMethodCallback<orderFile_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.fid = fid;
        this.position = position;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("orderFile", TMessageType.CALL, 0));
        orderFile_args args = new orderFile_args();
        args.setFid(fid);
        args.setPosition(position);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_orderFile();
      }
    }

    public void setPackageData(int pid, Map<String,String> data, AsyncMethodCallback<setPackageData_call> resultHandler) throws TException {
      checkReady();
      setPackageData_call method_call = new setPackageData_call(pid, data, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setPackageData_call extends TAsyncMethodCall {
      private int pid;
      private Map<String,String> data;
      public setPackageData_call(int pid, Map<String,String> data, AsyncMethodCallback<setPackageData_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.pid = pid;
        this.data = data;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setPackageData", TMessageType.CALL, 0));
        setPackageData_args args = new setPackageData_args();
        args.setPid(pid);
        args.setData(data);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws PackageDoesNotExists, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_setPackageData();
      }
    }

    public void deleteFinished(AsyncMethodCallback<deleteFinished_call> resultHandler) throws TException {
      checkReady();
      deleteFinished_call method_call = new deleteFinished_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteFinished_call extends TAsyncMethodCall {
      public deleteFinished_call(AsyncMethodCallback<deleteFinished_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteFinished", TMessageType.CALL, 0));
        deleteFinished_args args = new deleteFinished_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteFinished();
      }
    }

    public void restartFailed(AsyncMethodCallback<restartFailed_call> resultHandler) throws TException {
      checkReady();
      restartFailed_call method_call = new restartFailed_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class restartFailed_call extends TAsyncMethodCall {
      public restartFailed_call(AsyncMethodCallback<restartFailed_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("restartFailed", TMessageType.CALL, 0));
        restartFailed_args args = new restartFailed_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_restartFailed();
      }
    }

    public void isCaptchaWaiting(AsyncMethodCallback<isCaptchaWaiting_call> resultHandler) throws TException {
      checkReady();
      isCaptchaWaiting_call method_call = new isCaptchaWaiting_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class isCaptchaWaiting_call extends TAsyncMethodCall {
      public isCaptchaWaiting_call(AsyncMethodCallback<isCaptchaWaiting_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("isCaptchaWaiting", TMessageType.CALL, 0));
        isCaptchaWaiting_args args = new isCaptchaWaiting_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_isCaptchaWaiting();
      }
    }

    public void getCaptchaTask(boolean exclusive, AsyncMethodCallback<getCaptchaTask_call> resultHandler) throws TException {
      checkReady();
      getCaptchaTask_call method_call = new getCaptchaTask_call(exclusive, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getCaptchaTask_call extends TAsyncMethodCall {
      private boolean exclusive;
      public getCaptchaTask_call(boolean exclusive, AsyncMethodCallback<getCaptchaTask_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.exclusive = exclusive;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getCaptchaTask", TMessageType.CALL, 0));
        getCaptchaTask_args args = new getCaptchaTask_args();
        args.setExclusive(exclusive);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public CaptchaTask getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getCaptchaTask();
      }
    }

    public void getCaptchaTaskStatus(int tid, AsyncMethodCallback<getCaptchaTaskStatus_call> resultHandler) throws TException {
      checkReady();
      getCaptchaTaskStatus_call method_call = new getCaptchaTaskStatus_call(tid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getCaptchaTaskStatus_call extends TAsyncMethodCall {
      private int tid;
      public getCaptchaTaskStatus_call(int tid, AsyncMethodCallback<getCaptchaTaskStatus_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tid = tid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getCaptchaTaskStatus", TMessageType.CALL, 0));
        getCaptchaTaskStatus_args args = new getCaptchaTaskStatus_args();
        args.setTid(tid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getCaptchaTaskStatus();
      }
    }

    public void setCaptchaResult(int tid, String result, AsyncMethodCallback<setCaptchaResult_call> resultHandler) throws TException {
      checkReady();
      setCaptchaResult_call method_call = new setCaptchaResult_call(tid, result, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setCaptchaResult_call extends TAsyncMethodCall {
      private int tid;
      private String result;
      public setCaptchaResult_call(int tid, String result, AsyncMethodCallback<setCaptchaResult_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.tid = tid;
        this.result = result;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setCaptchaResult", TMessageType.CALL, 0));
        setCaptchaResult_args args = new setCaptchaResult_args();
        args.setTid(tid);
        args.setResult(result);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_setCaptchaResult();
      }
    }

    public void getEvents(String uuid, AsyncMethodCallback<getEvents_call> resultHandler) throws TException {
      checkReady();
      getEvents_call method_call = new getEvents_call(uuid, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getEvents_call extends TAsyncMethodCall {
      private String uuid;
      public getEvents_call(String uuid, AsyncMethodCallback<getEvents_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.uuid = uuid;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getEvents", TMessageType.CALL, 0));
        getEvents_args args = new getEvents_args();
        args.setUuid(uuid);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Event> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getEvents();
      }
    }

    public void getAccounts(boolean refresh, AsyncMethodCallback<getAccounts_call> resultHandler) throws TException {
      checkReady();
      getAccounts_call method_call = new getAccounts_call(refresh, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getAccounts_call extends TAsyncMethodCall {
      private boolean refresh;
      public getAccounts_call(boolean refresh, AsyncMethodCallback<getAccounts_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.refresh = refresh;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getAccounts", TMessageType.CALL, 0));
        getAccounts_args args = new getAccounts_args();
        args.setRefresh(refresh);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<AccountInfo> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getAccounts();
      }
    }

    public void getAccountTypes(AsyncMethodCallback<getAccountTypes_call> resultHandler) throws TException {
      checkReady();
      getAccountTypes_call method_call = new getAccountTypes_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getAccountTypes_call extends TAsyncMethodCall {
      public getAccountTypes_call(AsyncMethodCallback<getAccountTypes_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getAccountTypes", TMessageType.CALL, 0));
        getAccountTypes_args args = new getAccountTypes_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getAccountTypes();
      }
    }

    public void updateAccount(String plugin, String account, String password, Map<String,String> options, AsyncMethodCallback<updateAccount_call> resultHandler) throws TException {
      checkReady();
      updateAccount_call method_call = new updateAccount_call(plugin, account, password, options, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class updateAccount_call extends TAsyncMethodCall {
      private String plugin;
      private String account;
      private String password;
      private Map<String,String> options;
      public updateAccount_call(String plugin, String account, String password, Map<String,String> options, AsyncMethodCallback<updateAccount_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.plugin = plugin;
        this.account = account;
        this.password = password;
        this.options = options;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("updateAccount", TMessageType.CALL, 0));
        updateAccount_args args = new updateAccount_args();
        args.setPlugin(plugin);
        args.setAccount(account);
        args.setPassword(password);
        args.setOptions(options);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_updateAccount();
      }
    }

    public void removeAccount(String plugin, String account, AsyncMethodCallback<removeAccount_call> resultHandler) throws TException {
      checkReady();
      removeAccount_call method_call = new removeAccount_call(plugin, account, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class removeAccount_call extends TAsyncMethodCall {
      private String plugin;
      private String account;
      public removeAccount_call(String plugin, String account, AsyncMethodCallback<removeAccount_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.plugin = plugin;
        this.account = account;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("removeAccount", TMessageType.CALL, 0));
        removeAccount_args args = new removeAccount_args();
        args.setPlugin(plugin);
        args.setAccount(account);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_removeAccount();
      }
    }

    public void login(String username, String password, AsyncMethodCallback<login_call> resultHandler) throws TException {
      checkReady();
      login_call method_call = new login_call(username, password, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class login_call extends TAsyncMethodCall {
      private String username;
      private String password;
      public login_call(String username, String password, AsyncMethodCallback<login_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.username = username;
        this.password = password;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("login", TMessageType.CALL, 0));
        login_args args = new login_args();
        args.setUsername(username);
        args.setPassword(password);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_login();
      }
    }

    public void getUserData(String username, String password, AsyncMethodCallback<getUserData_call> resultHandler) throws TException {
      checkReady();
      getUserData_call method_call = new getUserData_call(username, password, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getUserData_call extends TAsyncMethodCall {
      private String username;
      private String password;
      public getUserData_call(String username, String password, AsyncMethodCallback<getUserData_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.username = username;
        this.password = password;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getUserData", TMessageType.CALL, 0));
        getUserData_args args = new getUserData_args();
        args.setUsername(username);
        args.setPassword(password);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public UserData getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getUserData();
      }
    }

    public void getServices(AsyncMethodCallback<getServices_call> resultHandler) throws TException {
      checkReady();
      getServices_call method_call = new getServices_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getServices_call extends TAsyncMethodCall {
      public getServices_call(AsyncMethodCallback<getServices_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getServices", TMessageType.CALL, 0));
        getServices_args args = new getServices_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,Map<String,String>> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getServices();
      }
    }

    public void hasService(String plugin, String func, AsyncMethodCallback<hasService_call> resultHandler) throws TException {
      checkReady();
      hasService_call method_call = new hasService_call(plugin, func, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class hasService_call extends TAsyncMethodCall {
      private String plugin;
      private String func;
      public hasService_call(String plugin, String func, AsyncMethodCallback<hasService_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.plugin = plugin;
        this.func = func;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("hasService", TMessageType.CALL, 0));
        hasService_args args = new hasService_args();
        args.setPlugin(plugin);
        args.setFunc(func);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public boolean getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_hasService();
      }
    }

    public void call(ServiceCall info, AsyncMethodCallback<call_call> resultHandler) throws TException {
      checkReady();
      call_call method_call = new call_call(info, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class call_call extends TAsyncMethodCall {
      private ServiceCall info;
      public call_call(ServiceCall info, AsyncMethodCallback<call_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.info = info;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("call", TMessageType.CALL, 0));
        call_args args = new call_args();
        args.setInfo(info);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws ServiceDoesNotExists, ServiceException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_call();
      }
    }

    public void getAllInfo(AsyncMethodCallback<getAllInfo_call> resultHandler) throws TException {
      checkReady();
      getAllInfo_call method_call = new getAllInfo_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getAllInfo_call extends TAsyncMethodCall {
      public getAllInfo_call(AsyncMethodCallback<getAllInfo_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getAllInfo", TMessageType.CALL, 0));
        getAllInfo_args args = new getAllInfo_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,Map<String,String>> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getAllInfo();
      }
    }

    public void getInfoByPlugin(String plugin, AsyncMethodCallback<getInfoByPlugin_call> resultHandler) throws TException {
      checkReady();
      getInfoByPlugin_call method_call = new getInfoByPlugin_call(plugin, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getInfoByPlugin_call extends TAsyncMethodCall {
      private String plugin;
      public getInfoByPlugin_call(String plugin, AsyncMethodCallback<getInfoByPlugin_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.plugin = plugin;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getInfoByPlugin", TMessageType.CALL, 0));
        getInfoByPlugin_args args = new getInfoByPlugin_args();
        args.setPlugin(plugin);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Map<String,String> getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getInfoByPlugin();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("getConfigValue", new getConfigValue());
      processMap_.put("setConfigValue", new setConfigValue());
      processMap_.put("getConfig", new getConfig());
      processMap_.put("getPluginConfig", new getPluginConfig());
      processMap_.put("pauseServer", new pauseServer());
      processMap_.put("unpauseServer", new unpauseServer());
      processMap_.put("togglePause", new togglePause());
      processMap_.put("statusServer", new statusServer());
      processMap_.put("freeSpace", new freeSpace());
      processMap_.put("getServerVersion", new getServerVersion());
      processMap_.put("kill", new kill());
      processMap_.put("restart", new restart());
      processMap_.put("getLog", new getLog());
      processMap_.put("isTimeDownload", new isTimeDownload());
      processMap_.put("isTimeReconnect", new isTimeReconnect());
      processMap_.put("toggleReconnect", new toggleReconnect());
      processMap_.put("generatePackages", new generatePackages());
      processMap_.put("checkURLs", new checkURLs());
      processMap_.put("parseURLs", new parseURLs());
      processMap_.put("checkOnlineStatus", new checkOnlineStatus());
      processMap_.put("checkOnlineStatusContainer", new checkOnlineStatusContainer());
      processMap_.put("pollResults", new pollResults());
      processMap_.put("statusDownloads", new statusDownloads());
      processMap_.put("getPackageData", new getPackageData());
      processMap_.put("getPackageInfo", new getPackageInfo());
      processMap_.put("getFileData", new getFileData());
      processMap_.put("getQueue", new getQueue());
      processMap_.put("getCollector", new getCollector());
      processMap_.put("getQueueData", new getQueueData());
      processMap_.put("getCollectorData", new getCollectorData());
      processMap_.put("getPackageOrder", new getPackageOrder());
      processMap_.put("getFileOrder", new getFileOrder());
      processMap_.put("generateAndAddPackages", new generateAndAddPackages());
      processMap_.put("addPackage", new addPackage());
      processMap_.put("addFiles", new addFiles());
      processMap_.put("uploadContainer", new uploadContainer());
      processMap_.put("deleteFiles", new deleteFiles());
      processMap_.put("deletePackages", new deletePackages());
      processMap_.put("pushToQueue", new pushToQueue());
      processMap_.put("pullFromQueue", new pullFromQueue());
      processMap_.put("restartPackage", new restartPackage());
      processMap_.put("restartFile", new restartFile());
      processMap_.put("recheckPackage", new recheckPackage());
      processMap_.put("stopAllDownloads", new stopAllDownloads());
      processMap_.put("stopDownloads", new stopDownloads());
      processMap_.put("setPackageName", new setPackageName());
      processMap_.put("movePackage", new movePackage());
      processMap_.put("moveFiles", new moveFiles());
      processMap_.put("orderPackage", new orderPackage());
      processMap_.put("orderFile", new orderFile());
      processMap_.put("setPackageData", new setPackageData());
      processMap_.put("deleteFinished", new deleteFinished());
      processMap_.put("restartFailed", new restartFailed());
      processMap_.put("isCaptchaWaiting", new isCaptchaWaiting());
      processMap_.put("getCaptchaTask", new getCaptchaTask());
      processMap_.put("getCaptchaTaskStatus", new getCaptchaTaskStatus());
      processMap_.put("setCaptchaResult", new setCaptchaResult());
      processMap_.put("getEvents", new getEvents());
      processMap_.put("getAccounts", new getAccounts());
      processMap_.put("getAccountTypes", new getAccountTypes());
      processMap_.put("updateAccount", new updateAccount());
      processMap_.put("removeAccount", new removeAccount());
      processMap_.put("login", new login());
      processMap_.put("getUserData", new getUserData());
      processMap_.put("getServices", new getServices());
      processMap_.put("hasService", new hasService());
      processMap_.put("call", new call());
      processMap_.put("getAllInfo", new getAllInfo());
      processMap_.put("getInfoByPlugin", new getInfoByPlugin());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class getConfigValue implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getConfigValue_args args = new getConfigValue_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getConfigValue", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getConfigValue_result result = new getConfigValue_result();
        result.success = iface_.getConfigValue(args.category, args.option, args.section);
        oprot.writeMessageBegin(new TMessage("getConfigValue", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setConfigValue implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setConfigValue_args args = new setConfigValue_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setConfigValue", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setConfigValue_result result = new setConfigValue_result();
        iface_.setConfigValue(args.category, args.option, args.value, args.section);
        oprot.writeMessageBegin(new TMessage("setConfigValue", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getConfig_args args = new getConfig_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getConfig_result result = new getConfig_result();
        result.success = iface_.getConfig();
        oprot.writeMessageBegin(new TMessage("getConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getPluginConfig implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getPluginConfig_args args = new getPluginConfig_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getPluginConfig", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getPluginConfig_result result = new getPluginConfig_result();
        result.success = iface_.getPluginConfig();
        oprot.writeMessageBegin(new TMessage("getPluginConfig", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pauseServer implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pauseServer_args args = new pauseServer_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("pauseServer", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        pauseServer_result result = new pauseServer_result();
        iface_.pauseServer();
        oprot.writeMessageBegin(new TMessage("pauseServer", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class unpauseServer implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        unpauseServer_args args = new unpauseServer_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("unpauseServer", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        unpauseServer_result result = new unpauseServer_result();
        iface_.unpauseServer();
        oprot.writeMessageBegin(new TMessage("unpauseServer", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class togglePause implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        togglePause_args args = new togglePause_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("togglePause", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        togglePause_result result = new togglePause_result();
        result.success = iface_.togglePause();
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("togglePause", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class statusServer implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        statusServer_args args = new statusServer_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("statusServer", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        statusServer_result result = new statusServer_result();
        result.success = iface_.statusServer();
        oprot.writeMessageBegin(new TMessage("statusServer", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class freeSpace implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        freeSpace_args args = new freeSpace_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("freeSpace", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        freeSpace_result result = new freeSpace_result();
        result.success = iface_.freeSpace();
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("freeSpace", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getServerVersion implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getServerVersion_args args = new getServerVersion_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getServerVersion", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getServerVersion_result result = new getServerVersion_result();
        result.success = iface_.getServerVersion();
        oprot.writeMessageBegin(new TMessage("getServerVersion", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class kill implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        kill_args args = new kill_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("kill", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        kill_result result = new kill_result();
        iface_.kill();
        oprot.writeMessageBegin(new TMessage("kill", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class restart implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        restart_args args = new restart_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("restart", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        restart_result result = new restart_result();
        iface_.restart();
        oprot.writeMessageBegin(new TMessage("restart", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getLog implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getLog_args args = new getLog_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getLog", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getLog_result result = new getLog_result();
        result.success = iface_.getLog(args.offset);
        oprot.writeMessageBegin(new TMessage("getLog", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class isTimeDownload implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        isTimeDownload_args args = new isTimeDownload_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("isTimeDownload", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        isTimeDownload_result result = new isTimeDownload_result();
        result.success = iface_.isTimeDownload();
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("isTimeDownload", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class isTimeReconnect implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        isTimeReconnect_args args = new isTimeReconnect_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("isTimeReconnect", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        isTimeReconnect_result result = new isTimeReconnect_result();
        result.success = iface_.isTimeReconnect();
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("isTimeReconnect", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class toggleReconnect implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        toggleReconnect_args args = new toggleReconnect_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("toggleReconnect", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        toggleReconnect_result result = new toggleReconnect_result();
        result.success = iface_.toggleReconnect();
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("toggleReconnect", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class generatePackages implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        generatePackages_args args = new generatePackages_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("generatePackages", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        generatePackages_result result = new generatePackages_result();
        result.success = iface_.generatePackages(args.links);
        oprot.writeMessageBegin(new TMessage("generatePackages", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class checkURLs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkURLs_args args = new checkURLs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("checkURLs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        checkURLs_result result = new checkURLs_result();
        result.success = iface_.checkURLs(args.urls);
        oprot.writeMessageBegin(new TMessage("checkURLs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class parseURLs implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        parseURLs_args args = new parseURLs_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("parseURLs", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        parseURLs_result result = new parseURLs_result();
        result.success = iface_.parseURLs(args.html);
        oprot.writeMessageBegin(new TMessage("parseURLs", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class checkOnlineStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkOnlineStatus_args args = new checkOnlineStatus_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("checkOnlineStatus", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        checkOnlineStatus_result result = new checkOnlineStatus_result();
        result.success = iface_.checkOnlineStatus(args.urls);
        oprot.writeMessageBegin(new TMessage("checkOnlineStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class checkOnlineStatusContainer implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkOnlineStatusContainer_args args = new checkOnlineStatusContainer_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("checkOnlineStatusContainer", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        checkOnlineStatusContainer_result result = new checkOnlineStatusContainer_result();
        result.success = iface_.checkOnlineStatusContainer(args.urls, args.filename, args.data);
        oprot.writeMessageBegin(new TMessage("checkOnlineStatusContainer", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pollResults implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pollResults_args args = new pollResults_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("pollResults", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        pollResults_result result = new pollResults_result();
        result.success = iface_.pollResults(args.rid);
        oprot.writeMessageBegin(new TMessage("pollResults", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class statusDownloads implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        statusDownloads_args args = new statusDownloads_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("statusDownloads", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        statusDownloads_result result = new statusDownloads_result();
        result.success = iface_.statusDownloads();
        oprot.writeMessageBegin(new TMessage("statusDownloads", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getPackageData implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getPackageData_args args = new getPackageData_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getPackageData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getPackageData_result result = new getPackageData_result();
        try {
          result.success = iface_.getPackageData(args.pid);
        } catch (PackageDoesNotExists e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getPackageData", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getPackageData");
          oprot.writeMessageBegin(new TMessage("getPackageData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getPackageData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getPackageInfo implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getPackageInfo_args args = new getPackageInfo_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getPackageInfo", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getPackageInfo_result result = new getPackageInfo_result();
        try {
          result.success = iface_.getPackageInfo(args.pid);
        } catch (PackageDoesNotExists e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getPackageInfo", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getPackageInfo");
          oprot.writeMessageBegin(new TMessage("getPackageInfo", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getPackageInfo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getFileData implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getFileData_args args = new getFileData_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getFileData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getFileData_result result = new getFileData_result();
        try {
          result.success = iface_.getFileData(args.fid);
        } catch (FileDoesNotExists e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getFileData", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getFileData");
          oprot.writeMessageBegin(new TMessage("getFileData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getFileData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getQueue implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getQueue_args args = new getQueue_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getQueue", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getQueue_result result = new getQueue_result();
        result.success = iface_.getQueue();
        oprot.writeMessageBegin(new TMessage("getQueue", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getCollector implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getCollector_args args = new getCollector_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getCollector", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getCollector_result result = new getCollector_result();
        result.success = iface_.getCollector();
        oprot.writeMessageBegin(new TMessage("getCollector", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getQueueData implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getQueueData_args args = new getQueueData_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getQueueData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getQueueData_result result = new getQueueData_result();
        result.success = iface_.getQueueData();
        oprot.writeMessageBegin(new TMessage("getQueueData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getCollectorData implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getCollectorData_args args = new getCollectorData_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getCollectorData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getCollectorData_result result = new getCollectorData_result();
        result.success = iface_.getCollectorData();
        oprot.writeMessageBegin(new TMessage("getCollectorData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getPackageOrder implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getPackageOrder_args args = new getPackageOrder_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getPackageOrder", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getPackageOrder_result result = new getPackageOrder_result();
        result.success = iface_.getPackageOrder(args.destination);
        oprot.writeMessageBegin(new TMessage("getPackageOrder", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getFileOrder implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getFileOrder_args args = new getFileOrder_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getFileOrder", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getFileOrder_result result = new getFileOrder_result();
        result.success = iface_.getFileOrder(args.pid);
        oprot.writeMessageBegin(new TMessage("getFileOrder", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class generateAndAddPackages implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        generateAndAddPackages_args args = new generateAndAddPackages_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("generateAndAddPackages", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        generateAndAddPackages_result result = new generateAndAddPackages_result();
        result.success = iface_.generateAndAddPackages(args.links, args.dest);
        oprot.writeMessageBegin(new TMessage("generateAndAddPackages", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class addPackage implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        addPackage_args args = new addPackage_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("addPackage", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        addPackage_result result = new addPackage_result();
        result.success = iface_.addPackage(args.name, args.links, args.dest);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("addPackage", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class addFiles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        addFiles_args args = new addFiles_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("addFiles", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        addFiles_result result = new addFiles_result();
        iface_.addFiles(args.pid, args.links);
        oprot.writeMessageBegin(new TMessage("addFiles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class uploadContainer implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        uploadContainer_args args = new uploadContainer_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("uploadContainer", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        uploadContainer_result result = new uploadContainer_result();
        iface_.uploadContainer(args.filename, args.data);
        oprot.writeMessageBegin(new TMessage("uploadContainer", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteFiles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteFiles_args args = new deleteFiles_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteFiles", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteFiles_result result = new deleteFiles_result();
        iface_.deleteFiles(args.fids);
        oprot.writeMessageBegin(new TMessage("deleteFiles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deletePackages implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deletePackages_args args = new deletePackages_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deletePackages", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deletePackages_result result = new deletePackages_result();
        iface_.deletePackages(args.pids);
        oprot.writeMessageBegin(new TMessage("deletePackages", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pushToQueue implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pushToQueue_args args = new pushToQueue_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("pushToQueue", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        pushToQueue_result result = new pushToQueue_result();
        iface_.pushToQueue(args.pid);
        oprot.writeMessageBegin(new TMessage("pushToQueue", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pullFromQueue implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pullFromQueue_args args = new pullFromQueue_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("pullFromQueue", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        pullFromQueue_result result = new pullFromQueue_result();
        iface_.pullFromQueue(args.pid);
        oprot.writeMessageBegin(new TMessage("pullFromQueue", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class restartPackage implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        restartPackage_args args = new restartPackage_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("restartPackage", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        restartPackage_result result = new restartPackage_result();
        iface_.restartPackage(args.pid);
        oprot.writeMessageBegin(new TMessage("restartPackage", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class restartFile implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        restartFile_args args = new restartFile_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("restartFile", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        restartFile_result result = new restartFile_result();
        iface_.restartFile(args.fid);
        oprot.writeMessageBegin(new TMessage("restartFile", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class recheckPackage implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        recheckPackage_args args = new recheckPackage_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("recheckPackage", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        recheckPackage_result result = new recheckPackage_result();
        iface_.recheckPackage(args.pid);
        oprot.writeMessageBegin(new TMessage("recheckPackage", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class stopAllDownloads implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        stopAllDownloads_args args = new stopAllDownloads_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("stopAllDownloads", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        stopAllDownloads_result result = new stopAllDownloads_result();
        iface_.stopAllDownloads();
        oprot.writeMessageBegin(new TMessage("stopAllDownloads", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class stopDownloads implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        stopDownloads_args args = new stopDownloads_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("stopDownloads", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        stopDownloads_result result = new stopDownloads_result();
        iface_.stopDownloads(args.fids);
        oprot.writeMessageBegin(new TMessage("stopDownloads", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setPackageName implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setPackageName_args args = new setPackageName_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setPackageName", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setPackageName_result result = new setPackageName_result();
        iface_.setPackageName(args.pid, args.name);
        oprot.writeMessageBegin(new TMessage("setPackageName", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class movePackage implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        movePackage_args args = new movePackage_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("movePackage", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        movePackage_result result = new movePackage_result();
        iface_.movePackage(args.destination, args.pid);
        oprot.writeMessageBegin(new TMessage("movePackage", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class moveFiles implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        moveFiles_args args = new moveFiles_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("moveFiles", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        moveFiles_result result = new moveFiles_result();
        iface_.moveFiles(args.fids, args.pid);
        oprot.writeMessageBegin(new TMessage("moveFiles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class orderPackage implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        orderPackage_args args = new orderPackage_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("orderPackage", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        orderPackage_result result = new orderPackage_result();
        iface_.orderPackage(args.pid, args.position);
        oprot.writeMessageBegin(new TMessage("orderPackage", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class orderFile implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        orderFile_args args = new orderFile_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("orderFile", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        orderFile_result result = new orderFile_result();
        iface_.orderFile(args.fid, args.position);
        oprot.writeMessageBegin(new TMessage("orderFile", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setPackageData implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setPackageData_args args = new setPackageData_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setPackageData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setPackageData_result result = new setPackageData_result();
        try {
          iface_.setPackageData(args.pid, args.data);
        } catch (PackageDoesNotExists e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing setPackageData", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing setPackageData");
          oprot.writeMessageBegin(new TMessage("setPackageData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("setPackageData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteFinished implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteFinished_args args = new deleteFinished_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteFinished", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteFinished_result result = new deleteFinished_result();
        iface_.deleteFinished();
        oprot.writeMessageBegin(new TMessage("deleteFinished", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class restartFailed implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        restartFailed_args args = new restartFailed_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("restartFailed", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        restartFailed_result result = new restartFailed_result();
        iface_.restartFailed();
        oprot.writeMessageBegin(new TMessage("restartFailed", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class isCaptchaWaiting implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        isCaptchaWaiting_args args = new isCaptchaWaiting_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("isCaptchaWaiting", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        isCaptchaWaiting_result result = new isCaptchaWaiting_result();
        result.success = iface_.isCaptchaWaiting();
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("isCaptchaWaiting", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getCaptchaTask implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getCaptchaTask_args args = new getCaptchaTask_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getCaptchaTask", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getCaptchaTask_result result = new getCaptchaTask_result();
        result.success = iface_.getCaptchaTask(args.exclusive);
        oprot.writeMessageBegin(new TMessage("getCaptchaTask", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getCaptchaTaskStatus implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getCaptchaTaskStatus_args args = new getCaptchaTaskStatus_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getCaptchaTaskStatus", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getCaptchaTaskStatus_result result = new getCaptchaTaskStatus_result();
        result.success = iface_.getCaptchaTaskStatus(args.tid);
        oprot.writeMessageBegin(new TMessage("getCaptchaTaskStatus", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setCaptchaResult implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setCaptchaResult_args args = new setCaptchaResult_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setCaptchaResult", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setCaptchaResult_result result = new setCaptchaResult_result();
        iface_.setCaptchaResult(args.tid, args.result);
        oprot.writeMessageBegin(new TMessage("setCaptchaResult", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getEvents implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getEvents_args args = new getEvents_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getEvents", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getEvents_result result = new getEvents_result();
        result.success = iface_.getEvents(args.uuid);
        oprot.writeMessageBegin(new TMessage("getEvents", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getAccounts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getAccounts_args args = new getAccounts_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getAccounts", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getAccounts_result result = new getAccounts_result();
        result.success = iface_.getAccounts(args.refresh);
        oprot.writeMessageBegin(new TMessage("getAccounts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getAccountTypes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getAccountTypes_args args = new getAccountTypes_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getAccountTypes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getAccountTypes_result result = new getAccountTypes_result();
        result.success = iface_.getAccountTypes();
        oprot.writeMessageBegin(new TMessage("getAccountTypes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class updateAccount implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        updateAccount_args args = new updateAccount_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("updateAccount", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        updateAccount_result result = new updateAccount_result();
        iface_.updateAccount(args.plugin, args.account, args.password, args.options);
        oprot.writeMessageBegin(new TMessage("updateAccount", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class removeAccount implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        removeAccount_args args = new removeAccount_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("removeAccount", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        removeAccount_result result = new removeAccount_result();
        iface_.removeAccount(args.plugin, args.account);
        oprot.writeMessageBegin(new TMessage("removeAccount", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class login implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        login_args args = new login_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("login", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        login_result result = new login_result();
        result.success = iface_.login(args.username, args.password);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("login", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getUserData implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getUserData_args args = new getUserData_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getUserData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getUserData_result result = new getUserData_result();
        result.success = iface_.getUserData(args.username, args.password);
        oprot.writeMessageBegin(new TMessage("getUserData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getServices implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getServices_args args = new getServices_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getServices", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getServices_result result = new getServices_result();
        result.success = iface_.getServices();
        oprot.writeMessageBegin(new TMessage("getServices", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class hasService implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        hasService_args args = new hasService_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("hasService", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        hasService_result result = new hasService_result();
        result.success = iface_.hasService(args.plugin, args.func);
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("hasService", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class call implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        call_args args = new call_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("call", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        call_result result = new call_result();
        try {
          result.success = iface_.call(args.info);
        } catch (ServiceDoesNotExists ex) {
          result.ex = ex;
        } catch (ServiceException e) {
          result.e = e;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing call", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing call");
          oprot.writeMessageBegin(new TMessage("call", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("call", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getAllInfo implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getAllInfo_args args = new getAllInfo_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getAllInfo", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getAllInfo_result result = new getAllInfo_result();
        result.success = iface_.getAllInfo();
        oprot.writeMessageBegin(new TMessage("getAllInfo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getInfoByPlugin implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getInfoByPlugin_args args = new getInfoByPlugin_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getInfoByPlugin", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getInfoByPlugin_result result = new getInfoByPlugin_result();
        result.success = iface_.getInfoByPlugin(args.plugin);
        oprot.writeMessageBegin(new TMessage("getInfoByPlugin", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class getConfigValue_args implements TBase<getConfigValue_args, getConfigValue_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfigValue_args");

    private static final TField CATEGORY_FIELD_DESC = new TField("category", TType.STRING, (short)1);
    private static final TField OPTION_FIELD_DESC = new TField("option", TType.STRING, (short)2);
    private static final TField SECTION_FIELD_DESC = new TField("section", TType.STRING, (short)3);

    public String category;
    public String option;
    public String section;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      CATEGORY((short)1, "category"),
      OPTION((short)2, "option"),
      SECTION((short)3, "section");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CATEGORY
            return CATEGORY;
          case 2: // OPTION
            return OPTION;
          case 3: // SECTION
            return SECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CATEGORY, new FieldMetaData("category", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPTION, new FieldMetaData("option", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SECTION, new FieldMetaData("section", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getConfigValue_args.class, metaDataMap);
    }

    public getConfigValue_args() {
    }

    public getConfigValue_args(
      String category,
      String option,
      String section)
    {
      this();
      this.category = category;
      this.option = option;
      this.section = section;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfigValue_args(getConfigValue_args other) {
      if (other.isSetCategory()) {
        this.category = other.category;
      }
      if (other.isSetOption()) {
        this.option = other.option;
      }
      if (other.isSetSection()) {
        this.section = other.section;
      }
    }

    public getConfigValue_args deepCopy() {
      return new getConfigValue_args(this);
    }

    
    public void clear() {
      this.category = null;
      this.option = null;
      this.section = null;
    }

    public String getCategory() {
      return this.category;
    }

    public getConfigValue_args setCategory(String category) {
      this.category = category;
      return this;
    }

    public void unsetCategory() {
      this.category = null;
    }

    /** Returns true if field category is set (has been asigned a value) and false otherwise */
    public boolean isSetCategory() {
      return this.category != null;
    }

    public void setCategoryIsSet(boolean value) {
      if (!value) {
        this.category = null;
      }
    }

    public String getOption() {
      return this.option;
    }

    public getConfigValue_args setOption(String option) {
      this.option = option;
      return this;
    }

    public void unsetOption() {
      this.option = null;
    }

    /** Returns true if field option is set (has been asigned a value) and false otherwise */
    public boolean isSetOption() {
      return this.option != null;
    }

    public void setOptionIsSet(boolean value) {
      if (!value) {
        this.option = null;
      }
    }

    public String getSection() {
      return this.section;
    }

    public getConfigValue_args setSection(String section) {
      this.section = section;
      return this;
    }

    public void unsetSection() {
      this.section = null;
    }

    /** Returns true if field section is set (has been asigned a value) and false otherwise */
    public boolean isSetSection() {
      return this.section != null;
    }

    public void setSectionIsSet(boolean value) {
      if (!value) {
        this.section = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CATEGORY:
        if (value == null) {
          unsetCategory();
        } else {
          setCategory((String)value);
        }
        break;

      case OPTION:
        if (value == null) {
          unsetOption();
        } else {
          setOption((String)value);
        }
        break;

      case SECTION:
        if (value == null) {
          unsetSection();
        } else {
          setSection((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CATEGORY:
        return getCategory();

      case OPTION:
        return getOption();

      case SECTION:
        return getSection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CATEGORY:
        return isSetCategory();
      case OPTION:
        return isSetOption();
      case SECTION:
        return isSetSection();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfigValue_args)
        return this.equals((getConfigValue_args)that);
      return false;
    }

    public boolean equals(getConfigValue_args that) {
      if (that == null)
        return false;

      boolean this_present_category = true && this.isSetCategory();
      boolean that_present_category = true && that.isSetCategory();
      if (this_present_category || that_present_category) {
        if (!(this_present_category && that_present_category))
          return false;
        if (!this.category.equals(that.category))
          return false;
      }

      boolean this_present_option = true && this.isSetOption();
      boolean that_present_option = true && that.isSetOption();
      if (this_present_option || that_present_option) {
        if (!(this_present_option && that_present_option))
          return false;
        if (!this.option.equals(that.option))
          return false;
      }

      boolean this_present_section = true && this.isSetSection();
      boolean that_present_section = true && that.isSetSection();
      if (this_present_section || that_present_section) {
        if (!(this_present_section && that_present_section))
          return false;
        if (!this.section.equals(that.section))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfigValue_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfigValue_args typedOther = (getConfigValue_args)other;

      lastComparison = Boolean.valueOf(isSetCategory()).compareTo(typedOther.isSetCategory());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCategory()) {
        lastComparison = TBaseHelper.compareTo(this.category, typedOther.category);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOption()).compareTo(typedOther.isSetOption());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOption()) {
        lastComparison = TBaseHelper.compareTo(this.option, typedOther.option);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSection()).compareTo(typedOther.isSetSection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSection()) {
        lastComparison = TBaseHelper.compareTo(this.section, typedOther.section);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // CATEGORY
            if (field.type == TType.STRING) {
              this.category = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPTION
            if (field.type == TType.STRING) {
              this.option = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // SECTION
            if (field.type == TType.STRING) {
              this.section = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.category != null) {
        oprot.writeFieldBegin(CATEGORY_FIELD_DESC);
        oprot.writeString(this.category);
        oprot.writeFieldEnd();
      }
      if (this.option != null) {
        oprot.writeFieldBegin(OPTION_FIELD_DESC);
        oprot.writeString(this.option);
        oprot.writeFieldEnd();
      }
      if (this.section != null) {
        oprot.writeFieldBegin(SECTION_FIELD_DESC);
        oprot.writeString(this.section);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfigValue_args(");
      boolean first = true;

      sb.append("category:");
      if (this.category == null) {
        sb.append("null");
      } else {
        sb.append(this.category);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("option:");
      if (this.option == null) {
        sb.append("null");
      } else {
        sb.append(this.option);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("section:");
      if (this.section == null) {
        sb.append("null");
      } else {
        sb.append(this.section);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfigValue_result implements TBase<getConfigValue_result, getConfigValue_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfigValue_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getConfigValue_result.class, metaDataMap);
    }

    public getConfigValue_result() {
    }

    public getConfigValue_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfigValue_result(getConfigValue_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public getConfigValue_result deepCopy() {
      return new getConfigValue_result(this);
    }

    public void clear() {
      this.success = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public getConfigValue_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfigValue_result)
        return this.equals((getConfigValue_result)that);
      return false;
    }

    public boolean equals(getConfigValue_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfigValue_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfigValue_result typedOther = (getConfigValue_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfigValue_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setConfigValue_args implements TBase<setConfigValue_args, setConfigValue_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfigValue_args");

    private static final TField CATEGORY_FIELD_DESC = new TField("category", TType.STRING, (short)1);
    private static final TField OPTION_FIELD_DESC = new TField("option", TType.STRING, (short)2);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);
    private static final TField SECTION_FIELD_DESC = new TField("section", TType.STRING, (short)4);

    public String category;
    public String option;
    public String value;
    public String section;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      CATEGORY((short)1, "category"),
      OPTION((short)2, "option"),
      VALUE((short)3, "value"),
      SECTION((short)4, "section");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // CATEGORY
            return CATEGORY;
          case 2: // OPTION
            return OPTION;
          case 3: // VALUE
            return VALUE;
          case 4: // SECTION
            return SECTION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.CATEGORY, new FieldMetaData("category", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPTION, new FieldMetaData("option", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SECTION, new FieldMetaData("section", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setConfigValue_args.class, metaDataMap);
    }

    public setConfigValue_args() {
    }

    public setConfigValue_args(
      String category,
      String option,
      String value,
      String section)
    {
      this();
      this.category = category;
      this.option = option;
      this.value = value;
      this.section = section;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfigValue_args(setConfigValue_args other) {
      if (other.isSetCategory()) {
        this.category = other.category;
      }
      if (other.isSetOption()) {
        this.option = other.option;
      }
      if (other.isSetValue()) {
        this.value = other.value;
      }
      if (other.isSetSection()) {
        this.section = other.section;
      }
    }

    public setConfigValue_args deepCopy() {
      return new setConfigValue_args(this);
    }

    
    public void clear() {
      this.category = null;
      this.option = null;
      this.value = null;
      this.section = null;
    }

    public String getCategory() {
      return this.category;
    }

    public setConfigValue_args setCategory(String category) {
      this.category = category;
      return this;
    }

    public void unsetCategory() {
      this.category = null;
    }

    /** Returns true if field category is set (has been asigned a value) and false otherwise */
    public boolean isSetCategory() {
      return this.category != null;
    }

    public void setCategoryIsSet(boolean value) {
      if (!value) {
        this.category = null;
      }
    }

    public String getOption() {
      return this.option;
    }

    public setConfigValue_args setOption(String option) {
      this.option = option;
      return this;
    }

    public void unsetOption() {
      this.option = null;
    }

    /** Returns true if field option is set (has been asigned a value) and false otherwise */
    public boolean isSetOption() {
      return this.option != null;
    }

    public void setOptionIsSet(boolean value) {
      if (!value) {
        this.option = null;
      }
    }

    public String getValue() {
      return this.value;
    }

    public setConfigValue_args setValue(String value) {
      this.value = value;
      return this;
    }

    public void unsetValue() {
      this.value = null;
    }

    /** Returns true if field value is set (has been asigned a value) and false otherwise */
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public String getSection() {
      return this.section;
    }

    public setConfigValue_args setSection(String section) {
      this.section = section;
      return this;
    }

    public void unsetSection() {
      this.section = null;
    }

    /** Returns true if field section is set (has been asigned a value) and false otherwise */
    public boolean isSetSection() {
      return this.section != null;
    }

    public void setSectionIsSet(boolean value) {
      if (!value) {
        this.section = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case CATEGORY:
        if (value == null) {
          unsetCategory();
        } else {
          setCategory((String)value);
        }
        break;

      case OPTION:
        if (value == null) {
          unsetOption();
        } else {
          setOption((String)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((String)value);
        }
        break;

      case SECTION:
        if (value == null) {
          unsetSection();
        } else {
          setSection((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case CATEGORY:
        return getCategory();

      case OPTION:
        return getOption();

      case VALUE:
        return getValue();

      case SECTION:
        return getSection();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case CATEGORY:
        return isSetCategory();
      case OPTION:
        return isSetOption();
      case VALUE:
        return isSetValue();
      case SECTION:
        return isSetSection();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setConfigValue_args)
        return this.equals((setConfigValue_args)that);
      return false;
    }

    public boolean equals(setConfigValue_args that) {
      if (that == null)
        return false;

      boolean this_present_category = true && this.isSetCategory();
      boolean that_present_category = true && that.isSetCategory();
      if (this_present_category || that_present_category) {
        if (!(this_present_category && that_present_category))
          return false;
        if (!this.category.equals(that.category))
          return false;
      }

      boolean this_present_option = true && this.isSetOption();
      boolean that_present_option = true && that.isSetOption();
      if (this_present_option || that_present_option) {
        if (!(this_present_option && that_present_option))
          return false;
        if (!this.option.equals(that.option))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!this.value.equals(that.value))
          return false;
      }

      boolean this_present_section = true && this.isSetSection();
      boolean that_present_section = true && that.isSetSection();
      if (this_present_section || that_present_section) {
        if (!(this_present_section && that_present_section))
          return false;
        if (!this.section.equals(that.section))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setConfigValue_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setConfigValue_args typedOther = (setConfigValue_args)other;

      lastComparison = Boolean.valueOf(isSetCategory()).compareTo(typedOther.isSetCategory());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetCategory()) {
        lastComparison = TBaseHelper.compareTo(this.category, typedOther.category);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOption()).compareTo(typedOther.isSetOption());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOption()) {
        lastComparison = TBaseHelper.compareTo(this.option, typedOther.option);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetValue()).compareTo(typedOther.isSetValue());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetValue()) {
        lastComparison = TBaseHelper.compareTo(this.value, typedOther.value);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSection()).compareTo(typedOther.isSetSection());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSection()) {
        lastComparison = TBaseHelper.compareTo(this.section, typedOther.section);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // CATEGORY
            if (field.type == TType.STRING) {
              this.category = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // OPTION
            if (field.type == TType.STRING) {
              this.option = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // VALUE
            if (field.type == TType.STRING) {
              this.value = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // SECTION
            if (field.type == TType.STRING) {
              this.section = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.category != null) {
        oprot.writeFieldBegin(CATEGORY_FIELD_DESC);
        oprot.writeString(this.category);
        oprot.writeFieldEnd();
      }
      if (this.option != null) {
        oprot.writeFieldBegin(OPTION_FIELD_DESC);
        oprot.writeString(this.option);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeString(this.value);
        oprot.writeFieldEnd();
      }
      if (this.section != null) {
        oprot.writeFieldBegin(SECTION_FIELD_DESC);
        oprot.writeString(this.section);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setConfigValue_args(");
      boolean first = true;

      sb.append("category:");
      if (this.category == null) {
        sb.append("null");
      } else {
        sb.append(this.category);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("option:");
      if (this.option == null) {
        sb.append("null");
      } else {
        sb.append(this.option);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
        sb.append(this.value);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("section:");
      if (this.section == null) {
        sb.append("null");
      } else {
        sb.append(this.section);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setConfigValue_result implements TBase<setConfigValue_result, setConfigValue_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setConfigValue_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setConfigValue_result.class, metaDataMap);
    }

    public setConfigValue_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setConfigValue_result(setConfigValue_result other) {
    }

    public setConfigValue_result deepCopy() {
      return new setConfigValue_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setConfigValue_result)
        return this.equals((setConfigValue_result)that);
      return false;
    }

    public boolean equals(setConfigValue_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setConfigValue_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setConfigValue_result typedOther = (setConfigValue_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setConfigValue_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_args implements TBase<getConfig_args, getConfig_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getConfig_args.class, metaDataMap);
    }

    public getConfig_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_args(getConfig_args other) {
    }

    public getConfig_args deepCopy() {
      return new getConfig_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_args)
        return this.equals((getConfig_args)that);
      return false;
    }

    public boolean equals(getConfig_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfig_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfig_args typedOther = (getConfig_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfig_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getConfig_result implements TBase<getConfig_result, getConfig_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConfig_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,ConfigSection> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new StructMetaData(TType.STRUCT, ConfigSection.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getConfig_result.class, metaDataMap);
    }

    public getConfig_result() {
    }

    public getConfig_result(
      Map<String,ConfigSection> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConfig_result(getConfig_result other) {
      if (other.isSetSuccess()) {
        Map<String,ConfigSection> __this__success = new HashMap<String,ConfigSection>();
        for (Map.Entry<String, ConfigSection> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          ConfigSection other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          ConfigSection __this__success_copy_value = new ConfigSection(other_element_value);

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public getConfig_result deepCopy() {
      return new getConfig_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, ConfigSection val) {
      if (this.success == null) {
        this.success = new HashMap<String,ConfigSection>();
      }
      this.success.put(key, val);
    }

    public Map<String,ConfigSection> getSuccess() {
      return this.success;
    }

    public getConfig_result setSuccess(Map<String,ConfigSection> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,ConfigSection>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConfig_result)
        return this.equals((getConfig_result)that);
      return false;
    }

    public boolean equals(getConfig_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConfig_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConfig_result typedOther = (getConfig_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map31 = iprot.readMapBegin();
                this.success = new HashMap<String,ConfigSection>(2*_map31.size);
                for (int _i32 = 0; _i32 < _map31.size; ++_i32)
                {
                  String _key33;
                  ConfigSection _val34;
                  _key33 = iprot.readString();
                  _val34 = new ConfigSection();
                  _val34.read(iprot);
                  this.success.put(_key33, _val34);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
          for (Map.Entry<String, ConfigSection> _iter35 : this.success.entrySet())
          {
            oprot.writeString(_iter35.getKey());
            _iter35.getValue().write(oprot);
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getConfig_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPluginConfig_args implements TBase<getPluginConfig_args, getPluginConfig_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPluginConfig_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPluginConfig_args.class, metaDataMap);
    }

    public getPluginConfig_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPluginConfig_args(getPluginConfig_args other) {
    }

    public getPluginConfig_args deepCopy() {
      return new getPluginConfig_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPluginConfig_args)
        return this.equals((getPluginConfig_args)that);
      return false;
    }

    public boolean equals(getPluginConfig_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPluginConfig_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPluginConfig_args typedOther = (getPluginConfig_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPluginConfig_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPluginConfig_result implements TBase<getPluginConfig_result, getPluginConfig_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPluginConfig_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,ConfigSection> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new StructMetaData(TType.STRUCT, ConfigSection.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPluginConfig_result.class, metaDataMap);
    }

    public getPluginConfig_result() {
    }

    public getPluginConfig_result(
      Map<String,ConfigSection> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPluginConfig_result(getPluginConfig_result other) {
      if (other.isSetSuccess()) {
        Map<String,ConfigSection> __this__success = new HashMap<String,ConfigSection>();
        for (Map.Entry<String, ConfigSection> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          ConfigSection other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          ConfigSection __this__success_copy_value = new ConfigSection(other_element_value);

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public getPluginConfig_result deepCopy() {
      return new getPluginConfig_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, ConfigSection val) {
      if (this.success == null) {
        this.success = new HashMap<String,ConfigSection>();
      }
      this.success.put(key, val);
    }

    public Map<String,ConfigSection> getSuccess() {
      return this.success;
    }

    public getPluginConfig_result setSuccess(Map<String,ConfigSection> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,ConfigSection>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPluginConfig_result)
        return this.equals((getPluginConfig_result)that);
      return false;
    }

    public boolean equals(getPluginConfig_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPluginConfig_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPluginConfig_result typedOther = (getPluginConfig_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map36 = iprot.readMapBegin();
                this.success = new HashMap<String,ConfigSection>(2*_map36.size);
                for (int _i37 = 0; _i37 < _map36.size; ++_i37)
                {
                  String _key38;
                  ConfigSection _val39;
                  _key38 = iprot.readString();
                  _val39 = new ConfigSection();
                  _val39.read(iprot);
                  this.success.put(_key38, _val39);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.size()));
          for (Map.Entry<String, ConfigSection> _iter40 : this.success.entrySet())
          {
            oprot.writeString(_iter40.getKey());
            _iter40.getValue().write(oprot);
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPluginConfig_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pauseServer_args implements TBase<pauseServer_args, pauseServer_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pauseServer_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pauseServer_args.class, metaDataMap);
    }

    public pauseServer_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pauseServer_args(pauseServer_args other) {
    }

    public pauseServer_args deepCopy() {
      return new pauseServer_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pauseServer_args)
        return this.equals((pauseServer_args)that);
      return false;
    }

    public boolean equals(pauseServer_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pauseServer_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pauseServer_args typedOther = (pauseServer_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pauseServer_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pauseServer_result implements TBase<pauseServer_result, pauseServer_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pauseServer_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pauseServer_result.class, metaDataMap);
    }

    public pauseServer_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pauseServer_result(pauseServer_result other) {
    }

    public pauseServer_result deepCopy() {
      return new pauseServer_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pauseServer_result)
        return this.equals((pauseServer_result)that);
      return false;
    }

    public boolean equals(pauseServer_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pauseServer_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pauseServer_result typedOther = (pauseServer_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pauseServer_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class unpauseServer_args implements TBase<unpauseServer_args, unpauseServer_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("unpauseServer_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(unpauseServer_args.class, metaDataMap);
    }

    public unpauseServer_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public unpauseServer_args(unpauseServer_args other) {
    }

    public unpauseServer_args deepCopy() {
      return new unpauseServer_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof unpauseServer_args)
        return this.equals((unpauseServer_args)that);
      return false;
    }

    public boolean equals(unpauseServer_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(unpauseServer_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      unpauseServer_args typedOther = (unpauseServer_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("unpauseServer_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class unpauseServer_result implements TBase<unpauseServer_result, unpauseServer_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("unpauseServer_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(unpauseServer_result.class, metaDataMap);
    }

    public unpauseServer_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public unpauseServer_result(unpauseServer_result other) {
    }

    public unpauseServer_result deepCopy() {
      return new unpauseServer_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof unpauseServer_result)
        return this.equals((unpauseServer_result)that);
      return false;
    }

    public boolean equals(unpauseServer_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(unpauseServer_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      unpauseServer_result typedOther = (unpauseServer_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("unpauseServer_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class togglePause_args implements TBase<togglePause_args, togglePause_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("togglePause_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(togglePause_args.class, metaDataMap);
    }

    public togglePause_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public togglePause_args(togglePause_args other) {
    }

    public togglePause_args deepCopy() {
      return new togglePause_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof togglePause_args)
        return this.equals((togglePause_args)that);
      return false;
    }

    public boolean equals(togglePause_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(togglePause_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      togglePause_args typedOther = (togglePause_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("togglePause_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class togglePause_result implements TBase<togglePause_result, togglePause_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("togglePause_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(togglePause_result.class, metaDataMap);
    }

    public togglePause_result() {
    }

    public togglePause_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public togglePause_result(togglePause_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public togglePause_result deepCopy() {
      return new togglePause_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public togglePause_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof togglePause_result)
        return this.equals((togglePause_result)that);
      return false;
    }

    public boolean equals(togglePause_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(togglePause_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      togglePause_result typedOther = (togglePause_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("togglePause_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class statusServer_args implements TBase<statusServer_args, statusServer_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("statusServer_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(statusServer_args.class, metaDataMap);
    }

    public statusServer_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statusServer_args(statusServer_args other) {
    }

    public statusServer_args deepCopy() {
      return new statusServer_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statusServer_args)
        return this.equals((statusServer_args)that);
      return false;
    }

    public boolean equals(statusServer_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(statusServer_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      statusServer_args typedOther = (statusServer_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("statusServer_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class statusServer_result implements TBase<statusServer_result, statusServer_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("statusServer_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public ServerStatus success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ServerStatus.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(statusServer_result.class, metaDataMap);
    }

    public statusServer_result() {
    }

    public statusServer_result(
      ServerStatus success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statusServer_result(statusServer_result other) {
      if (other.isSetSuccess()) {
        this.success = new ServerStatus(other.success);
      }
    }

    public statusServer_result deepCopy() {
      return new statusServer_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public ServerStatus getSuccess() {
      return this.success;
    }

    public statusServer_result setSuccess(ServerStatus success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ServerStatus)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statusServer_result)
        return this.equals((statusServer_result)that);
      return false;
    }

    public boolean equals(statusServer_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(statusServer_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      statusServer_result typedOther = (statusServer_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new ServerStatus();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("statusServer_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class freeSpace_args implements TBase<freeSpace_args, freeSpace_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("freeSpace_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(freeSpace_args.class, metaDataMap);
    }

    public freeSpace_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public freeSpace_args(freeSpace_args other) {
    }

    public freeSpace_args deepCopy() {
      return new freeSpace_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof freeSpace_args)
        return this.equals((freeSpace_args)that);
      return false;
    }

    public boolean equals(freeSpace_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(freeSpace_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      freeSpace_args typedOther = (freeSpace_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("freeSpace_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class freeSpace_result implements TBase<freeSpace_result, freeSpace_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("freeSpace_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);

    public long success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(freeSpace_result.class, metaDataMap);
    }

    public freeSpace_result() {
    }

    public freeSpace_result(
      long success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public freeSpace_result(freeSpace_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public freeSpace_result deepCopy() {
      return new freeSpace_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
    }

    public long getSuccess() {
      return this.success;
    }

    public freeSpace_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof freeSpace_result)
        return this.equals((freeSpace_result)that);
      return false;
    }

    public boolean equals(freeSpace_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(freeSpace_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      freeSpace_result typedOther = (freeSpace_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("freeSpace_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getServerVersion_args implements TBase<getServerVersion_args, getServerVersion_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getServerVersion_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getServerVersion_args.class, metaDataMap);
    }

    public getServerVersion_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getServerVersion_args(getServerVersion_args other) {
    }

    public getServerVersion_args deepCopy() {
      return new getServerVersion_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getServerVersion_args)
        return this.equals((getServerVersion_args)that);
      return false;
    }

    public boolean equals(getServerVersion_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getServerVersion_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getServerVersion_args typedOther = (getServerVersion_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getServerVersion_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getServerVersion_result implements TBase<getServerVersion_result, getServerVersion_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getServerVersion_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getServerVersion_result.class, metaDataMap);
    }

    public getServerVersion_result() {
    }

    public getServerVersion_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getServerVersion_result(getServerVersion_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public getServerVersion_result deepCopy() {
      return new getServerVersion_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public getServerVersion_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getServerVersion_result)
        return this.equals((getServerVersion_result)that);
      return false;
    }

    public boolean equals(getServerVersion_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getServerVersion_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getServerVersion_result typedOther = (getServerVersion_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getServerVersion_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class kill_args implements TBase<kill_args, kill_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("kill_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(kill_args.class, metaDataMap);
    }

    public kill_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public kill_args(kill_args other) {
    }

    public kill_args deepCopy() {
      return new kill_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof kill_args)
        return this.equals((kill_args)that);
      return false;
    }

    public boolean equals(kill_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(kill_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      kill_args typedOther = (kill_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("kill_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class kill_result implements TBase<kill_result, kill_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("kill_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(kill_result.class, metaDataMap);
    }

    public kill_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public kill_result(kill_result other) {
    }

    public kill_result deepCopy() {
      return new kill_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof kill_result)
        return this.equals((kill_result)that);
      return false;
    }

    public boolean equals(kill_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(kill_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      kill_result typedOther = (kill_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("kill_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restart_args implements TBase<restart_args, restart_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restart_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restart_args.class, metaDataMap);
    }

    public restart_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restart_args(restart_args other) {
    }

    public restart_args deepCopy() {
      return new restart_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restart_args)
        return this.equals((restart_args)that);
      return false;
    }

    public boolean equals(restart_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restart_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restart_args typedOther = (restart_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restart_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restart_result implements TBase<restart_result, restart_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restart_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restart_result.class, metaDataMap);
    }

    public restart_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restart_result(restart_result other) {
    }

    public restart_result deepCopy() {
      return new restart_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restart_result)
        return this.equals((restart_result)that);
      return false;
    }

    public boolean equals(restart_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restart_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restart_result typedOther = (restart_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restart_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getLog_args implements TBase<getLog_args, getLog_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getLog_args");

    private static final TField OFFSET_FIELD_DESC = new TField("offset", TType.I32, (short)1);

    public int offset;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      OFFSET((short)1, "offset");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // OFFSET
            return OFFSET;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __OFFSET_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.OFFSET, new FieldMetaData("offset", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getLog_args.class, metaDataMap);
    }

    public getLog_args() {
    }

    public getLog_args(
      int offset)
    {
      this();
      this.offset = offset;
      setOffsetIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getLog_args(getLog_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.offset = other.offset;
    }

    public getLog_args deepCopy() {
      return new getLog_args(this);
    }

    
    public void clear() {
      setOffsetIsSet(false);
      this.offset = 0;
    }

    public int getOffset() {
      return this.offset;
    }

    public getLog_args setOffset(int offset) {
      this.offset = offset;
      setOffsetIsSet(true);
      return this;
    }

    public void unsetOffset() {
      __isset_bit_vector.clear(__OFFSET_ISSET_ID);
    }

    /** Returns true if field offset is set (has been asigned a value) and false otherwise */
    public boolean isSetOffset() {
      return __isset_bit_vector.get(__OFFSET_ISSET_ID);
    }

    public void setOffsetIsSet(boolean value) {
      __isset_bit_vector.set(__OFFSET_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case OFFSET:
        if (value == null) {
          unsetOffset();
        } else {
          setOffset((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case OFFSET:
        return new Integer(getOffset());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case OFFSET:
        return isSetOffset();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getLog_args)
        return this.equals((getLog_args)that);
      return false;
    }

    public boolean equals(getLog_args that) {
      if (that == null)
        return false;

      boolean this_present_offset = true;
      boolean that_present_offset = true;
      if (this_present_offset || that_present_offset) {
        if (!(this_present_offset && that_present_offset))
          return false;
        if (this.offset != that.offset)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getLog_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getLog_args typedOther = (getLog_args)other;

      lastComparison = Boolean.valueOf(isSetOffset()).compareTo(typedOther.isSetOffset());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOffset()) {
        lastComparison = TBaseHelper.compareTo(this.offset, typedOther.offset);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // OFFSET
            if (field.type == TType.I32) {
              this.offset = iprot.readI32();
              setOffsetIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(OFFSET_FIELD_DESC);
      oprot.writeI32(this.offset);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getLog_args(");
      boolean first = true;

      sb.append("offset:");
      sb.append(this.offset);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getLog_result implements TBase<getLog_result, getLog_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getLog_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getLog_result.class, metaDataMap);
    }

    public getLog_result() {
    }

    public getLog_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getLog_result(getLog_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public getLog_result deepCopy() {
      return new getLog_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public getLog_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getLog_result)
        return this.equals((getLog_result)that);
      return false;
    }

    public boolean equals(getLog_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getLog_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getLog_result typedOther = (getLog_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list41 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list41.size);
                for (int _i42 = 0; _i42 < _list41.size; ++_i42)
                {
                  String _elem43;
                  _elem43 = iprot.readString();
                  this.success.add(_elem43);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter44 : this.success)
          {
            oprot.writeString(_iter44);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getLog_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isTimeDownload_args implements TBase<isTimeDownload_args, isTimeDownload_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isTimeDownload_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isTimeDownload_args.class, metaDataMap);
    }

    public isTimeDownload_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isTimeDownload_args(isTimeDownload_args other) {
    }

    public isTimeDownload_args deepCopy() {
      return new isTimeDownload_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isTimeDownload_args)
        return this.equals((isTimeDownload_args)that);
      return false;
    }

    public boolean equals(isTimeDownload_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(isTimeDownload_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isTimeDownload_args typedOther = (isTimeDownload_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("isTimeDownload_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isTimeDownload_result implements TBase<isTimeDownload_result, isTimeDownload_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isTimeDownload_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isTimeDownload_result.class, metaDataMap);
    }

    public isTimeDownload_result() {
    }

    public isTimeDownload_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isTimeDownload_result(isTimeDownload_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public isTimeDownload_result deepCopy() {
      return new isTimeDownload_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public isTimeDownload_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isTimeDownload_result)
        return this.equals((isTimeDownload_result)that);
      return false;
    }

    public boolean equals(isTimeDownload_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(isTimeDownload_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isTimeDownload_result typedOther = (isTimeDownload_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("isTimeDownload_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isTimeReconnect_args implements TBase<isTimeReconnect_args, isTimeReconnect_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isTimeReconnect_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isTimeReconnect_args.class, metaDataMap);
    }

    public isTimeReconnect_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isTimeReconnect_args(isTimeReconnect_args other) {
    }

    public isTimeReconnect_args deepCopy() {
      return new isTimeReconnect_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isTimeReconnect_args)
        return this.equals((isTimeReconnect_args)that);
      return false;
    }

    public boolean equals(isTimeReconnect_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(isTimeReconnect_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isTimeReconnect_args typedOther = (isTimeReconnect_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("isTimeReconnect_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isTimeReconnect_result implements TBase<isTimeReconnect_result, isTimeReconnect_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isTimeReconnect_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isTimeReconnect_result.class, metaDataMap);
    }

    public isTimeReconnect_result() {
    }

    public isTimeReconnect_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isTimeReconnect_result(isTimeReconnect_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public isTimeReconnect_result deepCopy() {
      return new isTimeReconnect_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public isTimeReconnect_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isTimeReconnect_result)
        return this.equals((isTimeReconnect_result)that);
      return false;
    }

    public boolean equals(isTimeReconnect_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(isTimeReconnect_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isTimeReconnect_result typedOther = (isTimeReconnect_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("isTimeReconnect_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class toggleReconnect_args implements TBase<toggleReconnect_args, toggleReconnect_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("toggleReconnect_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(toggleReconnect_args.class, metaDataMap);
    }

    public toggleReconnect_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public toggleReconnect_args(toggleReconnect_args other) {
    }

    public toggleReconnect_args deepCopy() {
      return new toggleReconnect_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof toggleReconnect_args)
        return this.equals((toggleReconnect_args)that);
      return false;
    }

    public boolean equals(toggleReconnect_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(toggleReconnect_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      toggleReconnect_args typedOther = (toggleReconnect_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("toggleReconnect_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class toggleReconnect_result implements TBase<toggleReconnect_result, toggleReconnect_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("toggleReconnect_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(toggleReconnect_result.class, metaDataMap);
    }

    public toggleReconnect_result() {
    }

    public toggleReconnect_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public toggleReconnect_result(toggleReconnect_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public toggleReconnect_result deepCopy() {
      return new toggleReconnect_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public toggleReconnect_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof toggleReconnect_result)
        return this.equals((toggleReconnect_result)that);
      return false;
    }

    public boolean equals(toggleReconnect_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(toggleReconnect_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      toggleReconnect_result typedOther = (toggleReconnect_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("toggleReconnect_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class generatePackages_args implements TBase<generatePackages_args, generatePackages_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("generatePackages_args");

    private static final TField LINKS_FIELD_DESC = new TField("links", TType.LIST, (short)1);

    public List<String> links;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      LINKS((short)1, "links");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // LINKS
            return LINKS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.LINKS, new FieldMetaData("links", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "LinkList")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(generatePackages_args.class, metaDataMap);
    }

    public generatePackages_args() {
    }

    public generatePackages_args(
      List<String> links)
    {
      this();
      this.links = links;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public generatePackages_args(generatePackages_args other) {
      if (other.isSetLinks()) {
        this.links = other.links;
      }
    }

    public generatePackages_args deepCopy() {
      return new generatePackages_args(this);
    }

    
    public void clear() {
      this.links = null;
    }

    public int getLinksSize() {
      return (this.links == null) ? 0 : this.links.size();
    }

    public java.util.Iterator<String> getLinksIterator() {
      return (this.links == null) ? null : this.links.iterator();
    }

    public void addToLinks(String elem) {
      if (this.links == null) {
        this.links = new ArrayList<String>();
      }
      this.links.add(elem);
    }

    public List<String> getLinks() {
      return this.links;
    }

    public generatePackages_args setLinks(List<String> links) {
      this.links = links;
      return this;
    }

    public void unsetLinks() {
      this.links = null;
    }

    /** Returns true if field links is set (has been asigned a value) and false otherwise */
    public boolean isSetLinks() {
      return this.links != null;
    }

    public void setLinksIsSet(boolean value) {
      if (!value) {
        this.links = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case LINKS:
        if (value == null) {
          unsetLinks();
        } else {
          setLinks((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case LINKS:
        return getLinks();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case LINKS:
        return isSetLinks();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof generatePackages_args)
        return this.equals((generatePackages_args)that);
      return false;
    }

    public boolean equals(generatePackages_args that) {
      if (that == null)
        return false;

      boolean this_present_links = true && this.isSetLinks();
      boolean that_present_links = true && that.isSetLinks();
      if (this_present_links || that_present_links) {
        if (!(this_present_links && that_present_links))
          return false;
        if (!this.links.equals(that.links))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(generatePackages_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      generatePackages_args typedOther = (generatePackages_args)other;

      lastComparison = Boolean.valueOf(isSetLinks()).compareTo(typedOther.isSetLinks());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLinks()) {
        lastComparison = TBaseHelper.compareTo(this.links, typedOther.links);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // LINKS
            if (field.type == TType.LIST) {
              {
                TList _list45 = iprot.readListBegin();
                this.links = new ArrayList<String>(_list45.size);
                for (int _i46 = 0; _i46 < _list45.size; ++_i46)
                {
                  String _elem47;
                  _elem47 = iprot.readString();
                  this.links.add(_elem47);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.links != null) {
        oprot.writeFieldBegin(LINKS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.links.size()));
          for (String _iter48 : this.links)
          {
            oprot.writeString(_iter48);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("generatePackages_args(");
      boolean first = true;

      sb.append("links:");
      if (this.links == null) {
        sb.append("null");
      } else {
        sb.append(this.links);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class generatePackages_result implements TBase<generatePackages_result, generatePackages_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("generatePackages_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,List<String>> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.LIST              , "LinkList"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(generatePackages_result.class, metaDataMap);
    }

    public generatePackages_result() {
    }

    public generatePackages_result(
      Map<String,List<String>> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public generatePackages_result(generatePackages_result other) {
      if (other.isSetSuccess()) {
        Map<String,List<String>> __this__success = new HashMap<String,List<String>>();
        for (Map.Entry<String, List<String>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          List<String> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          List<String> __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public generatePackages_result deepCopy() {
      return new generatePackages_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, List<String> val) {
      if (this.success == null) {
        this.success = new HashMap<String,List<String>>();
      }
      this.success.put(key, val);
    }

    public Map<String,List<String>> getSuccess() {
      return this.success;
    }

    public generatePackages_result setSuccess(Map<String,List<String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,List<String>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof generatePackages_result)
        return this.equals((generatePackages_result)that);
      return false;
    }

    public boolean equals(generatePackages_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(generatePackages_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      generatePackages_result typedOther = (generatePackages_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map49 = iprot.readMapBegin();
                this.success = new HashMap<String,List<String>>(2*_map49.size);
                for (int _i50 = 0; _i50 < _map49.size; ++_i50)
                {
                  String _key51;
                  List<String> _val52;
                  _key51 = iprot.readString();
                  {
                    TList _list53 = iprot.readListBegin();
                    _val52 = new ArrayList<String>(_list53.size);
                    for (int _i54 = 0; _i54 < _list53.size; ++_i54)
                    {
                      String _elem55;
                      _elem55 = iprot.readString();
                      _val52.add(_elem55);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key51, _val52);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
          for (Map.Entry<String, List<String>> _iter56 : this.success.entrySet())
          {
            oprot.writeString(_iter56.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter56.getValue().size()));
              for (String _iter57 : _iter56.getValue())
              {
                oprot.writeString(_iter57);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("generatePackages_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkURLs_args implements TBase<checkURLs_args, checkURLs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkURLs_args");

    private static final TField URLS_FIELD_DESC = new TField("urls", TType.LIST, (short)1);

    public List<String> urls;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      URLS((short)1, "urls");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // URLS
            return URLS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.URLS, new FieldMetaData("urls", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "LinkList")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkURLs_args.class, metaDataMap);
    }

    public checkURLs_args() {
    }

    public checkURLs_args(
      List<String> urls)
    {
      this();
      this.urls = urls;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkURLs_args(checkURLs_args other) {
      if (other.isSetUrls()) {
        this.urls = other.urls;
      }
    }

    public checkURLs_args deepCopy() {
      return new checkURLs_args(this);
    }

    
    public void clear() {
      this.urls = null;
    }

    public int getUrlsSize() {
      return (this.urls == null) ? 0 : this.urls.size();
    }

    public java.util.Iterator<String> getUrlsIterator() {
      return (this.urls == null) ? null : this.urls.iterator();
    }

    public void addToUrls(String elem) {
      if (this.urls == null) {
        this.urls = new ArrayList<String>();
      }
      this.urls.add(elem);
    }

    public List<String> getUrls() {
      return this.urls;
    }

    public checkURLs_args setUrls(List<String> urls) {
      this.urls = urls;
      return this;
    }

    public void unsetUrls() {
      this.urls = null;
    }

    /** Returns true if field urls is set (has been asigned a value) and false otherwise */
    public boolean isSetUrls() {
      return this.urls != null;
    }

    public void setUrlsIsSet(boolean value) {
      if (!value) {
        this.urls = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case URLS:
        if (value == null) {
          unsetUrls();
        } else {
          setUrls((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case URLS:
        return getUrls();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case URLS:
        return isSetUrls();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkURLs_args)
        return this.equals((checkURLs_args)that);
      return false;
    }

    public boolean equals(checkURLs_args that) {
      if (that == null)
        return false;

      boolean this_present_urls = true && this.isSetUrls();
      boolean that_present_urls = true && that.isSetUrls();
      if (this_present_urls || that_present_urls) {
        if (!(this_present_urls && that_present_urls))
          return false;
        if (!this.urls.equals(that.urls))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkURLs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkURLs_args typedOther = (checkURLs_args)other;

      lastComparison = Boolean.valueOf(isSetUrls()).compareTo(typedOther.isSetUrls());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUrls()) {
        lastComparison = TBaseHelper.compareTo(this.urls, typedOther.urls);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // URLS
            if (field.type == TType.LIST) {
              {
                TList _list58 = iprot.readListBegin();
                this.urls = new ArrayList<String>(_list58.size);
                for (int _i59 = 0; _i59 < _list58.size; ++_i59)
                {
                  String _elem60;
                  _elem60 = iprot.readString();
                  this.urls.add(_elem60);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.urls != null) {
        oprot.writeFieldBegin(URLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.urls.size()));
          for (String _iter61 : this.urls)
          {
            oprot.writeString(_iter61);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("checkURLs_args(");
      boolean first = true;

      sb.append("urls:");
      if (this.urls == null) {
        sb.append("null");
      } else {
        sb.append(this.urls);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkURLs_result implements TBase<checkURLs_result, checkURLs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkURLs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,List<String>> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING              , "PluginName"), 
              new FieldValueMetaData(TType.LIST              , "LinkList"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkURLs_result.class, metaDataMap);
    }

    public checkURLs_result() {
    }

    public checkURLs_result(
      Map<String,List<String>> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkURLs_result(checkURLs_result other) {
      if (other.isSetSuccess()) {
        Map<String,List<String>> __this__success = new HashMap<String,List<String>>();
        for (Map.Entry<String, List<String>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          List<String> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          List<String> __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public checkURLs_result deepCopy() {
      return new checkURLs_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, List<String> val) {
      if (this.success == null) {
        this.success = new HashMap<String,List<String>>();
      }
      this.success.put(key, val);
    }

    public Map<String,List<String>> getSuccess() {
      return this.success;
    }

    public checkURLs_result setSuccess(Map<String,List<String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,List<String>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkURLs_result)
        return this.equals((checkURLs_result)that);
      return false;
    }

    public boolean equals(checkURLs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkURLs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkURLs_result typedOther = (checkURLs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map62 = iprot.readMapBegin();
                this.success = new HashMap<String,List<String>>(2*_map62.size);
                for (int _i63 = 0; _i63 < _map62.size; ++_i63)
                {
                  String _key64;
                  List<String> _val65;
                  _key64 = iprot.readString();
                  {
                    TList _list66 = iprot.readListBegin();
                    _val65 = new ArrayList<String>(_list66.size);
                    for (int _i67 = 0; _i67 < _list66.size; ++_i67)
                    {
                      String _elem68;
                      _elem68 = iprot.readString();
                      _val65.add(_elem68);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key64, _val65);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
          for (Map.Entry<String, List<String>> _iter69 : this.success.entrySet())
          {
            oprot.writeString(_iter69.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter69.getValue().size()));
              for (String _iter70 : _iter69.getValue())
              {
                oprot.writeString(_iter70);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("checkURLs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class parseURLs_args implements TBase<parseURLs_args, parseURLs_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("parseURLs_args");

    private static final TField HTML_FIELD_DESC = new TField("html", TType.STRING, (short)1);

    public String html;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      HTML((short)1, "html");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // HTML
            return HTML;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.HTML, new FieldMetaData("html", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(parseURLs_args.class, metaDataMap);
    }

    public parseURLs_args() {
    }

    public parseURLs_args(
      String html)
    {
      this();
      this.html = html;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public parseURLs_args(parseURLs_args other) {
      if (other.isSetHtml()) {
        this.html = other.html;
      }
    }

    public parseURLs_args deepCopy() {
      return new parseURLs_args(this);
    }

    
    public void clear() {
      this.html = null;
    }

    public String getHtml() {
      return this.html;
    }

    public parseURLs_args setHtml(String html) {
      this.html = html;
      return this;
    }

    public void unsetHtml() {
      this.html = null;
    }

    /** Returns true if field html is set (has been asigned a value) and false otherwise */
    public boolean isSetHtml() {
      return this.html != null;
    }

    public void setHtmlIsSet(boolean value) {
      if (!value) {
        this.html = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case HTML:
        if (value == null) {
          unsetHtml();
        } else {
          setHtml((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case HTML:
        return getHtml();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case HTML:
        return isSetHtml();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof parseURLs_args)
        return this.equals((parseURLs_args)that);
      return false;
    }

    public boolean equals(parseURLs_args that) {
      if (that == null)
        return false;

      boolean this_present_html = true && this.isSetHtml();
      boolean that_present_html = true && that.isSetHtml();
      if (this_present_html || that_present_html) {
        if (!(this_present_html && that_present_html))
          return false;
        if (!this.html.equals(that.html))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(parseURLs_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      parseURLs_args typedOther = (parseURLs_args)other;

      lastComparison = Boolean.valueOf(isSetHtml()).compareTo(typedOther.isSetHtml());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetHtml()) {
        lastComparison = TBaseHelper.compareTo(this.html, typedOther.html);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // HTML
            if (field.type == TType.STRING) {
              this.html = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.html != null) {
        oprot.writeFieldBegin(HTML_FIELD_DESC);
        oprot.writeString(this.html);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("parseURLs_args(");
      boolean first = true;

      sb.append("html:");
      if (this.html == null) {
        sb.append("null");
      } else {
        sb.append(this.html);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class parseURLs_result implements TBase<parseURLs_result, parseURLs_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("parseURLs_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,List<String>> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING              , "PluginName"), 
              new FieldValueMetaData(TType.LIST              , "LinkList"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(parseURLs_result.class, metaDataMap);
    }

    public parseURLs_result() {
    }

    public parseURLs_result(
      Map<String,List<String>> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public parseURLs_result(parseURLs_result other) {
      if (other.isSetSuccess()) {
        Map<String,List<String>> __this__success = new HashMap<String,List<String>>();
        for (Map.Entry<String, List<String>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          List<String> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          List<String> __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public parseURLs_result deepCopy() {
      return new parseURLs_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, List<String> val) {
      if (this.success == null) {
        this.success = new HashMap<String,List<String>>();
      }
      this.success.put(key, val);
    }

    public Map<String,List<String>> getSuccess() {
      return this.success;
    }

    public parseURLs_result setSuccess(Map<String,List<String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,List<String>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof parseURLs_result)
        return this.equals((parseURLs_result)that);
      return false;
    }

    public boolean equals(parseURLs_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(parseURLs_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      parseURLs_result typedOther = (parseURLs_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map71 = iprot.readMapBegin();
                this.success = new HashMap<String,List<String>>(2*_map71.size);
                for (int _i72 = 0; _i72 < _map71.size; ++_i72)
                {
                  String _key73;
                  List<String> _val74;
                  _key73 = iprot.readString();
                  {
                    TList _list75 = iprot.readListBegin();
                    _val74 = new ArrayList<String>(_list75.size);
                    for (int _i76 = 0; _i76 < _list75.size; ++_i76)
                    {
                      String _elem77;
                      _elem77 = iprot.readString();
                      _val74.add(_elem77);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key73, _val74);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
          for (Map.Entry<String, List<String>> _iter78 : this.success.entrySet())
          {
            oprot.writeString(_iter78.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter78.getValue().size()));
              for (String _iter79 : _iter78.getValue())
              {
                oprot.writeString(_iter79);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("parseURLs_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkOnlineStatus_args implements TBase<checkOnlineStatus_args, checkOnlineStatus_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkOnlineStatus_args");

    private static final TField URLS_FIELD_DESC = new TField("urls", TType.LIST, (short)1);

    public List<String> urls;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      URLS((short)1, "urls");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // URLS
            return URLS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.URLS, new FieldMetaData("urls", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "LinkList")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkOnlineStatus_args.class, metaDataMap);
    }

    public checkOnlineStatus_args() {
    }

    public checkOnlineStatus_args(
      List<String> urls)
    {
      this();
      this.urls = urls;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkOnlineStatus_args(checkOnlineStatus_args other) {
      if (other.isSetUrls()) {
        this.urls = other.urls;
      }
    }

    public checkOnlineStatus_args deepCopy() {
      return new checkOnlineStatus_args(this);
    }

    
    public void clear() {
      this.urls = null;
    }

    public int getUrlsSize() {
      return (this.urls == null) ? 0 : this.urls.size();
    }

    public java.util.Iterator<String> getUrlsIterator() {
      return (this.urls == null) ? null : this.urls.iterator();
    }

    public void addToUrls(String elem) {
      if (this.urls == null) {
        this.urls = new ArrayList<String>();
      }
      this.urls.add(elem);
    }

    public List<String> getUrls() {
      return this.urls;
    }

    public checkOnlineStatus_args setUrls(List<String> urls) {
      this.urls = urls;
      return this;
    }

    public void unsetUrls() {
      this.urls = null;
    }

    /** Returns true if field urls is set (has been asigned a value) and false otherwise */
    public boolean isSetUrls() {
      return this.urls != null;
    }

    public void setUrlsIsSet(boolean value) {
      if (!value) {
        this.urls = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case URLS:
        if (value == null) {
          unsetUrls();
        } else {
          setUrls((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case URLS:
        return getUrls();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case URLS:
        return isSetUrls();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkOnlineStatus_args)
        return this.equals((checkOnlineStatus_args)that);
      return false;
    }

    public boolean equals(checkOnlineStatus_args that) {
      if (that == null)
        return false;

      boolean this_present_urls = true && this.isSetUrls();
      boolean that_present_urls = true && that.isSetUrls();
      if (this_present_urls || that_present_urls) {
        if (!(this_present_urls && that_present_urls))
          return false;
        if (!this.urls.equals(that.urls))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkOnlineStatus_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkOnlineStatus_args typedOther = (checkOnlineStatus_args)other;

      lastComparison = Boolean.valueOf(isSetUrls()).compareTo(typedOther.isSetUrls());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUrls()) {
        lastComparison = TBaseHelper.compareTo(this.urls, typedOther.urls);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // URLS
            if (field.type == TType.LIST) {
              {
                TList _list80 = iprot.readListBegin();
                this.urls = new ArrayList<String>(_list80.size);
                for (int _i81 = 0; _i81 < _list80.size; ++_i81)
                {
                  String _elem82;
                  _elem82 = iprot.readString();
                  this.urls.add(_elem82);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.urls != null) {
        oprot.writeFieldBegin(URLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.urls.size()));
          for (String _iter83 : this.urls)
          {
            oprot.writeString(_iter83);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("checkOnlineStatus_args(");
      boolean first = true;

      sb.append("urls:");
      if (this.urls == null) {
        sb.append("null");
      } else {
        sb.append(this.urls);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkOnlineStatus_result implements TBase<checkOnlineStatus_result, checkOnlineStatus_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkOnlineStatus_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public OnlineCheck success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, OnlineCheck.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkOnlineStatus_result.class, metaDataMap);
    }

    public checkOnlineStatus_result() {
    }

    public checkOnlineStatus_result(
      OnlineCheck success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkOnlineStatus_result(checkOnlineStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = new OnlineCheck(other.success);
      }
    }

    public checkOnlineStatus_result deepCopy() {
      return new checkOnlineStatus_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public OnlineCheck getSuccess() {
      return this.success;
    }

    public checkOnlineStatus_result setSuccess(OnlineCheck success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((OnlineCheck)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkOnlineStatus_result)
        return this.equals((checkOnlineStatus_result)that);
      return false;
    }

    public boolean equals(checkOnlineStatus_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkOnlineStatus_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkOnlineStatus_result typedOther = (checkOnlineStatus_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new OnlineCheck();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("checkOnlineStatus_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkOnlineStatusContainer_args implements TBase<checkOnlineStatusContainer_args, checkOnlineStatusContainer_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkOnlineStatusContainer_args");

    private static final TField URLS_FIELD_DESC = new TField("urls", TType.LIST, (short)1);
    private static final TField FILENAME_FIELD_DESC = new TField("filename", TType.STRING, (short)2);
    private static final TField DATA_FIELD_DESC = new TField("data", TType.STRING, (short)3);

    public List<String> urls;
    public String filename;
    public ByteBuffer data;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      URLS((short)1, "urls"),
      FILENAME((short)2, "filename"),
      DATA((short)3, "data");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // URLS
            return URLS;
          case 2: // FILENAME
            return FILENAME;
          case 3: // DATA
            return DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.URLS, new FieldMetaData("urls", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "LinkList")));
      tmpMap.put(_Fields.FILENAME, new FieldMetaData("filename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DATA, new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkOnlineStatusContainer_args.class, metaDataMap);
    }

    public checkOnlineStatusContainer_args() {
    }

    public checkOnlineStatusContainer_args(
      List<String> urls,
      String filename,
      ByteBuffer data)
    {
      this();
      this.urls = urls;
      this.filename = filename;
      this.data = data;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkOnlineStatusContainer_args(checkOnlineStatusContainer_args other) {
      if (other.isSetUrls()) {
        this.urls = other.urls;
      }
      if (other.isSetFilename()) {
        this.filename = other.filename;
      }
      if (other.isSetData()) {
        this.data = TBaseHelper.copyBinary(other.data);
;
      }
    }

    public checkOnlineStatusContainer_args deepCopy() {
      return new checkOnlineStatusContainer_args(this);
    }

    
    public void clear() {
      this.urls = null;
      this.filename = null;
      this.data = null;
    }

    public int getUrlsSize() {
      return (this.urls == null) ? 0 : this.urls.size();
    }

    public java.util.Iterator<String> getUrlsIterator() {
      return (this.urls == null) ? null : this.urls.iterator();
    }

    public void addToUrls(String elem) {
      if (this.urls == null) {
        this.urls = new ArrayList<String>();
      }
      this.urls.add(elem);
    }

    public List<String> getUrls() {
      return this.urls;
    }

    public checkOnlineStatusContainer_args setUrls(List<String> urls) {
      this.urls = urls;
      return this;
    }

    public void unsetUrls() {
      this.urls = null;
    }

    /** Returns true if field urls is set (has been asigned a value) and false otherwise */
    public boolean isSetUrls() {
      return this.urls != null;
    }

    public void setUrlsIsSet(boolean value) {
      if (!value) {
        this.urls = null;
      }
    }

    public String getFilename() {
      return this.filename;
    }

    public checkOnlineStatusContainer_args setFilename(String filename) {
      this.filename = filename;
      return this;
    }

    public void unsetFilename() {
      this.filename = null;
    }

    /** Returns true if field filename is set (has been asigned a value) and false otherwise */
    public boolean isSetFilename() {
      return this.filename != null;
    }

    public void setFilenameIsSet(boolean value) {
      if (!value) {
        this.filename = null;
      }
    }

    public byte[] getData() {
      setData(TBaseHelper.rightSize(data));
      return data.array();
    }

    public ByteBuffer BufferForData() {
      return data;
    }

    public checkOnlineStatusContainer_args setData(byte[] data) {
      setData(ByteBuffer.wrap(data));
      return this;
    }

    public checkOnlineStatusContainer_args setData(ByteBuffer data) {
      this.data = data;
      return this;
    }

    public void unsetData() {
      this.data = null;
    }

    /** Returns true if field data is set (has been asigned a value) and false otherwise */
    public boolean isSetData() {
      return this.data != null;
    }

    public void setDataIsSet(boolean value) {
      if (!value) {
        this.data = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case URLS:
        if (value == null) {
          unsetUrls();
        } else {
          setUrls((List<String>)value);
        }
        break;

      case FILENAME:
        if (value == null) {
          unsetFilename();
        } else {
          setFilename((String)value);
        }
        break;

      case DATA:
        if (value == null) {
          unsetData();
        } else {
          setData((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case URLS:
        return getUrls();

      case FILENAME:
        return getFilename();

      case DATA:
        return getData();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case URLS:
        return isSetUrls();
      case FILENAME:
        return isSetFilename();
      case DATA:
        return isSetData();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkOnlineStatusContainer_args)
        return this.equals((checkOnlineStatusContainer_args)that);
      return false;
    }

    public boolean equals(checkOnlineStatusContainer_args that) {
      if (that == null)
        return false;

      boolean this_present_urls = true && this.isSetUrls();
      boolean that_present_urls = true && that.isSetUrls();
      if (this_present_urls || that_present_urls) {
        if (!(this_present_urls && that_present_urls))
          return false;
        if (!this.urls.equals(that.urls))
          return false;
      }

      boolean this_present_filename = true && this.isSetFilename();
      boolean that_present_filename = true && that.isSetFilename();
      if (this_present_filename || that_present_filename) {
        if (!(this_present_filename && that_present_filename))
          return false;
        if (!this.filename.equals(that.filename))
          return false;
      }

      boolean this_present_data = true && this.isSetData();
      boolean that_present_data = true && that.isSetData();
      if (this_present_data || that_present_data) {
        if (!(this_present_data && that_present_data))
          return false;
        if (!this.data.equals(that.data))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkOnlineStatusContainer_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkOnlineStatusContainer_args typedOther = (checkOnlineStatusContainer_args)other;

      lastComparison = Boolean.valueOf(isSetUrls()).compareTo(typedOther.isSetUrls());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUrls()) {
        lastComparison = TBaseHelper.compareTo(this.urls, typedOther.urls);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFilename()).compareTo(typedOther.isSetFilename());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFilename()) {
        lastComparison = TBaseHelper.compareTo(this.filename, typedOther.filename);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetData()).compareTo(typedOther.isSetData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetData()) {
        lastComparison = TBaseHelper.compareTo(this.data, typedOther.data);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // URLS
            if (field.type == TType.LIST) {
              {
                TList _list84 = iprot.readListBegin();
                this.urls = new ArrayList<String>(_list84.size);
                for (int _i85 = 0; _i85 < _list84.size; ++_i85)
                {
                  String _elem86;
                  _elem86 = iprot.readString();
                  this.urls.add(_elem86);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // FILENAME
            if (field.type == TType.STRING) {
              this.filename = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // DATA
            if (field.type == TType.STRING) {
              this.data = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.urls != null) {
        oprot.writeFieldBegin(URLS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.urls.size()));
          for (String _iter87 : this.urls)
          {
            oprot.writeString(_iter87);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.filename != null) {
        oprot.writeFieldBegin(FILENAME_FIELD_DESC);
        oprot.writeString(this.filename);
        oprot.writeFieldEnd();
      }
      if (this.data != null) {
        oprot.writeFieldBegin(DATA_FIELD_DESC);
        oprot.writeBinary(this.data);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("checkOnlineStatusContainer_args(");
      boolean first = true;

      sb.append("urls:");
      if (this.urls == null) {
        sb.append("null");
      } else {
        sb.append(this.urls);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("filename:");
      if (this.filename == null) {
        sb.append("null");
      } else {
        sb.append(this.filename);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("data:");
      if (this.data == null) {
        sb.append("null");
      } else {
        TBaseHelper.toString(this.data, sb);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkOnlineStatusContainer_result implements TBase<checkOnlineStatusContainer_result, checkOnlineStatusContainer_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkOnlineStatusContainer_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public OnlineCheck success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, OnlineCheck.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkOnlineStatusContainer_result.class, metaDataMap);
    }

    public checkOnlineStatusContainer_result() {
    }

    public checkOnlineStatusContainer_result(
      OnlineCheck success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkOnlineStatusContainer_result(checkOnlineStatusContainer_result other) {
      if (other.isSetSuccess()) {
        this.success = new OnlineCheck(other.success);
      }
    }

    public checkOnlineStatusContainer_result deepCopy() {
      return new checkOnlineStatusContainer_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public OnlineCheck getSuccess() {
      return this.success;
    }

    public checkOnlineStatusContainer_result setSuccess(OnlineCheck success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((OnlineCheck)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkOnlineStatusContainer_result)
        return this.equals((checkOnlineStatusContainer_result)that);
      return false;
    }

    public boolean equals(checkOnlineStatusContainer_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkOnlineStatusContainer_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkOnlineStatusContainer_result typedOther = (checkOnlineStatusContainer_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new OnlineCheck();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("checkOnlineStatusContainer_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pollResults_args implements TBase<pollResults_args, pollResults_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pollResults_args");

    private static final TField RID_FIELD_DESC = new TField("rid", TType.I32, (short)1);

    public int rid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RID((short)1, "rid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // RID
            return RID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __RID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.RID, new FieldMetaData("rid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "ResultID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pollResults_args.class, metaDataMap);
    }

    public pollResults_args() {
    }

    public pollResults_args(
      int rid)
    {
      this();
      this.rid = rid;
      setRidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pollResults_args(pollResults_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.rid = other.rid;
    }

    public pollResults_args deepCopy() {
      return new pollResults_args(this);
    }

    
    public void clear() {
      setRidIsSet(false);
      this.rid = 0;
    }

    public int getRid() {
      return this.rid;
    }

    public pollResults_args setRid(int rid) {
      this.rid = rid;
      setRidIsSet(true);
      return this;
    }

    public void unsetRid() {
      __isset_bit_vector.clear(__RID_ISSET_ID);
    }

    /** Returns true if field rid is set (has been asigned a value) and false otherwise */
    public boolean isSetRid() {
      return __isset_bit_vector.get(__RID_ISSET_ID);
    }

    public void setRidIsSet(boolean value) {
      __isset_bit_vector.set(__RID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RID:
        if (value == null) {
          unsetRid();
        } else {
          setRid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RID:
        return new Integer(getRid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case RID:
        return isSetRid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pollResults_args)
        return this.equals((pollResults_args)that);
      return false;
    }

    public boolean equals(pollResults_args that) {
      if (that == null)
        return false;

      boolean this_present_rid = true;
      boolean that_present_rid = true;
      if (this_present_rid || that_present_rid) {
        if (!(this_present_rid && that_present_rid))
          return false;
        if (this.rid != that.rid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pollResults_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pollResults_args typedOther = (pollResults_args)other;

      lastComparison = Boolean.valueOf(isSetRid()).compareTo(typedOther.isSetRid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRid()) {
        lastComparison = TBaseHelper.compareTo(this.rid, typedOther.rid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // RID
            if (field.type == TType.I32) {
              this.rid = iprot.readI32();
              setRidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(RID_FIELD_DESC);
      oprot.writeI32(this.rid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pollResults_args(");
      boolean first = true;

      sb.append("rid:");
      sb.append(this.rid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pollResults_result implements TBase<pollResults_result, pollResults_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pollResults_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public OnlineCheck success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, OnlineCheck.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pollResults_result.class, metaDataMap);
    }

    public pollResults_result() {
    }

    public pollResults_result(
      OnlineCheck success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pollResults_result(pollResults_result other) {
      if (other.isSetSuccess()) {
        this.success = new OnlineCheck(other.success);
      }
    }

    public pollResults_result deepCopy() {
      return new pollResults_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public OnlineCheck getSuccess() {
      return this.success;
    }

    public pollResults_result setSuccess(OnlineCheck success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((OnlineCheck)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pollResults_result)
        return this.equals((pollResults_result)that);
      return false;
    }

    public boolean equals(pollResults_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pollResults_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pollResults_result typedOther = (pollResults_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new OnlineCheck();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pollResults_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class statusDownloads_args implements TBase<statusDownloads_args, statusDownloads_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("statusDownloads_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(statusDownloads_args.class, metaDataMap);
    }

    public statusDownloads_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statusDownloads_args(statusDownloads_args other) {
    }

    public statusDownloads_args deepCopy() {
      return new statusDownloads_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statusDownloads_args)
        return this.equals((statusDownloads_args)that);
      return false;
    }

    public boolean equals(statusDownloads_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(statusDownloads_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      statusDownloads_args typedOther = (statusDownloads_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("statusDownloads_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class statusDownloads_result implements TBase<statusDownloads_result, statusDownloads_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("statusDownloads_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<DownloadInfo> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, DownloadInfo.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(statusDownloads_result.class, metaDataMap);
    }

    public statusDownloads_result() {
    }

    public statusDownloads_result(
      List<DownloadInfo> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public statusDownloads_result(statusDownloads_result other) {
      if (other.isSetSuccess()) {
        List<DownloadInfo> __this__success = new ArrayList<DownloadInfo>();
        for (DownloadInfo other_element : other.success) {
          __this__success.add(new DownloadInfo(other_element));
        }
        this.success = __this__success;
      }
    }

    public statusDownloads_result deepCopy() {
      return new statusDownloads_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<DownloadInfo> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(DownloadInfo elem) {
      if (this.success == null) {
        this.success = new ArrayList<DownloadInfo>();
      }
      this.success.add(elem);
    }

    public List<DownloadInfo> getSuccess() {
      return this.success;
    }

    public statusDownloads_result setSuccess(List<DownloadInfo> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<DownloadInfo>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof statusDownloads_result)
        return this.equals((statusDownloads_result)that);
      return false;
    }

    public boolean equals(statusDownloads_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(statusDownloads_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      statusDownloads_result typedOther = (statusDownloads_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list88 = iprot.readListBegin();
                this.success = new ArrayList<DownloadInfo>(_list88.size);
                for (int _i89 = 0; _i89 < _list88.size; ++_i89)
                {
                  DownloadInfo _elem90;
                  _elem90 = new DownloadInfo();
                  _elem90.read(iprot);
                  this.success.add(_elem90);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (DownloadInfo _iter91 : this.success)
          {
            _iter91.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("statusDownloads_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPackageData_args implements TBase<getPackageData_args, getPackageData_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPackageData_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);

    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPackageData_args.class, metaDataMap);
    }

    public getPackageData_args() {
    }

    public getPackageData_args(
      int pid)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPackageData_args(getPackageData_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
    }

    public getPackageData_args deepCopy() {
      return new getPackageData_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public getPackageData_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPackageData_args)
        return this.equals((getPackageData_args)that);
      return false;
    }

    public boolean equals(getPackageData_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPackageData_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPackageData_args typedOther = (getPackageData_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPackageData_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPackageData_result implements TBase<getPackageData_result, getPackageData_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPackageData_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public PackageData success;
    public PackageDoesNotExists e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, PackageData.class)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPackageData_result.class, metaDataMap);
    }

    public getPackageData_result() {
    }

    public getPackageData_result(
      PackageData success,
      PackageDoesNotExists e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPackageData_result(getPackageData_result other) {
      if (other.isSetSuccess()) {
        this.success = new PackageData(other.success);
      }
      if (other.isSetE()) {
        this.e = new PackageDoesNotExists(other.e);
      }
    }

    public getPackageData_result deepCopy() {
      return new getPackageData_result(this);
    }

    
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public PackageData getSuccess() {
      return this.success;
    }

    public getPackageData_result setSuccess(PackageData success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public PackageDoesNotExists getE() {
      return this.e;
    }

    public getPackageData_result setE(PackageDoesNotExists e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((PackageData)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((PackageDoesNotExists)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPackageData_result)
        return this.equals((getPackageData_result)that);
      return false;
    }

    public boolean equals(getPackageData_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPackageData_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPackageData_result typedOther = (getPackageData_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new PackageData();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new PackageDoesNotExists();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPackageData_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPackageInfo_args implements TBase<getPackageInfo_args, getPackageInfo_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPackageInfo_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);

    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPackageInfo_args.class, metaDataMap);
    }

    public getPackageInfo_args() {
    }

    public getPackageInfo_args(
      int pid)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPackageInfo_args(getPackageInfo_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
    }

    public getPackageInfo_args deepCopy() {
      return new getPackageInfo_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public getPackageInfo_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPackageInfo_args)
        return this.equals((getPackageInfo_args)that);
      return false;
    }

    public boolean equals(getPackageInfo_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPackageInfo_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPackageInfo_args typedOther = (getPackageInfo_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPackageInfo_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPackageInfo_result implements TBase<getPackageInfo_result, getPackageInfo_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPackageInfo_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public PackageData success;
    public PackageDoesNotExists e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, PackageData.class)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPackageInfo_result.class, metaDataMap);
    }

    public getPackageInfo_result() {
    }

    public getPackageInfo_result(
      PackageData success,
      PackageDoesNotExists e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPackageInfo_result(getPackageInfo_result other) {
      if (other.isSetSuccess()) {
        this.success = new PackageData(other.success);
      }
      if (other.isSetE()) {
        this.e = new PackageDoesNotExists(other.e);
      }
    }

    public getPackageInfo_result deepCopy() {
      return new getPackageInfo_result(this);
    }

    
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public PackageData getSuccess() {
      return this.success;
    }

    public getPackageInfo_result setSuccess(PackageData success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public PackageDoesNotExists getE() {
      return this.e;
    }

    public getPackageInfo_result setE(PackageDoesNotExists e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((PackageData)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((PackageDoesNotExists)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPackageInfo_result)
        return this.equals((getPackageInfo_result)that);
      return false;
    }

    public boolean equals(getPackageInfo_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPackageInfo_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPackageInfo_result typedOther = (getPackageInfo_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new PackageData();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new PackageDoesNotExists();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPackageInfo_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getFileData_args implements TBase<getFileData_args, getFileData_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getFileData_args");

    private static final TField FID_FIELD_DESC = new TField("fid", TType.I32, (short)1);

    public int fid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FID((short)1, "fid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FID
            return FID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __FID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FID, new FieldMetaData("fid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "FileID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getFileData_args.class, metaDataMap);
    }

    public getFileData_args() {
    }

    public getFileData_args(
      int fid)
    {
      this();
      this.fid = fid;
      setFidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getFileData_args(getFileData_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.fid = other.fid;
    }

    public getFileData_args deepCopy() {
      return new getFileData_args(this);
    }

    
    public void clear() {
      setFidIsSet(false);
      this.fid = 0;
    }

    public int getFid() {
      return this.fid;
    }

    public getFileData_args setFid(int fid) {
      this.fid = fid;
      setFidIsSet(true);
      return this;
    }

    public void unsetFid() {
      __isset_bit_vector.clear(__FID_ISSET_ID);
    }

    /** Returns true if field fid is set (has been asigned a value) and false otherwise */
    public boolean isSetFid() {
      return __isset_bit_vector.get(__FID_ISSET_ID);
    }

    public void setFidIsSet(boolean value) {
      __isset_bit_vector.set(__FID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FID:
        if (value == null) {
          unsetFid();
        } else {
          setFid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FID:
        return new Integer(getFid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FID:
        return isSetFid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getFileData_args)
        return this.equals((getFileData_args)that);
      return false;
    }

    public boolean equals(getFileData_args that) {
      if (that == null)
        return false;

      boolean this_present_fid = true;
      boolean that_present_fid = true;
      if (this_present_fid || that_present_fid) {
        if (!(this_present_fid && that_present_fid))
          return false;
        if (this.fid != that.fid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getFileData_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getFileData_args typedOther = (getFileData_args)other;

      lastComparison = Boolean.valueOf(isSetFid()).compareTo(typedOther.isSetFid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFid()) {
        lastComparison = TBaseHelper.compareTo(this.fid, typedOther.fid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FID
            if (field.type == TType.I32) {
              this.fid = iprot.readI32();
              setFidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FID_FIELD_DESC);
      oprot.writeI32(this.fid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getFileData_args(");
      boolean first = true;

      sb.append("fid:");
      sb.append(this.fid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getFileData_result implements TBase<getFileData_result, getFileData_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getFileData_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public FileData success;
    public FileDoesNotExists e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, FileData.class)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getFileData_result.class, metaDataMap);
    }

    public getFileData_result() {
    }

    public getFileData_result(
      FileData success,
      FileDoesNotExists e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getFileData_result(getFileData_result other) {
      if (other.isSetSuccess()) {
        this.success = new FileData(other.success);
      }
      if (other.isSetE()) {
        this.e = new FileDoesNotExists(other.e);
      }
    }

    public getFileData_result deepCopy() {
      return new getFileData_result(this);
    }

    
    public void clear() {
      this.success = null;
      this.e = null;
    }

    public FileData getSuccess() {
      return this.success;
    }

    public getFileData_result setSuccess(FileData success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public FileDoesNotExists getE() {
      return this.e;
    }

    public getFileData_result setE(FileDoesNotExists e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((FileData)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((FileDoesNotExists)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getFileData_result)
        return this.equals((getFileData_result)that);
      return false;
    }

    public boolean equals(getFileData_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getFileData_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getFileData_result typedOther = (getFileData_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new FileData();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new FileDoesNotExists();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getFileData_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getQueue_args implements TBase<getQueue_args, getQueue_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getQueue_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getQueue_args.class, metaDataMap);
    }

    public getQueue_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getQueue_args(getQueue_args other) {
    }

    public getQueue_args deepCopy() {
      return new getQueue_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getQueue_args)
        return this.equals((getQueue_args)that);
      return false;
    }

    public boolean equals(getQueue_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getQueue_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getQueue_args typedOther = (getQueue_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getQueue_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getQueue_result implements TBase<getQueue_result, getQueue_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getQueue_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<PackageData> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, PackageData.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getQueue_result.class, metaDataMap);
    }

    public getQueue_result() {
    }

    public getQueue_result(
      List<PackageData> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getQueue_result(getQueue_result other) {
      if (other.isSetSuccess()) {
        List<PackageData> __this__success = new ArrayList<PackageData>();
        for (PackageData other_element : other.success) {
          __this__success.add(new PackageData(other_element));
        }
        this.success = __this__success;
      }
    }

    public getQueue_result deepCopy() {
      return new getQueue_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<PackageData> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(PackageData elem) {
      if (this.success == null) {
        this.success = new ArrayList<PackageData>();
      }
      this.success.add(elem);
    }

    public List<PackageData> getSuccess() {
      return this.success;
    }

    public getQueue_result setSuccess(List<PackageData> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<PackageData>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getQueue_result)
        return this.equals((getQueue_result)that);
      return false;
    }

    public boolean equals(getQueue_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getQueue_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getQueue_result typedOther = (getQueue_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list92 = iprot.readListBegin();
                this.success = new ArrayList<PackageData>(_list92.size);
                for (int _i93 = 0; _i93 < _list92.size; ++_i93)
                {
                  PackageData _elem94;
                  _elem94 = new PackageData();
                  _elem94.read(iprot);
                  this.success.add(_elem94);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (PackageData _iter95 : this.success)
          {
            _iter95.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getQueue_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCollector_args implements TBase<getCollector_args, getCollector_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCollector_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCollector_args.class, metaDataMap);
    }

    public getCollector_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCollector_args(getCollector_args other) {
    }

    public getCollector_args deepCopy() {
      return new getCollector_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCollector_args)
        return this.equals((getCollector_args)that);
      return false;
    }

    public boolean equals(getCollector_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCollector_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCollector_args typedOther = (getCollector_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCollector_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCollector_result implements TBase<getCollector_result, getCollector_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCollector_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<PackageData> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, PackageData.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCollector_result.class, metaDataMap);
    }

    public getCollector_result() {
    }

    public getCollector_result(
      List<PackageData> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCollector_result(getCollector_result other) {
      if (other.isSetSuccess()) {
        List<PackageData> __this__success = new ArrayList<PackageData>();
        for (PackageData other_element : other.success) {
          __this__success.add(new PackageData(other_element));
        }
        this.success = __this__success;
      }
    }

    public getCollector_result deepCopy() {
      return new getCollector_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<PackageData> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(PackageData elem) {
      if (this.success == null) {
        this.success = new ArrayList<PackageData>();
      }
      this.success.add(elem);
    }

    public List<PackageData> getSuccess() {
      return this.success;
    }

    public getCollector_result setSuccess(List<PackageData> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<PackageData>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCollector_result)
        return this.equals((getCollector_result)that);
      return false;
    }

    public boolean equals(getCollector_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCollector_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCollector_result typedOther = (getCollector_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list96 = iprot.readListBegin();
                this.success = new ArrayList<PackageData>(_list96.size);
                for (int _i97 = 0; _i97 < _list96.size; ++_i97)
                {
                  PackageData _elem98;
                  _elem98 = new PackageData();
                  _elem98.read(iprot);
                  this.success.add(_elem98);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (PackageData _iter99 : this.success)
          {
            _iter99.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCollector_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getQueueData_args implements TBase<getQueueData_args, getQueueData_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getQueueData_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getQueueData_args.class, metaDataMap);
    }

    public getQueueData_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getQueueData_args(getQueueData_args other) {
    }

    public getQueueData_args deepCopy() {
      return new getQueueData_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getQueueData_args)
        return this.equals((getQueueData_args)that);
      return false;
    }

    public boolean equals(getQueueData_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getQueueData_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getQueueData_args typedOther = (getQueueData_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getQueueData_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getQueueData_result implements TBase<getQueueData_result, getQueueData_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getQueueData_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<PackageData> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, PackageData.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getQueueData_result.class, metaDataMap);
    }

    public getQueueData_result() {
    }

    public getQueueData_result(
      List<PackageData> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getQueueData_result(getQueueData_result other) {
      if (other.isSetSuccess()) {
        List<PackageData> __this__success = new ArrayList<PackageData>();
        for (PackageData other_element : other.success) {
          __this__success.add(new PackageData(other_element));
        }
        this.success = __this__success;
      }
    }

    public getQueueData_result deepCopy() {
      return new getQueueData_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<PackageData> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(PackageData elem) {
      if (this.success == null) {
        this.success = new ArrayList<PackageData>();
      }
      this.success.add(elem);
    }

    public List<PackageData> getSuccess() {
      return this.success;
    }

    public getQueueData_result setSuccess(List<PackageData> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<PackageData>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getQueueData_result)
        return this.equals((getQueueData_result)that);
      return false;
    }

    public boolean equals(getQueueData_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getQueueData_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getQueueData_result typedOther = (getQueueData_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list100 = iprot.readListBegin();
                this.success = new ArrayList<PackageData>(_list100.size);
                for (int _i101 = 0; _i101 < _list100.size; ++_i101)
                {
                  PackageData _elem102;
                  _elem102 = new PackageData();
                  _elem102.read(iprot);
                  this.success.add(_elem102);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (PackageData _iter103 : this.success)
          {
            _iter103.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getQueueData_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCollectorData_args implements TBase<getCollectorData_args, getCollectorData_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCollectorData_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCollectorData_args.class, metaDataMap);
    }

    public getCollectorData_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCollectorData_args(getCollectorData_args other) {
    }

    public getCollectorData_args deepCopy() {
      return new getCollectorData_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCollectorData_args)
        return this.equals((getCollectorData_args)that);
      return false;
    }

    public boolean equals(getCollectorData_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCollectorData_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCollectorData_args typedOther = (getCollectorData_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCollectorData_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCollectorData_result implements TBase<getCollectorData_result, getCollectorData_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCollectorData_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<PackageData> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, PackageData.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCollectorData_result.class, metaDataMap);
    }

    public getCollectorData_result() {
    }

    public getCollectorData_result(
      List<PackageData> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCollectorData_result(getCollectorData_result other) {
      if (other.isSetSuccess()) {
        List<PackageData> __this__success = new ArrayList<PackageData>();
        for (PackageData other_element : other.success) {
          __this__success.add(new PackageData(other_element));
        }
        this.success = __this__success;
      }
    }

    public getCollectorData_result deepCopy() {
      return new getCollectorData_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<PackageData> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(PackageData elem) {
      if (this.success == null) {
        this.success = new ArrayList<PackageData>();
      }
      this.success.add(elem);
    }

    public List<PackageData> getSuccess() {
      return this.success;
    }

    public getCollectorData_result setSuccess(List<PackageData> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<PackageData>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCollectorData_result)
        return this.equals((getCollectorData_result)that);
      return false;
    }

    public boolean equals(getCollectorData_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCollectorData_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCollectorData_result typedOther = (getCollectorData_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list104 = iprot.readListBegin();
                this.success = new ArrayList<PackageData>(_list104.size);
                for (int _i105 = 0; _i105 < _list104.size; ++_i105)
                {
                  PackageData _elem106;
                  _elem106 = new PackageData();
                  _elem106.read(iprot);
                  this.success.add(_elem106);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (PackageData _iter107 : this.success)
          {
            _iter107.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCollectorData_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPackageOrder_args implements TBase<getPackageOrder_args, getPackageOrder_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPackageOrder_args");

    private static final TField DESTINATION_FIELD_DESC = new TField("destination", TType.I32, (short)1);

    /**
     * 
     * @see Destination
     */
    public Destination destination;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * 
       * @see Destination
       */
      DESTINATION((short)1, "destination");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DESTINATION
            return DESTINATION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DESTINATION, new FieldMetaData("destination", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, Destination.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPackageOrder_args.class, metaDataMap);
    }

    public getPackageOrder_args() {
    }

    public getPackageOrder_args(
      Destination destination)
    {
      this();
      this.destination = destination;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPackageOrder_args(getPackageOrder_args other) {
      if (other.isSetDestination()) {
        this.destination = other.destination;
      }
    }

    public getPackageOrder_args deepCopy() {
      return new getPackageOrder_args(this);
    }

    
    public void clear() {
      this.destination = null;
    }

    /**
     * 
     * @see Destination
     */
    public Destination getDestination() {
      return this.destination;
    }

    /**
     * 
     * @see Destination
     */
    public getPackageOrder_args setDestination(Destination destination) {
      this.destination = destination;
      return this;
    }

    public void unsetDestination() {
      this.destination = null;
    }

    /** Returns true if field destination is set (has been asigned a value) and false otherwise */
    public boolean isSetDestination() {
      return this.destination != null;
    }

    public void setDestinationIsSet(boolean value) {
      if (!value) {
        this.destination = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DESTINATION:
        if (value == null) {
          unsetDestination();
        } else {
          setDestination((Destination)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DESTINATION:
        return getDestination();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DESTINATION:
        return isSetDestination();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPackageOrder_args)
        return this.equals((getPackageOrder_args)that);
      return false;
    }

    public boolean equals(getPackageOrder_args that) {
      if (that == null)
        return false;

      boolean this_present_destination = true && this.isSetDestination();
      boolean that_present_destination = true && that.isSetDestination();
      if (this_present_destination || that_present_destination) {
        if (!(this_present_destination && that_present_destination))
          return false;
        if (!this.destination.equals(that.destination))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPackageOrder_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPackageOrder_args typedOther = (getPackageOrder_args)other;

      lastComparison = Boolean.valueOf(isSetDestination()).compareTo(typedOther.isSetDestination());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDestination()) {
        lastComparison = TBaseHelper.compareTo(this.destination, typedOther.destination);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DESTINATION
            if (field.type == TType.I32) {
              this.destination = Destination.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.destination != null) {
        oprot.writeFieldBegin(DESTINATION_FIELD_DESC);
        oprot.writeI32(this.destination.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPackageOrder_args(");
      boolean first = true;

      sb.append("destination:");
      if (this.destination == null) {
        sb.append("null");
      } else {
        sb.append(this.destination);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getPackageOrder_result implements TBase<getPackageOrder_result, getPackageOrder_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPackageOrder_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<Short,Integer> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I16), 
              new FieldValueMetaData(TType.I32              , "PackageID"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getPackageOrder_result.class, metaDataMap);
    }

    public getPackageOrder_result() {
    }

    public getPackageOrder_result(
      Map<Short,Integer> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPackageOrder_result(getPackageOrder_result other) {
      if (other.isSetSuccess()) {
        Map<Short,Integer> __this__success = new HashMap<Short,Integer>();
        for (Map.Entry<Short, Integer> other_element : other.success.entrySet()) {

          Short other_element_key = other_element.getKey();
          Integer other_element_value = other_element.getValue();

          Short __this__success_copy_key = other_element_key;

          Integer __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public getPackageOrder_result deepCopy() {
      return new getPackageOrder_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(short key, int val) {
      if (this.success == null) {
        this.success = new HashMap<Short,Integer>();
      }
      this.success.put(key, val);
    }

    public Map<Short,Integer> getSuccess() {
      return this.success;
    }

    public getPackageOrder_result setSuccess(Map<Short,Integer> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<Short,Integer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPackageOrder_result)
        return this.equals((getPackageOrder_result)that);
      return false;
    }

    public boolean equals(getPackageOrder_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getPackageOrder_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getPackageOrder_result typedOther = (getPackageOrder_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map108 = iprot.readMapBegin();
                this.success = new HashMap<Short,Integer>(2*_map108.size);
                for (int _i109 = 0; _i109 < _map108.size; ++_i109)
                {
                  short _key110;
                  int _val111;
                  _key110 = iprot.readI16();
                  _val111 = iprot.readI32();
                  this.success.put(_key110, _val111);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I16, TType.I32, this.success.size()));
          for (Map.Entry<Short, Integer> _iter112 : this.success.entrySet())
          {
            oprot.writeI16(_iter112.getKey());
            oprot.writeI32(_iter112.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getPackageOrder_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getFileOrder_args implements TBase<getFileOrder_args, getFileOrder_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getFileOrder_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);

    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getFileOrder_args.class, metaDataMap);
    }

    public getFileOrder_args() {
    }

    public getFileOrder_args(
      int pid)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getFileOrder_args(getFileOrder_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
    }

    public getFileOrder_args deepCopy() {
      return new getFileOrder_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public getFileOrder_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getFileOrder_args)
        return this.equals((getFileOrder_args)that);
      return false;
    }

    public boolean equals(getFileOrder_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getFileOrder_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getFileOrder_args typedOther = (getFileOrder_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getFileOrder_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getFileOrder_result implements TBase<getFileOrder_result, getFileOrder_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getFileOrder_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<Short,Integer> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I16), 
              new FieldValueMetaData(TType.I32              , "FileID"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getFileOrder_result.class, metaDataMap);
    }

    public getFileOrder_result() {
    }

    public getFileOrder_result(
      Map<Short,Integer> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getFileOrder_result(getFileOrder_result other) {
      if (other.isSetSuccess()) {
        Map<Short,Integer> __this__success = new HashMap<Short,Integer>();
        for (Map.Entry<Short, Integer> other_element : other.success.entrySet()) {

          Short other_element_key = other_element.getKey();
          Integer other_element_value = other_element.getValue();

          Short __this__success_copy_key = other_element_key;

          Integer __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public getFileOrder_result deepCopy() {
      return new getFileOrder_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(short key, int val) {
      if (this.success == null) {
        this.success = new HashMap<Short,Integer>();
      }
      this.success.put(key, val);
    }

    public Map<Short,Integer> getSuccess() {
      return this.success;
    }

    public getFileOrder_result setSuccess(Map<Short,Integer> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<Short,Integer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getFileOrder_result)
        return this.equals((getFileOrder_result)that);
      return false;
    }

    public boolean equals(getFileOrder_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getFileOrder_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getFileOrder_result typedOther = (getFileOrder_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map113 = iprot.readMapBegin();
                this.success = new HashMap<Short,Integer>(2*_map113.size);
                for (int _i114 = 0; _i114 < _map113.size; ++_i114)
                {
                  short _key115;
                  int _val116;
                  _key115 = iprot.readI16();
                  _val116 = iprot.readI32();
                  this.success.put(_key115, _val116);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I16, TType.I32, this.success.size()));
          for (Map.Entry<Short, Integer> _iter117 : this.success.entrySet())
          {
            oprot.writeI16(_iter117.getKey());
            oprot.writeI32(_iter117.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getFileOrder_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class generateAndAddPackages_args implements TBase<generateAndAddPackages_args, generateAndAddPackages_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("generateAndAddPackages_args");

    private static final TField LINKS_FIELD_DESC = new TField("links", TType.LIST, (short)1);
    private static final TField DEST_FIELD_DESC = new TField("dest", TType.I32, (short)2);

    public List<String> links;
    /**
     * 
     * @see Destination
     */
    public Destination dest;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      LINKS((short)1, "links"),
      /**
       * 
       * @see Destination
       */
      DEST((short)2, "dest");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // LINKS
            return LINKS;
          case 2: // DEST
            return DEST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.LINKS, new FieldMetaData("links", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "LinkList")));
      tmpMap.put(_Fields.DEST, new FieldMetaData("dest", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, Destination.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(generateAndAddPackages_args.class, metaDataMap);
    }

    public generateAndAddPackages_args() {
    }

    public generateAndAddPackages_args(
      List<String> links,
      Destination dest)
    {
      this();
      this.links = links;
      this.dest = dest;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public generateAndAddPackages_args(generateAndAddPackages_args other) {
      if (other.isSetLinks()) {
        this.links = other.links;
      }
      if (other.isSetDest()) {
        this.dest = other.dest;
      }
    }

    public generateAndAddPackages_args deepCopy() {
      return new generateAndAddPackages_args(this);
    }

    
    public void clear() {
      this.links = null;
      this.dest = null;
    }

    public int getLinksSize() {
      return (this.links == null) ? 0 : this.links.size();
    }

    public java.util.Iterator<String> getLinksIterator() {
      return (this.links == null) ? null : this.links.iterator();
    }

    public void addToLinks(String elem) {
      if (this.links == null) {
        this.links = new ArrayList<String>();
      }
      this.links.add(elem);
    }

    public List<String> getLinks() {
      return this.links;
    }

    public generateAndAddPackages_args setLinks(List<String> links) {
      this.links = links;
      return this;
    }

    public void unsetLinks() {
      this.links = null;
    }

    /** Returns true if field links is set (has been asigned a value) and false otherwise */
    public boolean isSetLinks() {
      return this.links != null;
    }

    public void setLinksIsSet(boolean value) {
      if (!value) {
        this.links = null;
      }
    }

    /**
     * 
     * @see Destination
     */
    public Destination getDest() {
      return this.dest;
    }

    /**
     * 
     * @see Destination
     */
    public generateAndAddPackages_args setDest(Destination dest) {
      this.dest = dest;
      return this;
    }

    public void unsetDest() {
      this.dest = null;
    }

    /** Returns true if field dest is set (has been asigned a value) and false otherwise */
    public boolean isSetDest() {
      return this.dest != null;
    }

    public void setDestIsSet(boolean value) {
      if (!value) {
        this.dest = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case LINKS:
        if (value == null) {
          unsetLinks();
        } else {
          setLinks((List<String>)value);
        }
        break;

      case DEST:
        if (value == null) {
          unsetDest();
        } else {
          setDest((Destination)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case LINKS:
        return getLinks();

      case DEST:
        return getDest();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case LINKS:
        return isSetLinks();
      case DEST:
        return isSetDest();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof generateAndAddPackages_args)
        return this.equals((generateAndAddPackages_args)that);
      return false;
    }

    public boolean equals(generateAndAddPackages_args that) {
      if (that == null)
        return false;

      boolean this_present_links = true && this.isSetLinks();
      boolean that_present_links = true && that.isSetLinks();
      if (this_present_links || that_present_links) {
        if (!(this_present_links && that_present_links))
          return false;
        if (!this.links.equals(that.links))
          return false;
      }

      boolean this_present_dest = true && this.isSetDest();
      boolean that_present_dest = true && that.isSetDest();
      if (this_present_dest || that_present_dest) {
        if (!(this_present_dest && that_present_dest))
          return false;
        if (!this.dest.equals(that.dest))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(generateAndAddPackages_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      generateAndAddPackages_args typedOther = (generateAndAddPackages_args)other;

      lastComparison = Boolean.valueOf(isSetLinks()).compareTo(typedOther.isSetLinks());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLinks()) {
        lastComparison = TBaseHelper.compareTo(this.links, typedOther.links);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDest()).compareTo(typedOther.isSetDest());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDest()) {
        lastComparison = TBaseHelper.compareTo(this.dest, typedOther.dest);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // LINKS
            if (field.type == TType.LIST) {
              {
                TList _list118 = iprot.readListBegin();
                this.links = new ArrayList<String>(_list118.size);
                for (int _i119 = 0; _i119 < _list118.size; ++_i119)
                {
                  String _elem120;
                  _elem120 = iprot.readString();
                  this.links.add(_elem120);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DEST
            if (field.type == TType.I32) {
              this.dest = Destination.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.links != null) {
        oprot.writeFieldBegin(LINKS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.links.size()));
          for (String _iter121 : this.links)
          {
            oprot.writeString(_iter121);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.dest != null) {
        oprot.writeFieldBegin(DEST_FIELD_DESC);
        oprot.writeI32(this.dest.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("generateAndAddPackages_args(");
      boolean first = true;

      sb.append("links:");
      if (this.links == null) {
        sb.append("null");
      } else {
        sb.append(this.links);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("dest:");
      if (this.dest == null) {
        sb.append("null");
      } else {
        sb.append(this.dest);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class generateAndAddPackages_result implements TBase<generateAndAddPackages_result, generateAndAddPackages_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("generateAndAddPackages_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<Integer> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I32              , "PackageID"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(generateAndAddPackages_result.class, metaDataMap);
    }

    public generateAndAddPackages_result() {
    }

    public generateAndAddPackages_result(
      List<Integer> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public generateAndAddPackages_result(generateAndAddPackages_result other) {
      if (other.isSetSuccess()) {
        List<Integer> __this__success = new ArrayList<Integer>();
        for (Integer other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public generateAndAddPackages_result deepCopy() {
      return new generateAndAddPackages_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Integer> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(int elem) {
      if (this.success == null) {
        this.success = new ArrayList<Integer>();
      }
      this.success.add(elem);
    }

    public List<Integer> getSuccess() {
      return this.success;
    }

    public generateAndAddPackages_result setSuccess(List<Integer> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Integer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof generateAndAddPackages_result)
        return this.equals((generateAndAddPackages_result)that);
      return false;
    }

    public boolean equals(generateAndAddPackages_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(generateAndAddPackages_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      generateAndAddPackages_result typedOther = (generateAndAddPackages_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list122 = iprot.readListBegin();
                this.success = new ArrayList<Integer>(_list122.size);
                for (int _i123 = 0; _i123 < _list122.size; ++_i123)
                {
                  int _elem124;
                  _elem124 = iprot.readI32();
                  this.success.add(_elem124);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.success.size()));
          for (int _iter125 : this.success)
          {
            oprot.writeI32(_iter125);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("generateAndAddPackages_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addPackage_args implements TBase<addPackage_args, addPackage_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("addPackage_args");

    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField LINKS_FIELD_DESC = new TField("links", TType.LIST, (short)2);
    private static final TField DEST_FIELD_DESC = new TField("dest", TType.I32, (short)3);

    public String name;
    public List<String> links;
    /**
     * 
     * @see Destination
     */
    public Destination dest;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      NAME((short)1, "name"),
      LINKS((short)2, "links"),
      /**
       * 
       * @see Destination
       */
      DEST((short)3, "dest");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // NAME
            return NAME;
          case 2: // LINKS
            return LINKS;
          case 3: // DEST
            return DEST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.LINKS, new FieldMetaData("links", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "LinkList")));
      tmpMap.put(_Fields.DEST, new FieldMetaData("dest", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, Destination.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(addPackage_args.class, metaDataMap);
    }

    public addPackage_args() {
    }

    public addPackage_args(
      String name,
      List<String> links,
      Destination dest)
    {
      this();
      this.name = name;
      this.links = links;
      this.dest = dest;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addPackage_args(addPackage_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      if (other.isSetLinks()) {
        this.links = other.links;
      }
      if (other.isSetDest()) {
        this.dest = other.dest;
      }
    }

    public addPackage_args deepCopy() {
      return new addPackage_args(this);
    }

    
    public void clear() {
      this.name = null;
      this.links = null;
      this.dest = null;
    }

    public String getName() {
      return this.name;
    }

    public addPackage_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public int getLinksSize() {
      return (this.links == null) ? 0 : this.links.size();
    }

    public java.util.Iterator<String> getLinksIterator() {
      return (this.links == null) ? null : this.links.iterator();
    }

    public void addToLinks(String elem) {
      if (this.links == null) {
        this.links = new ArrayList<String>();
      }
      this.links.add(elem);
    }

    public List<String> getLinks() {
      return this.links;
    }

    public addPackage_args setLinks(List<String> links) {
      this.links = links;
      return this;
    }

    public void unsetLinks() {
      this.links = null;
    }

    /** Returns true if field links is set (has been asigned a value) and false otherwise */
    public boolean isSetLinks() {
      return this.links != null;
    }

    public void setLinksIsSet(boolean value) {
      if (!value) {
        this.links = null;
      }
    }

    /**
     * 
     * @see Destination
     */
    public Destination getDest() {
      return this.dest;
    }

    /**
     * 
     * @see Destination
     */
    public addPackage_args setDest(Destination dest) {
      this.dest = dest;
      return this;
    }

    public void unsetDest() {
      this.dest = null;
    }

    /** Returns true if field dest is set (has been asigned a value) and false otherwise */
    public boolean isSetDest() {
      return this.dest != null;
    }

    public void setDestIsSet(boolean value) {
      if (!value) {
        this.dest = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case LINKS:
        if (value == null) {
          unsetLinks();
        } else {
          setLinks((List<String>)value);
        }
        break;

      case DEST:
        if (value == null) {
          unsetDest();
        } else {
          setDest((Destination)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case NAME:
        return getName();

      case LINKS:
        return getLinks();

      case DEST:
        return getDest();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case NAME:
        return isSetName();
      case LINKS:
        return isSetLinks();
      case DEST:
        return isSetDest();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addPackage_args)
        return this.equals((addPackage_args)that);
      return false;
    }

    public boolean equals(addPackage_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_links = true && this.isSetLinks();
      boolean that_present_links = true && that.isSetLinks();
      if (this_present_links || that_present_links) {
        if (!(this_present_links && that_present_links))
          return false;
        if (!this.links.equals(that.links))
          return false;
      }

      boolean this_present_dest = true && this.isSetDest();
      boolean that_present_dest = true && that.isSetDest();
      if (this_present_dest || that_present_dest) {
        if (!(this_present_dest && that_present_dest))
          return false;
        if (!this.dest.equals(that.dest))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(addPackage_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addPackage_args typedOther = (addPackage_args)other;

      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLinks()).compareTo(typedOther.isSetLinks());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLinks()) {
        lastComparison = TBaseHelper.compareTo(this.links, typedOther.links);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDest()).compareTo(typedOther.isSetDest());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDest()) {
        lastComparison = TBaseHelper.compareTo(this.dest, typedOther.dest);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // LINKS
            if (field.type == TType.LIST) {
              {
                TList _list126 = iprot.readListBegin();
                this.links = new ArrayList<String>(_list126.size);
                for (int _i127 = 0; _i127 < _list126.size; ++_i127)
                {
                  String _elem128;
                  _elem128 = iprot.readString();
                  this.links.add(_elem128);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // DEST
            if (field.type == TType.I32) {
              this.dest = Destination.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      if (this.links != null) {
        oprot.writeFieldBegin(LINKS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.links.size()));
          for (String _iter129 : this.links)
          {
            oprot.writeString(_iter129);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.dest != null) {
        oprot.writeFieldBegin(DEST_FIELD_DESC);
        oprot.writeI32(this.dest.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("addPackage_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("links:");
      if (this.links == null) {
        sb.append("null");
      } else {
        sb.append(this.links);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("dest:");
      if (this.dest == null) {
        sb.append("null");
      } else {
        sb.append(this.dest);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addPackage_result implements TBase<addPackage_result, addPackage_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("addPackage_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);

    public int success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(addPackage_result.class, metaDataMap);
    }

    public addPackage_result() {
    }

    public addPackage_result(
      int success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addPackage_result(addPackage_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public addPackage_result deepCopy() {
      return new addPackage_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
    }

    public int getSuccess() {
      return this.success;
    }

    public addPackage_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addPackage_result)
        return this.equals((addPackage_result)that);
      return false;
    }

    public boolean equals(addPackage_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(addPackage_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addPackage_result typedOther = (addPackage_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("addPackage_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addFiles_args implements TBase<addFiles_args, addFiles_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("addFiles_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);
    private static final TField LINKS_FIELD_DESC = new TField("links", TType.LIST, (short)2);

    public int pid;
    public List<String> links;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid"),
      LINKS((short)2, "links");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          case 2: // LINKS
            return LINKS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      tmpMap.put(_Fields.LINKS, new FieldMetaData("links", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.LIST          , "LinkList")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(addFiles_args.class, metaDataMap);
    }

    public addFiles_args() {
    }

    public addFiles_args(
      int pid,
      List<String> links)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
      this.links = links;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addFiles_args(addFiles_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
      if (other.isSetLinks()) {
        this.links = other.links;
      }
    }

    public addFiles_args deepCopy() {
      return new addFiles_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
      this.links = null;
    }

    public int getPid() {
      return this.pid;
    }

    public addFiles_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public int getLinksSize() {
      return (this.links == null) ? 0 : this.links.size();
    }

    public java.util.Iterator<String> getLinksIterator() {
      return (this.links == null) ? null : this.links.iterator();
    }

    public void addToLinks(String elem) {
      if (this.links == null) {
        this.links = new ArrayList<String>();
      }
      this.links.add(elem);
    }

    public List<String> getLinks() {
      return this.links;
    }

    public addFiles_args setLinks(List<String> links) {
      this.links = links;
      return this;
    }

    public void unsetLinks() {
      this.links = null;
    }

    /** Returns true if field links is set (has been asigned a value) and false otherwise */
    public boolean isSetLinks() {
      return this.links != null;
    }

    public void setLinksIsSet(boolean value) {
      if (!value) {
        this.links = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      case LINKS:
        if (value == null) {
          unsetLinks();
        } else {
          setLinks((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      case LINKS:
        return getLinks();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      case LINKS:
        return isSetLinks();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addFiles_args)
        return this.equals((addFiles_args)that);
      return false;
    }

    public boolean equals(addFiles_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      boolean this_present_links = true && this.isSetLinks();
      boolean that_present_links = true && that.isSetLinks();
      if (this_present_links || that_present_links) {
        if (!(this_present_links && that_present_links))
          return false;
        if (!this.links.equals(that.links))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(addFiles_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addFiles_args typedOther = (addFiles_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLinks()).compareTo(typedOther.isSetLinks());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLinks()) {
        lastComparison = TBaseHelper.compareTo(this.links, typedOther.links);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // LINKS
            if (field.type == TType.LIST) {
              {
                TList _list130 = iprot.readListBegin();
                this.links = new ArrayList<String>(_list130.size);
                for (int _i131 = 0; _i131 < _list130.size; ++_i131)
                {
                  String _elem132;
                  _elem132 = iprot.readString();
                  this.links.add(_elem132);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      if (this.links != null) {
        oprot.writeFieldBegin(LINKS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.links.size()));
          for (String _iter133 : this.links)
          {
            oprot.writeString(_iter133);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("addFiles_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      if (!first) sb.append(", ");
      sb.append("links:");
      if (this.links == null) {
        sb.append("null");
      } else {
        sb.append(this.links);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addFiles_result implements TBase<addFiles_result, addFiles_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("addFiles_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(addFiles_result.class, metaDataMap);
    }

    public addFiles_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addFiles_result(addFiles_result other) {
    }

    public addFiles_result deepCopy() {
      return new addFiles_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addFiles_result)
        return this.equals((addFiles_result)that);
      return false;
    }

    public boolean equals(addFiles_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(addFiles_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addFiles_result typedOther = (addFiles_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("addFiles_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class uploadContainer_args implements TBase<uploadContainer_args, uploadContainer_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("uploadContainer_args");

    private static final TField FILENAME_FIELD_DESC = new TField("filename", TType.STRING, (short)1);
    private static final TField DATA_FIELD_DESC = new TField("data", TType.STRING, (short)2);

    public String filename;
    public ByteBuffer data;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FILENAME((short)1, "filename"),
      DATA((short)2, "data");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FILENAME
            return FILENAME;
          case 2: // DATA
            return DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FILENAME, new FieldMetaData("filename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DATA, new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(uploadContainer_args.class, metaDataMap);
    }

    public uploadContainer_args() {
    }

    public uploadContainer_args(
      String filename,
      ByteBuffer data)
    {
      this();
      this.filename = filename;
      this.data = data;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public uploadContainer_args(uploadContainer_args other) {
      if (other.isSetFilename()) {
        this.filename = other.filename;
      }
      if (other.isSetData()) {
        this.data = TBaseHelper.copyBinary(other.data);
;
      }
    }

    public uploadContainer_args deepCopy() {
      return new uploadContainer_args(this);
    }

    
    public void clear() {
      this.filename = null;
      this.data = null;
    }

    public String getFilename() {
      return this.filename;
    }

    public uploadContainer_args setFilename(String filename) {
      this.filename = filename;
      return this;
    }

    public void unsetFilename() {
      this.filename = null;
    }

    /** Returns true if field filename is set (has been asigned a value) and false otherwise */
    public boolean isSetFilename() {
      return this.filename != null;
    }

    public void setFilenameIsSet(boolean value) {
      if (!value) {
        this.filename = null;
      }
    }

    public byte[] getData() {
      setData(TBaseHelper.rightSize(data));
      return data.array();
    }

    public ByteBuffer BufferForData() {
      return data;
    }

    public uploadContainer_args setData(byte[] data) {
      setData(ByteBuffer.wrap(data));
      return this;
    }

    public uploadContainer_args setData(ByteBuffer data) {
      this.data = data;
      return this;
    }

    public void unsetData() {
      this.data = null;
    }

    /** Returns true if field data is set (has been asigned a value) and false otherwise */
    public boolean isSetData() {
      return this.data != null;
    }

    public void setDataIsSet(boolean value) {
      if (!value) {
        this.data = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FILENAME:
        if (value == null) {
          unsetFilename();
        } else {
          setFilename((String)value);
        }
        break;

      case DATA:
        if (value == null) {
          unsetData();
        } else {
          setData((ByteBuffer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FILENAME:
        return getFilename();

      case DATA:
        return getData();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FILENAME:
        return isSetFilename();
      case DATA:
        return isSetData();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof uploadContainer_args)
        return this.equals((uploadContainer_args)that);
      return false;
    }

    public boolean equals(uploadContainer_args that) {
      if (that == null)
        return false;

      boolean this_present_filename = true && this.isSetFilename();
      boolean that_present_filename = true && that.isSetFilename();
      if (this_present_filename || that_present_filename) {
        if (!(this_present_filename && that_present_filename))
          return false;
        if (!this.filename.equals(that.filename))
          return false;
      }

      boolean this_present_data = true && this.isSetData();
      boolean that_present_data = true && that.isSetData();
      if (this_present_data || that_present_data) {
        if (!(this_present_data && that_present_data))
          return false;
        if (!this.data.equals(that.data))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(uploadContainer_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      uploadContainer_args typedOther = (uploadContainer_args)other;

      lastComparison = Boolean.valueOf(isSetFilename()).compareTo(typedOther.isSetFilename());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFilename()) {
        lastComparison = TBaseHelper.compareTo(this.filename, typedOther.filename);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetData()).compareTo(typedOther.isSetData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetData()) {
        lastComparison = TBaseHelper.compareTo(this.data, typedOther.data);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FILENAME
            if (field.type == TType.STRING) {
              this.filename = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DATA
            if (field.type == TType.STRING) {
              this.data = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.filename != null) {
        oprot.writeFieldBegin(FILENAME_FIELD_DESC);
        oprot.writeString(this.filename);
        oprot.writeFieldEnd();
      }
      if (this.data != null) {
        oprot.writeFieldBegin(DATA_FIELD_DESC);
        oprot.writeBinary(this.data);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("uploadContainer_args(");
      boolean first = true;

      sb.append("filename:");
      if (this.filename == null) {
        sb.append("null");
      } else {
        sb.append(this.filename);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("data:");
      if (this.data == null) {
        sb.append("null");
      } else {
        TBaseHelper.toString(this.data, sb);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class uploadContainer_result implements TBase<uploadContainer_result, uploadContainer_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("uploadContainer_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(uploadContainer_result.class, metaDataMap);
    }

    public uploadContainer_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public uploadContainer_result(uploadContainer_result other) {
    }

    public uploadContainer_result deepCopy() {
      return new uploadContainer_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof uploadContainer_result)
        return this.equals((uploadContainer_result)that);
      return false;
    }

    public boolean equals(uploadContainer_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(uploadContainer_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      uploadContainer_result typedOther = (uploadContainer_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("uploadContainer_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteFiles_args implements TBase<deleteFiles_args, deleteFiles_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteFiles_args");

    private static final TField FIDS_FIELD_DESC = new TField("fids", TType.LIST, (short)1);

    public List<Integer> fids;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FIDS((short)1, "fids");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FIDS
            return FIDS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FIDS, new FieldMetaData("fids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I32              , "FileID"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteFiles_args.class, metaDataMap);
    }

    public deleteFiles_args() {
    }

    public deleteFiles_args(
      List<Integer> fids)
    {
      this();
      this.fids = fids;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteFiles_args(deleteFiles_args other) {
      if (other.isSetFids()) {
        List<Integer> __this__fids = new ArrayList<Integer>();
        for (Integer other_element : other.fids) {
          __this__fids.add(other_element);
        }
        this.fids = __this__fids;
      }
    }

    public deleteFiles_args deepCopy() {
      return new deleteFiles_args(this);
    }

    
    public void clear() {
      this.fids = null;
    }

    public int getFidsSize() {
      return (this.fids == null) ? 0 : this.fids.size();
    }

    public java.util.Iterator<Integer> getFidsIterator() {
      return (this.fids == null) ? null : this.fids.iterator();
    }

    public void addToFids(int elem) {
      if (this.fids == null) {
        this.fids = new ArrayList<Integer>();
      }
      this.fids.add(elem);
    }

    public List<Integer> getFids() {
      return this.fids;
    }

    public deleteFiles_args setFids(List<Integer> fids) {
      this.fids = fids;
      return this;
    }

    public void unsetFids() {
      this.fids = null;
    }

    /** Returns true if field fids is set (has been asigned a value) and false otherwise */
    public boolean isSetFids() {
      return this.fids != null;
    }

    public void setFidsIsSet(boolean value) {
      if (!value) {
        this.fids = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FIDS:
        if (value == null) {
          unsetFids();
        } else {
          setFids((List<Integer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FIDS:
        return getFids();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FIDS:
        return isSetFids();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteFiles_args)
        return this.equals((deleteFiles_args)that);
      return false;
    }

    public boolean equals(deleteFiles_args that) {
      if (that == null)
        return false;

      boolean this_present_fids = true && this.isSetFids();
      boolean that_present_fids = true && that.isSetFids();
      if (this_present_fids || that_present_fids) {
        if (!(this_present_fids && that_present_fids))
          return false;
        if (!this.fids.equals(that.fids))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteFiles_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteFiles_args typedOther = (deleteFiles_args)other;

      lastComparison = Boolean.valueOf(isSetFids()).compareTo(typedOther.isSetFids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFids()) {
        lastComparison = TBaseHelper.compareTo(this.fids, typedOther.fids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FIDS
            if (field.type == TType.LIST) {
              {
                TList _list134 = iprot.readListBegin();
                this.fids = new ArrayList<Integer>(_list134.size);
                for (int _i135 = 0; _i135 < _list134.size; ++_i135)
                {
                  int _elem136;
                  _elem136 = iprot.readI32();
                  this.fids.add(_elem136);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.fids != null) {
        oprot.writeFieldBegin(FIDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.fids.size()));
          for (int _iter137 : this.fids)
          {
            oprot.writeI32(_iter137);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteFiles_args(");
      boolean first = true;

      sb.append("fids:");
      if (this.fids == null) {
        sb.append("null");
      } else {
        sb.append(this.fids);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteFiles_result implements TBase<deleteFiles_result, deleteFiles_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteFiles_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteFiles_result.class, metaDataMap);
    }

    public deleteFiles_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteFiles_result(deleteFiles_result other) {
    }

    public deleteFiles_result deepCopy() {
      return new deleteFiles_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteFiles_result)
        return this.equals((deleteFiles_result)that);
      return false;
    }

    public boolean equals(deleteFiles_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteFiles_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteFiles_result typedOther = (deleteFiles_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteFiles_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deletePackages_args implements TBase<deletePackages_args, deletePackages_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deletePackages_args");

    private static final TField PIDS_FIELD_DESC = new TField("pids", TType.LIST, (short)1);

    public List<Integer> pids;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PIDS((short)1, "pids");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PIDS
            return PIDS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PIDS, new FieldMetaData("pids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I32              , "PackageID"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deletePackages_args.class, metaDataMap);
    }

    public deletePackages_args() {
    }

    public deletePackages_args(
      List<Integer> pids)
    {
      this();
      this.pids = pids;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deletePackages_args(deletePackages_args other) {
      if (other.isSetPids()) {
        List<Integer> __this__pids = new ArrayList<Integer>();
        for (Integer other_element : other.pids) {
          __this__pids.add(other_element);
        }
        this.pids = __this__pids;
      }
    }

    public deletePackages_args deepCopy() {
      return new deletePackages_args(this);
    }

    
    public void clear() {
      this.pids = null;
    }

    public int getPidsSize() {
      return (this.pids == null) ? 0 : this.pids.size();
    }

    public java.util.Iterator<Integer> getPidsIterator() {
      return (this.pids == null) ? null : this.pids.iterator();
    }

    public void addToPids(int elem) {
      if (this.pids == null) {
        this.pids = new ArrayList<Integer>();
      }
      this.pids.add(elem);
    }

    public List<Integer> getPids() {
      return this.pids;
    }

    public deletePackages_args setPids(List<Integer> pids) {
      this.pids = pids;
      return this;
    }

    public void unsetPids() {
      this.pids = null;
    }

    /** Returns true if field pids is set (has been asigned a value) and false otherwise */
    public boolean isSetPids() {
      return this.pids != null;
    }

    public void setPidsIsSet(boolean value) {
      if (!value) {
        this.pids = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PIDS:
        if (value == null) {
          unsetPids();
        } else {
          setPids((List<Integer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PIDS:
        return getPids();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PIDS:
        return isSetPids();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deletePackages_args)
        return this.equals((deletePackages_args)that);
      return false;
    }

    public boolean equals(deletePackages_args that) {
      if (that == null)
        return false;

      boolean this_present_pids = true && this.isSetPids();
      boolean that_present_pids = true && that.isSetPids();
      if (this_present_pids || that_present_pids) {
        if (!(this_present_pids && that_present_pids))
          return false;
        if (!this.pids.equals(that.pids))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(deletePackages_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deletePackages_args typedOther = (deletePackages_args)other;

      lastComparison = Boolean.valueOf(isSetPids()).compareTo(typedOther.isSetPids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPids()) {
        lastComparison = TBaseHelper.compareTo(this.pids, typedOther.pids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PIDS
            if (field.type == TType.LIST) {
              {
                TList _list138 = iprot.readListBegin();
                this.pids = new ArrayList<Integer>(_list138.size);
                for (int _i139 = 0; _i139 < _list138.size; ++_i139)
                {
                  int _elem140;
                  _elem140 = iprot.readI32();
                  this.pids.add(_elem140);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.pids != null) {
        oprot.writeFieldBegin(PIDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.pids.size()));
          for (int _iter141 : this.pids)
          {
            oprot.writeI32(_iter141);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("deletePackages_args(");
      boolean first = true;

      sb.append("pids:");
      if (this.pids == null) {
        sb.append("null");
      } else {
        sb.append(this.pids);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deletePackages_result implements TBase<deletePackages_result, deletePackages_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deletePackages_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deletePackages_result.class, metaDataMap);
    }

    public deletePackages_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deletePackages_result(deletePackages_result other) {
    }

    public deletePackages_result deepCopy() {
      return new deletePackages_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deletePackages_result)
        return this.equals((deletePackages_result)that);
      return false;
    }

    public boolean equals(deletePackages_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(deletePackages_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deletePackages_result typedOther = (deletePackages_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("deletePackages_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pushToQueue_args implements TBase<pushToQueue_args, pushToQueue_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pushToQueue_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);

    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pushToQueue_args.class, metaDataMap);
    }

    public pushToQueue_args() {
    }

    public pushToQueue_args(
      int pid)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pushToQueue_args(pushToQueue_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
    }

    public pushToQueue_args deepCopy() {
      return new pushToQueue_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public pushToQueue_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pushToQueue_args)
        return this.equals((pushToQueue_args)that);
      return false;
    }

    public boolean equals(pushToQueue_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pushToQueue_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pushToQueue_args typedOther = (pushToQueue_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pushToQueue_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pushToQueue_result implements TBase<pushToQueue_result, pushToQueue_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pushToQueue_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pushToQueue_result.class, metaDataMap);
    }

    public pushToQueue_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pushToQueue_result(pushToQueue_result other) {
    }

    public pushToQueue_result deepCopy() {
      return new pushToQueue_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pushToQueue_result)
        return this.equals((pushToQueue_result)that);
      return false;
    }

    public boolean equals(pushToQueue_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pushToQueue_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pushToQueue_result typedOther = (pushToQueue_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pushToQueue_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pullFromQueue_args implements TBase<pullFromQueue_args, pullFromQueue_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pullFromQueue_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);

    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pullFromQueue_args.class, metaDataMap);
    }

    public pullFromQueue_args() {
    }

    public pullFromQueue_args(
      int pid)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pullFromQueue_args(pullFromQueue_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
    }

    public pullFromQueue_args deepCopy() {
      return new pullFromQueue_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public pullFromQueue_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pullFromQueue_args)
        return this.equals((pullFromQueue_args)that);
      return false;
    }

    public boolean equals(pullFromQueue_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pullFromQueue_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pullFromQueue_args typedOther = (pullFromQueue_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pullFromQueue_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class pullFromQueue_result implements TBase<pullFromQueue_result, pullFromQueue_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pullFromQueue_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(pullFromQueue_result.class, metaDataMap);
    }

    public pullFromQueue_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pullFromQueue_result(pullFromQueue_result other) {
    }

    public pullFromQueue_result deepCopy() {
      return new pullFromQueue_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pullFromQueue_result)
        return this.equals((pullFromQueue_result)that);
      return false;
    }

    public boolean equals(pullFromQueue_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(pullFromQueue_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pullFromQueue_result typedOther = (pullFromQueue_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("pullFromQueue_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restartPackage_args implements TBase<restartPackage_args, restartPackage_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restartPackage_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);

    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restartPackage_args.class, metaDataMap);
    }

    public restartPackage_args() {
    }

    public restartPackage_args(
      int pid)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restartPackage_args(restartPackage_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
    }

    public restartPackage_args deepCopy() {
      return new restartPackage_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public restartPackage_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restartPackage_args)
        return this.equals((restartPackage_args)that);
      return false;
    }

    public boolean equals(restartPackage_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restartPackage_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restartPackage_args typedOther = (restartPackage_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restartPackage_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restartPackage_result implements TBase<restartPackage_result, restartPackage_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restartPackage_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restartPackage_result.class, metaDataMap);
    }

    public restartPackage_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restartPackage_result(restartPackage_result other) {
    }

    public restartPackage_result deepCopy() {
      return new restartPackage_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restartPackage_result)
        return this.equals((restartPackage_result)that);
      return false;
    }

    public boolean equals(restartPackage_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restartPackage_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restartPackage_result typedOther = (restartPackage_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restartPackage_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restartFile_args implements TBase<restartFile_args, restartFile_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restartFile_args");

    private static final TField FID_FIELD_DESC = new TField("fid", TType.I32, (short)1);

    public int fid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FID((short)1, "fid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FID
            return FID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __FID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FID, new FieldMetaData("fid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "FileID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restartFile_args.class, metaDataMap);
    }

    public restartFile_args() {
    }

    public restartFile_args(
      int fid)
    {
      this();
      this.fid = fid;
      setFidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restartFile_args(restartFile_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.fid = other.fid;
    }

    public restartFile_args deepCopy() {
      return new restartFile_args(this);
    }

    
    public void clear() {
      setFidIsSet(false);
      this.fid = 0;
    }

    public int getFid() {
      return this.fid;
    }

    public restartFile_args setFid(int fid) {
      this.fid = fid;
      setFidIsSet(true);
      return this;
    }

    public void unsetFid() {
      __isset_bit_vector.clear(__FID_ISSET_ID);
    }

    /** Returns true if field fid is set (has been asigned a value) and false otherwise */
    public boolean isSetFid() {
      return __isset_bit_vector.get(__FID_ISSET_ID);
    }

    public void setFidIsSet(boolean value) {
      __isset_bit_vector.set(__FID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FID:
        if (value == null) {
          unsetFid();
        } else {
          setFid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FID:
        return new Integer(getFid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FID:
        return isSetFid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restartFile_args)
        return this.equals((restartFile_args)that);
      return false;
    }

    public boolean equals(restartFile_args that) {
      if (that == null)
        return false;

      boolean this_present_fid = true;
      boolean that_present_fid = true;
      if (this_present_fid || that_present_fid) {
        if (!(this_present_fid && that_present_fid))
          return false;
        if (this.fid != that.fid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restartFile_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restartFile_args typedOther = (restartFile_args)other;

      lastComparison = Boolean.valueOf(isSetFid()).compareTo(typedOther.isSetFid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFid()) {
        lastComparison = TBaseHelper.compareTo(this.fid, typedOther.fid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FID
            if (field.type == TType.I32) {
              this.fid = iprot.readI32();
              setFidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FID_FIELD_DESC);
      oprot.writeI32(this.fid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restartFile_args(");
      boolean first = true;

      sb.append("fid:");
      sb.append(this.fid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restartFile_result implements TBase<restartFile_result, restartFile_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restartFile_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restartFile_result.class, metaDataMap);
    }

    public restartFile_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restartFile_result(restartFile_result other) {
    }

    public restartFile_result deepCopy() {
      return new restartFile_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restartFile_result)
        return this.equals((restartFile_result)that);
      return false;
    }

    public boolean equals(restartFile_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restartFile_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restartFile_result typedOther = (restartFile_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restartFile_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class recheckPackage_args implements TBase<recheckPackage_args, recheckPackage_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("recheckPackage_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);

    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(recheckPackage_args.class, metaDataMap);
    }

    public recheckPackage_args() {
    }

    public recheckPackage_args(
      int pid)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public recheckPackage_args(recheckPackage_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
    }

    public recheckPackage_args deepCopy() {
      return new recheckPackage_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public recheckPackage_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof recheckPackage_args)
        return this.equals((recheckPackage_args)that);
      return false;
    }

    public boolean equals(recheckPackage_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(recheckPackage_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      recheckPackage_args typedOther = (recheckPackage_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("recheckPackage_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class recheckPackage_result implements TBase<recheckPackage_result, recheckPackage_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("recheckPackage_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(recheckPackage_result.class, metaDataMap);
    }

    public recheckPackage_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public recheckPackage_result(recheckPackage_result other) {
    }

    public recheckPackage_result deepCopy() {
      return new recheckPackage_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof recheckPackage_result)
        return this.equals((recheckPackage_result)that);
      return false;
    }

    public boolean equals(recheckPackage_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(recheckPackage_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      recheckPackage_result typedOther = (recheckPackage_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("recheckPackage_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class stopAllDownloads_args implements TBase<stopAllDownloads_args, stopAllDownloads_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stopAllDownloads_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(stopAllDownloads_args.class, metaDataMap);
    }

    public stopAllDownloads_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stopAllDownloads_args(stopAllDownloads_args other) {
    }

    public stopAllDownloads_args deepCopy() {
      return new stopAllDownloads_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stopAllDownloads_args)
        return this.equals((stopAllDownloads_args)that);
      return false;
    }

    public boolean equals(stopAllDownloads_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(stopAllDownloads_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      stopAllDownloads_args typedOther = (stopAllDownloads_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("stopAllDownloads_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class stopAllDownloads_result implements TBase<stopAllDownloads_result, stopAllDownloads_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stopAllDownloads_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(stopAllDownloads_result.class, metaDataMap);
    }

    public stopAllDownloads_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stopAllDownloads_result(stopAllDownloads_result other) {
    }

    public stopAllDownloads_result deepCopy() {
      return new stopAllDownloads_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stopAllDownloads_result)
        return this.equals((stopAllDownloads_result)that);
      return false;
    }

    public boolean equals(stopAllDownloads_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(stopAllDownloads_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      stopAllDownloads_result typedOther = (stopAllDownloads_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("stopAllDownloads_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class stopDownloads_args implements TBase<stopDownloads_args, stopDownloads_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stopDownloads_args");

    private static final TField FIDS_FIELD_DESC = new TField("fids", TType.LIST, (short)1);

    public List<Integer> fids;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FIDS((short)1, "fids");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FIDS
            return FIDS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FIDS, new FieldMetaData("fids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I32              , "FileID"))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(stopDownloads_args.class, metaDataMap);
    }

    public stopDownloads_args() {
    }

    public stopDownloads_args(
      List<Integer> fids)
    {
      this();
      this.fids = fids;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stopDownloads_args(stopDownloads_args other) {
      if (other.isSetFids()) {
        List<Integer> __this__fids = new ArrayList<Integer>();
        for (Integer other_element : other.fids) {
          __this__fids.add(other_element);
        }
        this.fids = __this__fids;
      }
    }

    public stopDownloads_args deepCopy() {
      return new stopDownloads_args(this);
    }

    
    public void clear() {
      this.fids = null;
    }

    public int getFidsSize() {
      return (this.fids == null) ? 0 : this.fids.size();
    }

    public java.util.Iterator<Integer> getFidsIterator() {
      return (this.fids == null) ? null : this.fids.iterator();
    }

    public void addToFids(int elem) {
      if (this.fids == null) {
        this.fids = new ArrayList<Integer>();
      }
      this.fids.add(elem);
    }

    public List<Integer> getFids() {
      return this.fids;
    }

    public stopDownloads_args setFids(List<Integer> fids) {
      this.fids = fids;
      return this;
    }

    public void unsetFids() {
      this.fids = null;
    }

    /** Returns true if field fids is set (has been asigned a value) and false otherwise */
    public boolean isSetFids() {
      return this.fids != null;
    }

    public void setFidsIsSet(boolean value) {
      if (!value) {
        this.fids = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FIDS:
        if (value == null) {
          unsetFids();
        } else {
          setFids((List<Integer>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FIDS:
        return getFids();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FIDS:
        return isSetFids();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stopDownloads_args)
        return this.equals((stopDownloads_args)that);
      return false;
    }

    public boolean equals(stopDownloads_args that) {
      if (that == null)
        return false;

      boolean this_present_fids = true && this.isSetFids();
      boolean that_present_fids = true && that.isSetFids();
      if (this_present_fids || that_present_fids) {
        if (!(this_present_fids && that_present_fids))
          return false;
        if (!this.fids.equals(that.fids))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(stopDownloads_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      stopDownloads_args typedOther = (stopDownloads_args)other;

      lastComparison = Boolean.valueOf(isSetFids()).compareTo(typedOther.isSetFids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFids()) {
        lastComparison = TBaseHelper.compareTo(this.fids, typedOther.fids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FIDS
            if (field.type == TType.LIST) {
              {
                TList _list142 = iprot.readListBegin();
                this.fids = new ArrayList<Integer>(_list142.size);
                for (int _i143 = 0; _i143 < _list142.size; ++_i143)
                {
                  int _elem144;
                  _elem144 = iprot.readI32();
                  this.fids.add(_elem144);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.fids != null) {
        oprot.writeFieldBegin(FIDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.fids.size()));
          for (int _iter145 : this.fids)
          {
            oprot.writeI32(_iter145);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("stopDownloads_args(");
      boolean first = true;

      sb.append("fids:");
      if (this.fids == null) {
        sb.append("null");
      } else {
        sb.append(this.fids);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class stopDownloads_result implements TBase<stopDownloads_result, stopDownloads_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stopDownloads_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(stopDownloads_result.class, metaDataMap);
    }

    public stopDownloads_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stopDownloads_result(stopDownloads_result other) {
    }

    public stopDownloads_result deepCopy() {
      return new stopDownloads_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stopDownloads_result)
        return this.equals((stopDownloads_result)that);
      return false;
    }

    public boolean equals(stopDownloads_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(stopDownloads_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      stopDownloads_result typedOther = (stopDownloads_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("stopDownloads_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setPackageName_args implements TBase<setPackageName_args, setPackageName_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setPackageName_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);

    public int pid;
    public String name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid"),
      NAME((short)2, "name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          case 2: // NAME
            return NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      tmpMap.put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setPackageName_args.class, metaDataMap);
    }

    public setPackageName_args() {
    }

    public setPackageName_args(
      int pid,
      String name)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
      this.name = name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setPackageName_args(setPackageName_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
      if (other.isSetName()) {
        this.name = other.name;
      }
    }

    public setPackageName_args deepCopy() {
      return new setPackageName_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
      this.name = null;
    }

    public int getPid() {
      return this.pid;
    }

    public setPackageName_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public String getName() {
      return this.name;
    }

    public setPackageName_args setName(String name) {
      this.name = name;
      return this;
    }

    public void unsetName() {
      this.name = null;
    }

    /** Returns true if field name is set (has been asigned a value) and false otherwise */
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      case NAME:
        return getName();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      case NAME:
        return isSetName();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setPackageName_args)
        return this.equals((setPackageName_args)that);
      return false;
    }

    public boolean equals(setPackageName_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setPackageName_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setPackageName_args typedOther = (setPackageName_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetName()).compareTo(typedOther.isSetName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetName()) {
        lastComparison = TBaseHelper.compareTo(this.name, typedOther.name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NAME
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setPackageName_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      if (!first) sb.append(", ");
      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setPackageName_result implements TBase<setPackageName_result, setPackageName_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setPackageName_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setPackageName_result.class, metaDataMap);
    }

    public setPackageName_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setPackageName_result(setPackageName_result other) {
    }

    public setPackageName_result deepCopy() {
      return new setPackageName_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setPackageName_result)
        return this.equals((setPackageName_result)that);
      return false;
    }

    public boolean equals(setPackageName_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setPackageName_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setPackageName_result typedOther = (setPackageName_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setPackageName_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class movePackage_args implements TBase<movePackage_args, movePackage_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("movePackage_args");

    private static final TField DESTINATION_FIELD_DESC = new TField("destination", TType.I32, (short)1);
    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)2);

    /**
     * 
     * @see Destination
     */
    public Destination destination;
    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      /**
       * 
       * @see Destination
       */
      DESTINATION((short)1, "destination"),
      PID((short)2, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DESTINATION
            return DESTINATION;
          case 2: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DESTINATION, new FieldMetaData("destination", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, Destination.class)));
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(movePackage_args.class, metaDataMap);
    }

    public movePackage_args() {
    }

    public movePackage_args(
      Destination destination,
      int pid)
    {
      this();
      this.destination = destination;
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public movePackage_args(movePackage_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetDestination()) {
        this.destination = other.destination;
      }
      this.pid = other.pid;
    }

    public movePackage_args deepCopy() {
      return new movePackage_args(this);
    }

    
    public void clear() {
      this.destination = null;
      setPidIsSet(false);
      this.pid = 0;
    }

    /**
     * 
     * @see Destination
     */
    public Destination getDestination() {
      return this.destination;
    }

    /**
     * 
     * @see Destination
     */
    public movePackage_args setDestination(Destination destination) {
      this.destination = destination;
      return this;
    }

    public void unsetDestination() {
      this.destination = null;
    }

    /** Returns true if field destination is set (has been asigned a value) and false otherwise */
    public boolean isSetDestination() {
      return this.destination != null;
    }

    public void setDestinationIsSet(boolean value) {
      if (!value) {
        this.destination = null;
      }
    }

    public int getPid() {
      return this.pid;
    }

    public movePackage_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DESTINATION:
        if (value == null) {
          unsetDestination();
        } else {
          setDestination((Destination)value);
        }
        break;

      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DESTINATION:
        return getDestination();

      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DESTINATION:
        return isSetDestination();
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof movePackage_args)
        return this.equals((movePackage_args)that);
      return false;
    }

    public boolean equals(movePackage_args that) {
      if (that == null)
        return false;

      boolean this_present_destination = true && this.isSetDestination();
      boolean that_present_destination = true && that.isSetDestination();
      if (this_present_destination || that_present_destination) {
        if (!(this_present_destination && that_present_destination))
          return false;
        if (!this.destination.equals(that.destination))
          return false;
      }

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(movePackage_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      movePackage_args typedOther = (movePackage_args)other;

      lastComparison = Boolean.valueOf(isSetDestination()).compareTo(typedOther.isSetDestination());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDestination()) {
        lastComparison = TBaseHelper.compareTo(this.destination, typedOther.destination);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DESTINATION
            if (field.type == TType.I32) {
              this.destination = Destination.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.destination != null) {
        oprot.writeFieldBegin(DESTINATION_FIELD_DESC);
        oprot.writeI32(this.destination.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("movePackage_args(");
      boolean first = true;

      sb.append("destination:");
      if (this.destination == null) {
        sb.append("null");
      } else {
        sb.append(this.destination);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class movePackage_result implements TBase<movePackage_result, movePackage_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("movePackage_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(movePackage_result.class, metaDataMap);
    }

    public movePackage_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public movePackage_result(movePackage_result other) {
    }

    public movePackage_result deepCopy() {
      return new movePackage_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof movePackage_result)
        return this.equals((movePackage_result)that);
      return false;
    }

    public boolean equals(movePackage_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(movePackage_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      movePackage_result typedOther = (movePackage_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("movePackage_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class moveFiles_args implements TBase<moveFiles_args, moveFiles_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("moveFiles_args");

    private static final TField FIDS_FIELD_DESC = new TField("fids", TType.LIST, (short)1);
    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)2);

    public List<Integer> fids;
    public int pid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FIDS((short)1, "fids"),
      PID((short)2, "pid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FIDS
            return FIDS;
          case 2: // PID
            return PID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FIDS, new FieldMetaData("fids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I32              , "FileID"))));
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(moveFiles_args.class, metaDataMap);
    }

    public moveFiles_args() {
    }

    public moveFiles_args(
      List<Integer> fids,
      int pid)
    {
      this();
      this.fids = fids;
      this.pid = pid;
      setPidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public moveFiles_args(moveFiles_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetFids()) {
        List<Integer> __this__fids = new ArrayList<Integer>();
        for (Integer other_element : other.fids) {
          __this__fids.add(other_element);
        }
        this.fids = __this__fids;
      }
      this.pid = other.pid;
    }

    public moveFiles_args deepCopy() {
      return new moveFiles_args(this);
    }

    
    public void clear() {
      this.fids = null;
      setPidIsSet(false);
      this.pid = 0;
    }

    public int getFidsSize() {
      return (this.fids == null) ? 0 : this.fids.size();
    }

    public java.util.Iterator<Integer> getFidsIterator() {
      return (this.fids == null) ? null : this.fids.iterator();
    }

    public void addToFids(int elem) {
      if (this.fids == null) {
        this.fids = new ArrayList<Integer>();
      }
      this.fids.add(elem);
    }

    public List<Integer> getFids() {
      return this.fids;
    }

    public moveFiles_args setFids(List<Integer> fids) {
      this.fids = fids;
      return this;
    }

    public void unsetFids() {
      this.fids = null;
    }

    /** Returns true if field fids is set (has been asigned a value) and false otherwise */
    public boolean isSetFids() {
      return this.fids != null;
    }

    public void setFidsIsSet(boolean value) {
      if (!value) {
        this.fids = null;
      }
    }

    public int getPid() {
      return this.pid;
    }

    public moveFiles_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FIDS:
        if (value == null) {
          unsetFids();
        } else {
          setFids((List<Integer>)value);
        }
        break;

      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FIDS:
        return getFids();

      case PID:
        return new Integer(getPid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FIDS:
        return isSetFids();
      case PID:
        return isSetPid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof moveFiles_args)
        return this.equals((moveFiles_args)that);
      return false;
    }

    public boolean equals(moveFiles_args that) {
      if (that == null)
        return false;

      boolean this_present_fids = true && this.isSetFids();
      boolean that_present_fids = true && that.isSetFids();
      if (this_present_fids || that_present_fids) {
        if (!(this_present_fids && that_present_fids))
          return false;
        if (!this.fids.equals(that.fids))
          return false;
      }

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(moveFiles_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      moveFiles_args typedOther = (moveFiles_args)other;

      lastComparison = Boolean.valueOf(isSetFids()).compareTo(typedOther.isSetFids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFids()) {
        lastComparison = TBaseHelper.compareTo(this.fids, typedOther.fids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FIDS
            if (field.type == TType.LIST) {
              {
                TList _list146 = iprot.readListBegin();
                this.fids = new ArrayList<Integer>(_list146.size);
                for (int _i147 = 0; _i147 < _list146.size; ++_i147)
                {
                  int _elem148;
                  _elem148 = iprot.readI32();
                  this.fids.add(_elem148);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.fids != null) {
        oprot.writeFieldBegin(FIDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.fids.size()));
          for (int _iter149 : this.fids)
          {
            oprot.writeI32(_iter149);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("moveFiles_args(");
      boolean first = true;

      sb.append("fids:");
      if (this.fids == null) {
        sb.append("null");
      } else {
        sb.append(this.fids);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class moveFiles_result implements TBase<moveFiles_result, moveFiles_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("moveFiles_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(moveFiles_result.class, metaDataMap);
    }

    public moveFiles_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public moveFiles_result(moveFiles_result other) {
    }

    public moveFiles_result deepCopy() {
      return new moveFiles_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof moveFiles_result)
        return this.equals((moveFiles_result)that);
      return false;
    }

    public boolean equals(moveFiles_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(moveFiles_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      moveFiles_result typedOther = (moveFiles_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("moveFiles_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class orderPackage_args implements TBase<orderPackage_args, orderPackage_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("orderPackage_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);
    private static final TField POSITION_FIELD_DESC = new TField("position", TType.I16, (short)2);

    public int pid;
    public short position;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid"),
      POSITION((short)2, "position");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          case 2: // POSITION
            return POSITION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private static final int __POSITION_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      tmpMap.put(_Fields.POSITION, new FieldMetaData("position", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(orderPackage_args.class, metaDataMap);
    }

    public orderPackage_args() {
    }

    public orderPackage_args(
      int pid,
      short position)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
      this.position = position;
      setPositionIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public orderPackage_args(orderPackage_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
      this.position = other.position;
    }

    public orderPackage_args deepCopy() {
      return new orderPackage_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
      setPositionIsSet(false);
      this.position = 0;
    }

    public int getPid() {
      return this.pid;
    }

    public orderPackage_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public short getPosition() {
      return this.position;
    }

    public orderPackage_args setPosition(short position) {
      this.position = position;
      setPositionIsSet(true);
      return this;
    }

    public void unsetPosition() {
      __isset_bit_vector.clear(__POSITION_ISSET_ID);
    }

    /** Returns true if field position is set (has been asigned a value) and false otherwise */
    public boolean isSetPosition() {
      return __isset_bit_vector.get(__POSITION_ISSET_ID);
    }

    public void setPositionIsSet(boolean value) {
      __isset_bit_vector.set(__POSITION_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      case POSITION:
        if (value == null) {
          unsetPosition();
        } else {
          setPosition((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      case POSITION:
        return new Short(getPosition());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      case POSITION:
        return isSetPosition();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof orderPackage_args)
        return this.equals((orderPackage_args)that);
      return false;
    }

    public boolean equals(orderPackage_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      boolean this_present_position = true;
      boolean that_present_position = true;
      if (this_present_position || that_present_position) {
        if (!(this_present_position && that_present_position))
          return false;
        if (this.position != that.position)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(orderPackage_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      orderPackage_args typedOther = (orderPackage_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPosition()).compareTo(typedOther.isSetPosition());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPosition()) {
        lastComparison = TBaseHelper.compareTo(this.position, typedOther.position);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // POSITION
            if (field.type == TType.I16) {
              this.position = iprot.readI16();
              setPositionIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(POSITION_FIELD_DESC);
      oprot.writeI16(this.position);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("orderPackage_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      if (!first) sb.append(", ");
      sb.append("position:");
      sb.append(this.position);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class orderPackage_result implements TBase<orderPackage_result, orderPackage_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("orderPackage_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(orderPackage_result.class, metaDataMap);
    }

    public orderPackage_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public orderPackage_result(orderPackage_result other) {
    }

    public orderPackage_result deepCopy() {
      return new orderPackage_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof orderPackage_result)
        return this.equals((orderPackage_result)that);
      return false;
    }

    public boolean equals(orderPackage_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(orderPackage_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      orderPackage_result typedOther = (orderPackage_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("orderPackage_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class orderFile_args implements TBase<orderFile_args, orderFile_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("orderFile_args");

    private static final TField FID_FIELD_DESC = new TField("fid", TType.I32, (short)1);
    private static final TField POSITION_FIELD_DESC = new TField("position", TType.I16, (short)2);

    public int fid;
    public short position;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      FID((short)1, "fid"),
      POSITION((short)2, "position");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // FID
            return FID;
          case 2: // POSITION
            return POSITION;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __FID_ISSET_ID = 0;
    private static final int __POSITION_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.FID, new FieldMetaData("fid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "FileID")));
      tmpMap.put(_Fields.POSITION, new FieldMetaData("position", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(orderFile_args.class, metaDataMap);
    }

    public orderFile_args() {
    }

    public orderFile_args(
      int fid,
      short position)
    {
      this();
      this.fid = fid;
      setFidIsSet(true);
      this.position = position;
      setPositionIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public orderFile_args(orderFile_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.fid = other.fid;
      this.position = other.position;
    }

    public orderFile_args deepCopy() {
      return new orderFile_args(this);
    }

    
    public void clear() {
      setFidIsSet(false);
      this.fid = 0;
      setPositionIsSet(false);
      this.position = 0;
    }

    public int getFid() {
      return this.fid;
    }

    public orderFile_args setFid(int fid) {
      this.fid = fid;
      setFidIsSet(true);
      return this;
    }

    public void unsetFid() {
      __isset_bit_vector.clear(__FID_ISSET_ID);
    }

    /** Returns true if field fid is set (has been asigned a value) and false otherwise */
    public boolean isSetFid() {
      return __isset_bit_vector.get(__FID_ISSET_ID);
    }

    public void setFidIsSet(boolean value) {
      __isset_bit_vector.set(__FID_ISSET_ID, value);
    }

    public short getPosition() {
      return this.position;
    }

    public orderFile_args setPosition(short position) {
      this.position = position;
      setPositionIsSet(true);
      return this;
    }

    public void unsetPosition() {
      __isset_bit_vector.clear(__POSITION_ISSET_ID);
    }

    /** Returns true if field position is set (has been asigned a value) and false otherwise */
    public boolean isSetPosition() {
      return __isset_bit_vector.get(__POSITION_ISSET_ID);
    }

    public void setPositionIsSet(boolean value) {
      __isset_bit_vector.set(__POSITION_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case FID:
        if (value == null) {
          unsetFid();
        } else {
          setFid((Integer)value);
        }
        break;

      case POSITION:
        if (value == null) {
          unsetPosition();
        } else {
          setPosition((Short)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case FID:
        return new Integer(getFid());

      case POSITION:
        return new Short(getPosition());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case FID:
        return isSetFid();
      case POSITION:
        return isSetPosition();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof orderFile_args)
        return this.equals((orderFile_args)that);
      return false;
    }

    public boolean equals(orderFile_args that) {
      if (that == null)
        return false;

      boolean this_present_fid = true;
      boolean that_present_fid = true;
      if (this_present_fid || that_present_fid) {
        if (!(this_present_fid && that_present_fid))
          return false;
        if (this.fid != that.fid)
          return false;
      }

      boolean this_present_position = true;
      boolean that_present_position = true;
      if (this_present_position || that_present_position) {
        if (!(this_present_position && that_present_position))
          return false;
        if (this.position != that.position)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(orderFile_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      orderFile_args typedOther = (orderFile_args)other;

      lastComparison = Boolean.valueOf(isSetFid()).compareTo(typedOther.isSetFid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFid()) {
        lastComparison = TBaseHelper.compareTo(this.fid, typedOther.fid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPosition()).compareTo(typedOther.isSetPosition());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPosition()) {
        lastComparison = TBaseHelper.compareTo(this.position, typedOther.position);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // FID
            if (field.type == TType.I32) {
              this.fid = iprot.readI32();
              setFidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // POSITION
            if (field.type == TType.I16) {
              this.position = iprot.readI16();
              setPositionIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FID_FIELD_DESC);
      oprot.writeI32(this.fid);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(POSITION_FIELD_DESC);
      oprot.writeI16(this.position);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("orderFile_args(");
      boolean first = true;

      sb.append("fid:");
      sb.append(this.fid);
      first = false;
      if (!first) sb.append(", ");
      sb.append("position:");
      sb.append(this.position);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class orderFile_result implements TBase<orderFile_result, orderFile_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("orderFile_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(orderFile_result.class, metaDataMap);
    }

    public orderFile_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public orderFile_result(orderFile_result other) {
    }

    public orderFile_result deepCopy() {
      return new orderFile_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof orderFile_result)
        return this.equals((orderFile_result)that);
      return false;
    }

    public boolean equals(orderFile_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(orderFile_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      orderFile_result typedOther = (orderFile_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("orderFile_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setPackageData_args implements TBase<setPackageData_args, setPackageData_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setPackageData_args");

    private static final TField PID_FIELD_DESC = new TField("pid", TType.I32, (short)1);
    private static final TField DATA_FIELD_DESC = new TField("data", TType.MAP, (short)2);

    public int pid;
    public Map<String,String> data;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PID((short)1, "pid"),
      DATA((short)2, "data");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PID
            return PID;
          case 2: // DATA
            return DATA;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __PID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PID, new FieldMetaData("pid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "PackageID")));
      tmpMap.put(_Fields.DATA, new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setPackageData_args.class, metaDataMap);
    }

    public setPackageData_args() {
    }

    public setPackageData_args(
      int pid,
      Map<String,String> data)
    {
      this();
      this.pid = pid;
      setPidIsSet(true);
      this.data = data;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setPackageData_args(setPackageData_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.pid = other.pid;
      if (other.isSetData()) {
        Map<String,String> __this__data = new HashMap<String,String>();
        for (Map.Entry<String, String> other_element : other.data.entrySet()) {

          String other_element_key = other_element.getKey();
          String other_element_value = other_element.getValue();

          String __this__data_copy_key = other_element_key;

          String __this__data_copy_value = other_element_value;

          __this__data.put(__this__data_copy_key, __this__data_copy_value);
        }
        this.data = __this__data;
      }
    }

    public setPackageData_args deepCopy() {
      return new setPackageData_args(this);
    }

    
    public void clear() {
      setPidIsSet(false);
      this.pid = 0;
      this.data = null;
    }

    public int getPid() {
      return this.pid;
    }

    public setPackageData_args setPid(int pid) {
      this.pid = pid;
      setPidIsSet(true);
      return this;
    }

    public void unsetPid() {
      __isset_bit_vector.clear(__PID_ISSET_ID);
    }

    /** Returns true if field pid is set (has been asigned a value) and false otherwise */
    public boolean isSetPid() {
      return __isset_bit_vector.get(__PID_ISSET_ID);
    }

    public void setPidIsSet(boolean value) {
      __isset_bit_vector.set(__PID_ISSET_ID, value);
    }

    public int getDataSize() {
      return (this.data == null) ? 0 : this.data.size();
    }

    public void putToData(String key, String val) {
      if (this.data == null) {
        this.data = new HashMap<String,String>();
      }
      this.data.put(key, val);
    }

    public Map<String,String> getData() {
      return this.data;
    }

    public setPackageData_args setData(Map<String,String> data) {
      this.data = data;
      return this;
    }

    public void unsetData() {
      this.data = null;
    }

    /** Returns true if field data is set (has been asigned a value) and false otherwise */
    public boolean isSetData() {
      return this.data != null;
    }

    public void setDataIsSet(boolean value) {
      if (!value) {
        this.data = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PID:
        if (value == null) {
          unsetPid();
        } else {
          setPid((Integer)value);
        }
        break;

      case DATA:
        if (value == null) {
          unsetData();
        } else {
          setData((Map<String,String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PID:
        return new Integer(getPid());

      case DATA:
        return getData();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PID:
        return isSetPid();
      case DATA:
        return isSetData();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setPackageData_args)
        return this.equals((setPackageData_args)that);
      return false;
    }

    public boolean equals(setPackageData_args that) {
      if (that == null)
        return false;

      boolean this_present_pid = true;
      boolean that_present_pid = true;
      if (this_present_pid || that_present_pid) {
        if (!(this_present_pid && that_present_pid))
          return false;
        if (this.pid != that.pid)
          return false;
      }

      boolean this_present_data = true && this.isSetData();
      boolean that_present_data = true && that.isSetData();
      if (this_present_data || that_present_data) {
        if (!(this_present_data && that_present_data))
          return false;
        if (!this.data.equals(that.data))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setPackageData_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setPackageData_args typedOther = (setPackageData_args)other;

      lastComparison = Boolean.valueOf(isSetPid()).compareTo(typedOther.isSetPid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPid()) {
        lastComparison = TBaseHelper.compareTo(this.pid, typedOther.pid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetData()).compareTo(typedOther.isSetData());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetData()) {
        lastComparison = TBaseHelper.compareTo(this.data, typedOther.data);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PID
            if (field.type == TType.I32) {
              this.pid = iprot.readI32();
              setPidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DATA
            if (field.type == TType.MAP) {
              {
                TMap _map150 = iprot.readMapBegin();
                this.data = new HashMap<String,String>(2*_map150.size);
                for (int _i151 = 0; _i151 < _map150.size; ++_i151)
                {
                  String _key152;
                  String _val153;
                  _key152 = iprot.readString();
                  _val153 = iprot.readString();
                  this.data.put(_key152, _val153);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(PID_FIELD_DESC);
      oprot.writeI32(this.pid);
      oprot.writeFieldEnd();
      if (this.data != null) {
        oprot.writeFieldBegin(DATA_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.data.size()));
          for (Map.Entry<String, String> _iter154 : this.data.entrySet())
          {
            oprot.writeString(_iter154.getKey());
            oprot.writeString(_iter154.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setPackageData_args(");
      boolean first = true;

      sb.append("pid:");
      sb.append(this.pid);
      first = false;
      if (!first) sb.append(", ");
      sb.append("data:");
      if (this.data == null) {
        sb.append("null");
      } else {
        sb.append(this.data);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setPackageData_result implements TBase<setPackageData_result, setPackageData_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setPackageData_result");

    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public PackageDoesNotExists e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      E((short)1, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setPackageData_result.class, metaDataMap);
    }

    public setPackageData_result() {
    }

    public setPackageData_result(
      PackageDoesNotExists e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setPackageData_result(setPackageData_result other) {
      if (other.isSetE()) {
        this.e = new PackageDoesNotExists(other.e);
      }
    }

    public setPackageData_result deepCopy() {
      return new setPackageData_result(this);
    }

    
    public void clear() {
      this.e = null;
    }

    public PackageDoesNotExists getE() {
      return this.e;
    }

    public setPackageData_result setE(PackageDoesNotExists e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((PackageDoesNotExists)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setPackageData_result)
        return this.equals((setPackageData_result)that);
      return false;
    }

    public boolean equals(setPackageData_result that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setPackageData_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setPackageData_result typedOther = (setPackageData_result)other;

      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // E
            if (field.type == TType.STRUCT) {
              this.e = new PackageDoesNotExists();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setPackageData_result(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteFinished_args implements TBase<deleteFinished_args, deleteFinished_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteFinished_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteFinished_args.class, metaDataMap);
    }

    public deleteFinished_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteFinished_args(deleteFinished_args other) {
    }

    public deleteFinished_args deepCopy() {
      return new deleteFinished_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteFinished_args)
        return this.equals((deleteFinished_args)that);
      return false;
    }

    public boolean equals(deleteFinished_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteFinished_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteFinished_args typedOther = (deleteFinished_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteFinished_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteFinished_result implements TBase<deleteFinished_result, deleteFinished_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteFinished_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteFinished_result.class, metaDataMap);
    }

    public deleteFinished_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteFinished_result(deleteFinished_result other) {
    }

    public deleteFinished_result deepCopy() {
      return new deleteFinished_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteFinished_result)
        return this.equals((deleteFinished_result)that);
      return false;
    }

    public boolean equals(deleteFinished_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteFinished_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteFinished_result typedOther = (deleteFinished_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteFinished_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restartFailed_args implements TBase<restartFailed_args, restartFailed_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restartFailed_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restartFailed_args.class, metaDataMap);
    }

    public restartFailed_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restartFailed_args(restartFailed_args other) {
    }

    public restartFailed_args deepCopy() {
      return new restartFailed_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restartFailed_args)
        return this.equals((restartFailed_args)that);
      return false;
    }

    public boolean equals(restartFailed_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restartFailed_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restartFailed_args typedOther = (restartFailed_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restartFailed_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class restartFailed_result implements TBase<restartFailed_result, restartFailed_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("restartFailed_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(restartFailed_result.class, metaDataMap);
    }

    public restartFailed_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public restartFailed_result(restartFailed_result other) {
    }

    public restartFailed_result deepCopy() {
      return new restartFailed_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof restartFailed_result)
        return this.equals((restartFailed_result)that);
      return false;
    }

    public boolean equals(restartFailed_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(restartFailed_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      restartFailed_result typedOther = (restartFailed_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("restartFailed_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isCaptchaWaiting_args implements TBase<isCaptchaWaiting_args, isCaptchaWaiting_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isCaptchaWaiting_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isCaptchaWaiting_args.class, metaDataMap);
    }

    public isCaptchaWaiting_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isCaptchaWaiting_args(isCaptchaWaiting_args other) {
    }

    public isCaptchaWaiting_args deepCopy() {
      return new isCaptchaWaiting_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isCaptchaWaiting_args)
        return this.equals((isCaptchaWaiting_args)that);
      return false;
    }

    public boolean equals(isCaptchaWaiting_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(isCaptchaWaiting_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isCaptchaWaiting_args typedOther = (isCaptchaWaiting_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("isCaptchaWaiting_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class isCaptchaWaiting_result implements TBase<isCaptchaWaiting_result, isCaptchaWaiting_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isCaptchaWaiting_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(isCaptchaWaiting_result.class, metaDataMap);
    }

    public isCaptchaWaiting_result() {
    }

    public isCaptchaWaiting_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isCaptchaWaiting_result(isCaptchaWaiting_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public isCaptchaWaiting_result deepCopy() {
      return new isCaptchaWaiting_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public isCaptchaWaiting_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isCaptchaWaiting_result)
        return this.equals((isCaptchaWaiting_result)that);
      return false;
    }

    public boolean equals(isCaptchaWaiting_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(isCaptchaWaiting_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      isCaptchaWaiting_result typedOther = (isCaptchaWaiting_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("isCaptchaWaiting_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCaptchaTask_args implements TBase<getCaptchaTask_args, getCaptchaTask_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCaptchaTask_args");

    private static final TField EXCLUSIVE_FIELD_DESC = new TField("exclusive", TType.BOOL, (short)1);

    public boolean exclusive;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      EXCLUSIVE((short)1, "exclusive");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // EXCLUSIVE
            return EXCLUSIVE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __EXCLUSIVE_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.EXCLUSIVE, new FieldMetaData("exclusive", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCaptchaTask_args.class, metaDataMap);
    }

    public getCaptchaTask_args() {
    }

    public getCaptchaTask_args(
      boolean exclusive)
    {
      this();
      this.exclusive = exclusive;
      setExclusiveIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCaptchaTask_args(getCaptchaTask_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.exclusive = other.exclusive;
    }

    public getCaptchaTask_args deepCopy() {
      return new getCaptchaTask_args(this);
    }

    
    public void clear() {
      setExclusiveIsSet(false);
      this.exclusive = false;
    }

    public boolean isExclusive() {
      return this.exclusive;
    }

    public getCaptchaTask_args setExclusive(boolean exclusive) {
      this.exclusive = exclusive;
      setExclusiveIsSet(true);
      return this;
    }

    public void unsetExclusive() {
      __isset_bit_vector.clear(__EXCLUSIVE_ISSET_ID);
    }

    /** Returns true if field exclusive is set (has been asigned a value) and false otherwise */
    public boolean isSetExclusive() {
      return __isset_bit_vector.get(__EXCLUSIVE_ISSET_ID);
    }

    public void setExclusiveIsSet(boolean value) {
      __isset_bit_vector.set(__EXCLUSIVE_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case EXCLUSIVE:
        if (value == null) {
          unsetExclusive();
        } else {
          setExclusive((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case EXCLUSIVE:
        return new Boolean(isExclusive());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case EXCLUSIVE:
        return isSetExclusive();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCaptchaTask_args)
        return this.equals((getCaptchaTask_args)that);
      return false;
    }

    public boolean equals(getCaptchaTask_args that) {
      if (that == null)
        return false;

      boolean this_present_exclusive = true;
      boolean that_present_exclusive = true;
      if (this_present_exclusive || that_present_exclusive) {
        if (!(this_present_exclusive && that_present_exclusive))
          return false;
        if (this.exclusive != that.exclusive)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCaptchaTask_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCaptchaTask_args typedOther = (getCaptchaTask_args)other;

      lastComparison = Boolean.valueOf(isSetExclusive()).compareTo(typedOther.isSetExclusive());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetExclusive()) {
        lastComparison = TBaseHelper.compareTo(this.exclusive, typedOther.exclusive);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // EXCLUSIVE
            if (field.type == TType.BOOL) {
              this.exclusive = iprot.readBool();
              setExclusiveIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(EXCLUSIVE_FIELD_DESC);
      oprot.writeBool(this.exclusive);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCaptchaTask_args(");
      boolean first = true;

      sb.append("exclusive:");
      sb.append(this.exclusive);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCaptchaTask_result implements TBase<getCaptchaTask_result, getCaptchaTask_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCaptchaTask_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public CaptchaTask success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CaptchaTask.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCaptchaTask_result.class, metaDataMap);
    }

    public getCaptchaTask_result() {
    }

    public getCaptchaTask_result(
      CaptchaTask success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCaptchaTask_result(getCaptchaTask_result other) {
      if (other.isSetSuccess()) {
        this.success = new CaptchaTask(other.success);
      }
    }

    public getCaptchaTask_result deepCopy() {
      return new getCaptchaTask_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public CaptchaTask getSuccess() {
      return this.success;
    }

    public getCaptchaTask_result setSuccess(CaptchaTask success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((CaptchaTask)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCaptchaTask_result)
        return this.equals((getCaptchaTask_result)that);
      return false;
    }

    public boolean equals(getCaptchaTask_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCaptchaTask_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCaptchaTask_result typedOther = (getCaptchaTask_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new CaptchaTask();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCaptchaTask_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCaptchaTaskStatus_args implements TBase<getCaptchaTaskStatus_args, getCaptchaTaskStatus_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCaptchaTaskStatus_args");

    private static final TField TID_FIELD_DESC = new TField("tid", TType.I32, (short)1);

    public int tid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TID((short)1, "tid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TID
            return TID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TID, new FieldMetaData("tid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "TaskID")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCaptchaTaskStatus_args.class, metaDataMap);
    }

    public getCaptchaTaskStatus_args() {
    }

    public getCaptchaTaskStatus_args(
      int tid)
    {
      this();
      this.tid = tid;
      setTidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCaptchaTaskStatus_args(getCaptchaTaskStatus_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.tid = other.tid;
    }

    public getCaptchaTaskStatus_args deepCopy() {
      return new getCaptchaTaskStatus_args(this);
    }

    
    public void clear() {
      setTidIsSet(false);
      this.tid = 0;
    }

    public int getTid() {
      return this.tid;
    }

    public getCaptchaTaskStatus_args setTid(int tid) {
      this.tid = tid;
      setTidIsSet(true);
      return this;
    }

    public void unsetTid() {
      __isset_bit_vector.clear(__TID_ISSET_ID);
    }

    /** Returns true if field tid is set (has been asigned a value) and false otherwise */
    public boolean isSetTid() {
      return __isset_bit_vector.get(__TID_ISSET_ID);
    }

    public void setTidIsSet(boolean value) {
      __isset_bit_vector.set(__TID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TID:
        if (value == null) {
          unsetTid();
        } else {
          setTid((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TID:
        return new Integer(getTid());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TID:
        return isSetTid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCaptchaTaskStatus_args)
        return this.equals((getCaptchaTaskStatus_args)that);
      return false;
    }

    public boolean equals(getCaptchaTaskStatus_args that) {
      if (that == null)
        return false;

      boolean this_present_tid = true;
      boolean that_present_tid = true;
      if (this_present_tid || that_present_tid) {
        if (!(this_present_tid && that_present_tid))
          return false;
        if (this.tid != that.tid)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCaptchaTaskStatus_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCaptchaTaskStatus_args typedOther = (getCaptchaTaskStatus_args)other;

      lastComparison = Boolean.valueOf(isSetTid()).compareTo(typedOther.isSetTid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTid()) {
        lastComparison = TBaseHelper.compareTo(this.tid, typedOther.tid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TID
            if (field.type == TType.I32) {
              this.tid = iprot.readI32();
              setTidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(TID_FIELD_DESC);
      oprot.writeI32(this.tid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCaptchaTaskStatus_args(");
      boolean first = true;

      sb.append("tid:");
      sb.append(this.tid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getCaptchaTaskStatus_result implements TBase<getCaptchaTaskStatus_result, getCaptchaTaskStatus_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getCaptchaTaskStatus_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getCaptchaTaskStatus_result.class, metaDataMap);
    }

    public getCaptchaTaskStatus_result() {
    }

    public getCaptchaTaskStatus_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getCaptchaTaskStatus_result(getCaptchaTaskStatus_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public getCaptchaTaskStatus_result deepCopy() {
      return new getCaptchaTaskStatus_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public getCaptchaTaskStatus_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getCaptchaTaskStatus_result)
        return this.equals((getCaptchaTaskStatus_result)that);
      return false;
    }

    public boolean equals(getCaptchaTaskStatus_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getCaptchaTaskStatus_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getCaptchaTaskStatus_result typedOther = (getCaptchaTaskStatus_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getCaptchaTaskStatus_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setCaptchaResult_args implements TBase<setCaptchaResult_args, setCaptchaResult_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setCaptchaResult_args");

    private static final TField TID_FIELD_DESC = new TField("tid", TType.I32, (short)1);
    private static final TField RESULT_FIELD_DESC = new TField("result", TType.STRING, (short)2);

    public int tid;
    public String result;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TID((short)1, "tid"),
      RESULT((short)2, "result");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TID
            return TID;
          case 2: // RESULT
            return RESULT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TID, new FieldMetaData("tid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32          , "TaskID")));
      tmpMap.put(_Fields.RESULT, new FieldMetaData("result", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setCaptchaResult_args.class, metaDataMap);
    }

    public setCaptchaResult_args() {
    }

    public setCaptchaResult_args(
      int tid,
      String result)
    {
      this();
      this.tid = tid;
      setTidIsSet(true);
      this.result = result;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setCaptchaResult_args(setCaptchaResult_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.tid = other.tid;
      if (other.isSetResult()) {
        this.result = other.result;
      }
    }

    public setCaptchaResult_args deepCopy() {
      return new setCaptchaResult_args(this);
    }

    
    public void clear() {
      setTidIsSet(false);
      this.tid = 0;
      this.result = null;
    }

    public int getTid() {
      return this.tid;
    }

    public setCaptchaResult_args setTid(int tid) {
      this.tid = tid;
      setTidIsSet(true);
      return this;
    }

    public void unsetTid() {
      __isset_bit_vector.clear(__TID_ISSET_ID);
    }

    /** Returns true if field tid is set (has been asigned a value) and false otherwise */
    public boolean isSetTid() {
      return __isset_bit_vector.get(__TID_ISSET_ID);
    }

    public void setTidIsSet(boolean value) {
      __isset_bit_vector.set(__TID_ISSET_ID, value);
    }

    public String getResult() {
      return this.result;
    }

    public setCaptchaResult_args setResult(String result) {
      this.result = result;
      return this;
    }

    public void unsetResult() {
      this.result = null;
    }

    /** Returns true if field result is set (has been asigned a value) and false otherwise */
    public boolean isSetResult() {
      return this.result != null;
    }

    public void setResultIsSet(boolean value) {
      if (!value) {
        this.result = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TID:
        if (value == null) {
          unsetTid();
        } else {
          setTid((Integer)value);
        }
        break;

      case RESULT:
        if (value == null) {
          unsetResult();
        } else {
          setResult((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TID:
        return new Integer(getTid());

      case RESULT:
        return getResult();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TID:
        return isSetTid();
      case RESULT:
        return isSetResult();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setCaptchaResult_args)
        return this.equals((setCaptchaResult_args)that);
      return false;
    }

    public boolean equals(setCaptchaResult_args that) {
      if (that == null)
        return false;

      boolean this_present_tid = true;
      boolean that_present_tid = true;
      if (this_present_tid || that_present_tid) {
        if (!(this_present_tid && that_present_tid))
          return false;
        if (this.tid != that.tid)
          return false;
      }

      boolean this_present_result = true && this.isSetResult();
      boolean that_present_result = true && that.isSetResult();
      if (this_present_result || that_present_result) {
        if (!(this_present_result && that_present_result))
          return false;
        if (!this.result.equals(that.result))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setCaptchaResult_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setCaptchaResult_args typedOther = (setCaptchaResult_args)other;

      lastComparison = Boolean.valueOf(isSetTid()).compareTo(typedOther.isSetTid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTid()) {
        lastComparison = TBaseHelper.compareTo(this.tid, typedOther.tid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetResult()).compareTo(typedOther.isSetResult());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetResult()) {
        lastComparison = TBaseHelper.compareTo(this.result, typedOther.result);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TID
            if (field.type == TType.I32) {
              this.tid = iprot.readI32();
              setTidIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // RESULT
            if (field.type == TType.STRING) {
              this.result = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(TID_FIELD_DESC);
      oprot.writeI32(this.tid);
      oprot.writeFieldEnd();
      if (this.result != null) {
        oprot.writeFieldBegin(RESULT_FIELD_DESC);
        oprot.writeString(this.result);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setCaptchaResult_args(");
      boolean first = true;

      sb.append("tid:");
      sb.append(this.tid);
      first = false;
      if (!first) sb.append(", ");
      sb.append("result:");
      if (this.result == null) {
        sb.append("null");
      } else {
        sb.append(this.result);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setCaptchaResult_result implements TBase<setCaptchaResult_result, setCaptchaResult_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setCaptchaResult_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setCaptchaResult_result.class, metaDataMap);
    }

    public setCaptchaResult_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setCaptchaResult_result(setCaptchaResult_result other) {
    }

    public setCaptchaResult_result deepCopy() {
      return new setCaptchaResult_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setCaptchaResult_result)
        return this.equals((setCaptchaResult_result)that);
      return false;
    }

    public boolean equals(setCaptchaResult_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(setCaptchaResult_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setCaptchaResult_result typedOther = (setCaptchaResult_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("setCaptchaResult_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEvents_args implements TBase<getEvents_args, getEvents_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getEvents_args");

    private static final TField UUID_FIELD_DESC = new TField("uuid", TType.STRING, (short)1);

    public String uuid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      UUID((short)1, "uuid");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // UUID
            return UUID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.UUID, new FieldMetaData("uuid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getEvents_args.class, metaDataMap);
    }

    public getEvents_args() {
    }

    public getEvents_args(
      String uuid)
    {
      this();
      this.uuid = uuid;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEvents_args(getEvents_args other) {
      if (other.isSetUuid()) {
        this.uuid = other.uuid;
      }
    }

    public getEvents_args deepCopy() {
      return new getEvents_args(this);
    }

    
    public void clear() {
      this.uuid = null;
    }

    public String getUuid() {
      return this.uuid;
    }

    public getEvents_args setUuid(String uuid) {
      this.uuid = uuid;
      return this;
    }

    public void unsetUuid() {
      this.uuid = null;
    }

    /** Returns true if field uuid is set (has been asigned a value) and false otherwise */
    public boolean isSetUuid() {
      return this.uuid != null;
    }

    public void setUuidIsSet(boolean value) {
      if (!value) {
        this.uuid = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case UUID:
        if (value == null) {
          unsetUuid();
        } else {
          setUuid((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case UUID:
        return getUuid();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case UUID:
        return isSetUuid();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEvents_args)
        return this.equals((getEvents_args)that);
      return false;
    }

    public boolean equals(getEvents_args that) {
      if (that == null)
        return false;

      boolean this_present_uuid = true && this.isSetUuid();
      boolean that_present_uuid = true && that.isSetUuid();
      if (this_present_uuid || that_present_uuid) {
        if (!(this_present_uuid && that_present_uuid))
          return false;
        if (!this.uuid.equals(that.uuid))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getEvents_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getEvents_args typedOther = (getEvents_args)other;

      lastComparison = Boolean.valueOf(isSetUuid()).compareTo(typedOther.isSetUuid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUuid()) {
        lastComparison = TBaseHelper.compareTo(this.uuid, typedOther.uuid);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // UUID
            if (field.type == TType.STRING) {
              this.uuid = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.uuid != null) {
        oprot.writeFieldBegin(UUID_FIELD_DESC);
        oprot.writeString(this.uuid);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getEvents_args(");
      boolean first = true;

      sb.append("uuid:");
      if (this.uuid == null) {
        sb.append("null");
      } else {
        sb.append(this.uuid);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getEvents_result implements TBase<getEvents_result, getEvents_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getEvents_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<Event> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Event.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getEvents_result.class, metaDataMap);
    }

    public getEvents_result() {
    }

    public getEvents_result(
      List<Event> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getEvents_result(getEvents_result other) {
      if (other.isSetSuccess()) {
        List<Event> __this__success = new ArrayList<Event>();
        for (Event other_element : other.success) {
          __this__success.add(new Event(other_element));
        }
        this.success = __this__success;
      }
    }

    public getEvents_result deepCopy() {
      return new getEvents_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Event> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Event elem) {
      if (this.success == null) {
        this.success = new ArrayList<Event>();
      }
      this.success.add(elem);
    }

    public List<Event> getSuccess() {
      return this.success;
    }

    public getEvents_result setSuccess(List<Event> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Event>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getEvents_result)
        return this.equals((getEvents_result)that);
      return false;
    }

    public boolean equals(getEvents_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getEvents_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getEvents_result typedOther = (getEvents_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list155 = iprot.readListBegin();
                this.success = new ArrayList<Event>(_list155.size);
                for (int _i156 = 0; _i156 < _list155.size; ++_i156)
                {
                  Event _elem157;
                  _elem157 = new Event();
                  _elem157.read(iprot);
                  this.success.add(_elem157);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Event _iter158 : this.success)
          {
            _iter158.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getEvents_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getAccounts_args implements TBase<getAccounts_args, getAccounts_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getAccounts_args");

    private static final TField REFRESH_FIELD_DESC = new TField("refresh", TType.BOOL, (short)1);

    public boolean refresh;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      REFRESH((short)1, "refresh");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // REFRESH
            return REFRESH;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __REFRESH_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.REFRESH, new FieldMetaData("refresh", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getAccounts_args.class, metaDataMap);
    }

    public getAccounts_args() {
    }

    public getAccounts_args(
      boolean refresh)
    {
      this();
      this.refresh = refresh;
      setRefreshIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getAccounts_args(getAccounts_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.refresh = other.refresh;
    }

    public getAccounts_args deepCopy() {
      return new getAccounts_args(this);
    }

    
    public void clear() {
      setRefreshIsSet(false);
      this.refresh = false;
    }

    public boolean isRefresh() {
      return this.refresh;
    }

    public getAccounts_args setRefresh(boolean refresh) {
      this.refresh = refresh;
      setRefreshIsSet(true);
      return this;
    }

    public void unsetRefresh() {
      __isset_bit_vector.clear(__REFRESH_ISSET_ID);
    }

    /** Returns true if field refresh is set (has been asigned a value) and false otherwise */
    public boolean isSetRefresh() {
      return __isset_bit_vector.get(__REFRESH_ISSET_ID);
    }

    public void setRefreshIsSet(boolean value) {
      __isset_bit_vector.set(__REFRESH_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case REFRESH:
        if (value == null) {
          unsetRefresh();
        } else {
          setRefresh((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case REFRESH:
        return new Boolean(isRefresh());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case REFRESH:
        return isSetRefresh();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getAccounts_args)
        return this.equals((getAccounts_args)that);
      return false;
    }

    public boolean equals(getAccounts_args that) {
      if (that == null)
        return false;

      boolean this_present_refresh = true;
      boolean that_present_refresh = true;
      if (this_present_refresh || that_present_refresh) {
        if (!(this_present_refresh && that_present_refresh))
          return false;
        if (this.refresh != that.refresh)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getAccounts_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getAccounts_args typedOther = (getAccounts_args)other;

      lastComparison = Boolean.valueOf(isSetRefresh()).compareTo(typedOther.isSetRefresh());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRefresh()) {
        lastComparison = TBaseHelper.compareTo(this.refresh, typedOther.refresh);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // REFRESH
            if (field.type == TType.BOOL) {
              this.refresh = iprot.readBool();
              setRefreshIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(REFRESH_FIELD_DESC);
      oprot.writeBool(this.refresh);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getAccounts_args(");
      boolean first = true;

      sb.append("refresh:");
      sb.append(this.refresh);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getAccounts_result implements TBase<getAccounts_result, getAccounts_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getAccounts_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<AccountInfo> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, AccountInfo.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getAccounts_result.class, metaDataMap);
    }

    public getAccounts_result() {
    }

    public getAccounts_result(
      List<AccountInfo> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getAccounts_result(getAccounts_result other) {
      if (other.isSetSuccess()) {
        List<AccountInfo> __this__success = new ArrayList<AccountInfo>();
        for (AccountInfo other_element : other.success) {
          __this__success.add(new AccountInfo(other_element));
        }
        this.success = __this__success;
      }
    }

    public getAccounts_result deepCopy() {
      return new getAccounts_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<AccountInfo> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(AccountInfo elem) {
      if (this.success == null) {
        this.success = new ArrayList<AccountInfo>();
      }
      this.success.add(elem);
    }

    public List<AccountInfo> getSuccess() {
      return this.success;
    }

    public getAccounts_result setSuccess(List<AccountInfo> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<AccountInfo>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getAccounts_result)
        return this.equals((getAccounts_result)that);
      return false;
    }

    public boolean equals(getAccounts_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getAccounts_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getAccounts_result typedOther = (getAccounts_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list159 = iprot.readListBegin();
                this.success = new ArrayList<AccountInfo>(_list159.size);
                for (int _i160 = 0; _i160 < _list159.size; ++_i160)
                {
                  AccountInfo _elem161;
                  _elem161 = new AccountInfo();
                  _elem161.read(iprot);
                  this.success.add(_elem161);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (AccountInfo _iter162 : this.success)
          {
            _iter162.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getAccounts_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getAccountTypes_args implements TBase<getAccountTypes_args, getAccountTypes_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getAccountTypes_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getAccountTypes_args.class, metaDataMap);
    }

    public getAccountTypes_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getAccountTypes_args(getAccountTypes_args other) {
    }

    public getAccountTypes_args deepCopy() {
      return new getAccountTypes_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getAccountTypes_args)
        return this.equals((getAccountTypes_args)that);
      return false;
    }

    public boolean equals(getAccountTypes_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getAccountTypes_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getAccountTypes_args typedOther = (getAccountTypes_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getAccountTypes_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getAccountTypes_result implements TBase<getAccountTypes_result, getAccountTypes_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getAccountTypes_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getAccountTypes_result.class, metaDataMap);
    }

    public getAccountTypes_result() {
    }

    public getAccountTypes_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getAccountTypes_result(getAccountTypes_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    public getAccountTypes_result deepCopy() {
      return new getAccountTypes_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public getAccountTypes_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getAccountTypes_result)
        return this.equals((getAccountTypes_result)that);
      return false;
    }

    public boolean equals(getAccountTypes_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getAccountTypes_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getAccountTypes_result typedOther = (getAccountTypes_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list163 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list163.size);
                for (int _i164 = 0; _i164 < _list163.size; ++_i164)
                {
                  String _elem165;
                  _elem165 = iprot.readString();
                  this.success.add(_elem165);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter166 : this.success)
          {
            oprot.writeString(_iter166);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getAccountTypes_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class updateAccount_args implements TBase<updateAccount_args, updateAccount_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("updateAccount_args");

    private static final TField PLUGIN_FIELD_DESC = new TField("plugin", TType.STRING, (short)1);
    private static final TField ACCOUNT_FIELD_DESC = new TField("account", TType.STRING, (short)2);
    private static final TField PASSWORD_FIELD_DESC = new TField("password", TType.STRING, (short)3);
    private static final TField OPTIONS_FIELD_DESC = new TField("options", TType.MAP, (short)4);

    public String plugin;
    public String account;
    public String password;
    public Map<String,String> options;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PLUGIN((short)1, "plugin"),
      ACCOUNT((short)2, "account"),
      PASSWORD((short)3, "password"),
      OPTIONS((short)4, "options");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PLUGIN
            return PLUGIN;
          case 2: // ACCOUNT
            return ACCOUNT;
          case 3: // PASSWORD
            return PASSWORD;
          case 4: // OPTIONS
            return OPTIONS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PLUGIN, new FieldMetaData("plugin", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "PluginName")));
      tmpMap.put(_Fields.ACCOUNT, new FieldMetaData("account", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PASSWORD, new FieldMetaData("password", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.OPTIONS, new FieldMetaData("options", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(updateAccount_args.class, metaDataMap);
    }

    public updateAccount_args() {
    }

    public updateAccount_args(
      String plugin,
      String account,
      String password,
      Map<String,String> options)
    {
      this();
      this.plugin = plugin;
      this.account = account;
      this.password = password;
      this.options = options;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public updateAccount_args(updateAccount_args other) {
      if (other.isSetPlugin()) {
        this.plugin = other.plugin;
      }
      if (other.isSetAccount()) {
        this.account = other.account;
      }
      if (other.isSetPassword()) {
        this.password = other.password;
      }
      if (other.isSetOptions()) {
        Map<String,String> __this__options = new HashMap<String,String>();
        for (Map.Entry<String, String> other_element : other.options.entrySet()) {

          String other_element_key = other_element.getKey();
          String other_element_value = other_element.getValue();

          String __this__options_copy_key = other_element_key;

          String __this__options_copy_value = other_element_value;

          __this__options.put(__this__options_copy_key, __this__options_copy_value);
        }
        this.options = __this__options;
      }
    }

    public updateAccount_args deepCopy() {
      return new updateAccount_args(this);
    }

    
    public void clear() {
      this.plugin = null;
      this.account = null;
      this.password = null;
      this.options = null;
    }

    public String getPlugin() {
      return this.plugin;
    }

    public updateAccount_args setPlugin(String plugin) {
      this.plugin = plugin;
      return this;
    }

    public void unsetPlugin() {
      this.plugin = null;
    }

    /** Returns true if field plugin is set (has been asigned a value) and false otherwise */
    public boolean isSetPlugin() {
      return this.plugin != null;
    }

    public void setPluginIsSet(boolean value) {
      if (!value) {
        this.plugin = null;
      }
    }

    public String getAccount() {
      return this.account;
    }

    public updateAccount_args setAccount(String account) {
      this.account = account;
      return this;
    }

    public void unsetAccount() {
      this.account = null;
    }

    /** Returns true if field account is set (has been asigned a value) and false otherwise */
    public boolean isSetAccount() {
      return this.account != null;
    }

    public void setAccountIsSet(boolean value) {
      if (!value) {
        this.account = null;
      }
    }

    public String getPassword() {
      return this.password;
    }

    public updateAccount_args setPassword(String password) {
      this.password = password;
      return this;
    }

    public void unsetPassword() {
      this.password = null;
    }

    /** Returns true if field password is set (has been asigned a value) and false otherwise */
    public boolean isSetPassword() {
      return this.password != null;
    }

    public void setPasswordIsSet(boolean value) {
      if (!value) {
        this.password = null;
      }
    }

    public int getOptionsSize() {
      return (this.options == null) ? 0 : this.options.size();
    }

    public void putToOptions(String key, String val) {
      if (this.options == null) {
        this.options = new HashMap<String,String>();
      }
      this.options.put(key, val);
    }

    public Map<String,String> getOptions() {
      return this.options;
    }

    public updateAccount_args setOptions(Map<String,String> options) {
      this.options = options;
      return this;
    }

    public void unsetOptions() {
      this.options = null;
    }

    /** Returns true if field options is set (has been asigned a value) and false otherwise */
    public boolean isSetOptions() {
      return this.options != null;
    }

    public void setOptionsIsSet(boolean value) {
      if (!value) {
        this.options = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PLUGIN:
        if (value == null) {
          unsetPlugin();
        } else {
          setPlugin((String)value);
        }
        break;

      case ACCOUNT:
        if (value == null) {
          unsetAccount();
        } else {
          setAccount((String)value);
        }
        break;

      case PASSWORD:
        if (value == null) {
          unsetPassword();
        } else {
          setPassword((String)value);
        }
        break;

      case OPTIONS:
        if (value == null) {
          unsetOptions();
        } else {
          setOptions((Map<String,String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PLUGIN:
        return getPlugin();

      case ACCOUNT:
        return getAccount();

      case PASSWORD:
        return getPassword();

      case OPTIONS:
        return getOptions();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PLUGIN:
        return isSetPlugin();
      case ACCOUNT:
        return isSetAccount();
      case PASSWORD:
        return isSetPassword();
      case OPTIONS:
        return isSetOptions();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof updateAccount_args)
        return this.equals((updateAccount_args)that);
      return false;
    }

    public boolean equals(updateAccount_args that) {
      if (that == null)
        return false;

      boolean this_present_plugin = true && this.isSetPlugin();
      boolean that_present_plugin = true && that.isSetPlugin();
      if (this_present_plugin || that_present_plugin) {
        if (!(this_present_plugin && that_present_plugin))
          return false;
        if (!this.plugin.equals(that.plugin))
          return false;
      }

      boolean this_present_account = true && this.isSetAccount();
      boolean that_present_account = true && that.isSetAccount();
      if (this_present_account || that_present_account) {
        if (!(this_present_account && that_present_account))
          return false;
        if (!this.account.equals(that.account))
          return false;
      }

      boolean this_present_password = true && this.isSetPassword();
      boolean that_present_password = true && that.isSetPassword();
      if (this_present_password || that_present_password) {
        if (!(this_present_password && that_present_password))
          return false;
        if (!this.password.equals(that.password))
          return false;
      }

      boolean this_present_options = true && this.isSetOptions();
      boolean that_present_options = true && that.isSetOptions();
      if (this_present_options || that_present_options) {
        if (!(this_present_options && that_present_options))
          return false;
        if (!this.options.equals(that.options))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(updateAccount_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      updateAccount_args typedOther = (updateAccount_args)other;

      lastComparison = Boolean.valueOf(isSetPlugin()).compareTo(typedOther.isSetPlugin());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPlugin()) {
        lastComparison = TBaseHelper.compareTo(this.plugin, typedOther.plugin);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAccount()).compareTo(typedOther.isSetAccount());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAccount()) {
        lastComparison = TBaseHelper.compareTo(this.account, typedOther.account);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPassword()).compareTo(typedOther.isSetPassword());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPassword()) {
        lastComparison = TBaseHelper.compareTo(this.password, typedOther.password);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOptions()).compareTo(typedOther.isSetOptions());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOptions()) {
        lastComparison = TBaseHelper.compareTo(this.options, typedOther.options);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PLUGIN
            if (field.type == TType.STRING) {
              this.plugin = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ACCOUNT
            if (field.type == TType.STRING) {
              this.account = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PASSWORD
            if (field.type == TType.STRING) {
              this.password = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // OPTIONS
            if (field.type == TType.MAP) {
              {
                TMap _map167 = iprot.readMapBegin();
                this.options = new HashMap<String,String>(2*_map167.size);
                for (int _i168 = 0; _i168 < _map167.size; ++_i168)
                {
                  String _key169;
                  String _val170;
                  _key169 = iprot.readString();
                  _val170 = iprot.readString();
                  this.options.put(_key169, _val170);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.plugin != null) {
        oprot.writeFieldBegin(PLUGIN_FIELD_DESC);
        oprot.writeString(this.plugin);
        oprot.writeFieldEnd();
      }
      if (this.account != null) {
        oprot.writeFieldBegin(ACCOUNT_FIELD_DESC);
        oprot.writeString(this.account);
        oprot.writeFieldEnd();
      }
      if (this.password != null) {
        oprot.writeFieldBegin(PASSWORD_FIELD_DESC);
        oprot.writeString(this.password);
        oprot.writeFieldEnd();
      }
      if (this.options != null) {
        oprot.writeFieldBegin(OPTIONS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.options.size()));
          for (Map.Entry<String, String> _iter171 : this.options.entrySet())
          {
            oprot.writeString(_iter171.getKey());
            oprot.writeString(_iter171.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("updateAccount_args(");
      boolean first = true;

      sb.append("plugin:");
      if (this.plugin == null) {
        sb.append("null");
      } else {
        sb.append(this.plugin);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("account:");
      if (this.account == null) {
        sb.append("null");
      } else {
        sb.append(this.account);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("password:");
      if (this.password == null) {
        sb.append("null");
      } else {
        sb.append(this.password);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("options:");
      if (this.options == null) {
        sb.append("null");
      } else {
        sb.append(this.options);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class updateAccount_result implements TBase<updateAccount_result, updateAccount_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("updateAccount_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(updateAccount_result.class, metaDataMap);
    }

    public updateAccount_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public updateAccount_result(updateAccount_result other) {
    }

    public updateAccount_result deepCopy() {
      return new updateAccount_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof updateAccount_result)
        return this.equals((updateAccount_result)that);
      return false;
    }

    public boolean equals(updateAccount_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(updateAccount_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      updateAccount_result typedOther = (updateAccount_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("updateAccount_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeAccount_args implements TBase<removeAccount_args, removeAccount_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("removeAccount_args");

    private static final TField PLUGIN_FIELD_DESC = new TField("plugin", TType.STRING, (short)1);
    private static final TField ACCOUNT_FIELD_DESC = new TField("account", TType.STRING, (short)2);

    public String plugin;
    public String account;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PLUGIN((short)1, "plugin"),
      ACCOUNT((short)2, "account");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PLUGIN
            return PLUGIN;
          case 2: // ACCOUNT
            return ACCOUNT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PLUGIN, new FieldMetaData("plugin", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "PluginName")));
      tmpMap.put(_Fields.ACCOUNT, new FieldMetaData("account", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(removeAccount_args.class, metaDataMap);
    }

    public removeAccount_args() {
    }

    public removeAccount_args(
      String plugin,
      String account)
    {
      this();
      this.plugin = plugin;
      this.account = account;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeAccount_args(removeAccount_args other) {
      if (other.isSetPlugin()) {
        this.plugin = other.plugin;
      }
      if (other.isSetAccount()) {
        this.account = other.account;
      }
    }

    public removeAccount_args deepCopy() {
      return new removeAccount_args(this);
    }

    
    public void clear() {
      this.plugin = null;
      this.account = null;
    }

    public String getPlugin() {
      return this.plugin;
    }

    public removeAccount_args setPlugin(String plugin) {
      this.plugin = plugin;
      return this;
    }

    public void unsetPlugin() {
      this.plugin = null;
    }

    /** Returns true if field plugin is set (has been asigned a value) and false otherwise */
    public boolean isSetPlugin() {
      return this.plugin != null;
    }

    public void setPluginIsSet(boolean value) {
      if (!value) {
        this.plugin = null;
      }
    }

    public String getAccount() {
      return this.account;
    }

    public removeAccount_args setAccount(String account) {
      this.account = account;
      return this;
    }

    public void unsetAccount() {
      this.account = null;
    }

    /** Returns true if field account is set (has been asigned a value) and false otherwise */
    public boolean isSetAccount() {
      return this.account != null;
    }

    public void setAccountIsSet(boolean value) {
      if (!value) {
        this.account = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PLUGIN:
        if (value == null) {
          unsetPlugin();
        } else {
          setPlugin((String)value);
        }
        break;

      case ACCOUNT:
        if (value == null) {
          unsetAccount();
        } else {
          setAccount((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PLUGIN:
        return getPlugin();

      case ACCOUNT:
        return getAccount();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PLUGIN:
        return isSetPlugin();
      case ACCOUNT:
        return isSetAccount();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeAccount_args)
        return this.equals((removeAccount_args)that);
      return false;
    }

    public boolean equals(removeAccount_args that) {
      if (that == null)
        return false;

      boolean this_present_plugin = true && this.isSetPlugin();
      boolean that_present_plugin = true && that.isSetPlugin();
      if (this_present_plugin || that_present_plugin) {
        if (!(this_present_plugin && that_present_plugin))
          return false;
        if (!this.plugin.equals(that.plugin))
          return false;
      }

      boolean this_present_account = true && this.isSetAccount();
      boolean that_present_account = true && that.isSetAccount();
      if (this_present_account || that_present_account) {
        if (!(this_present_account && that_present_account))
          return false;
        if (!this.account.equals(that.account))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(removeAccount_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      removeAccount_args typedOther = (removeAccount_args)other;

      lastComparison = Boolean.valueOf(isSetPlugin()).compareTo(typedOther.isSetPlugin());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPlugin()) {
        lastComparison = TBaseHelper.compareTo(this.plugin, typedOther.plugin);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAccount()).compareTo(typedOther.isSetAccount());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAccount()) {
        lastComparison = TBaseHelper.compareTo(this.account, typedOther.account);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PLUGIN
            if (field.type == TType.STRING) {
              this.plugin = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ACCOUNT
            if (field.type == TType.STRING) {
              this.account = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.plugin != null) {
        oprot.writeFieldBegin(PLUGIN_FIELD_DESC);
        oprot.writeString(this.plugin);
        oprot.writeFieldEnd();
      }
      if (this.account != null) {
        oprot.writeFieldBegin(ACCOUNT_FIELD_DESC);
        oprot.writeString(this.account);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("removeAccount_args(");
      boolean first = true;

      sb.append("plugin:");
      if (this.plugin == null) {
        sb.append("null");
      } else {
        sb.append(this.plugin);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("account:");
      if (this.account == null) {
        sb.append("null");
      } else {
        sb.append(this.account);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeAccount_result implements TBase<removeAccount_result, removeAccount_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("removeAccount_result");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(removeAccount_result.class, metaDataMap);
    }

    public removeAccount_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeAccount_result(removeAccount_result other) {
    }

    public removeAccount_result deepCopy() {
      return new removeAccount_result(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeAccount_result)
        return this.equals((removeAccount_result)that);
      return false;
    }

    public boolean equals(removeAccount_result that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(removeAccount_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      removeAccount_result typedOther = (removeAccount_result)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("removeAccount_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class login_args implements TBase<login_args, login_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("login_args");

    private static final TField USERNAME_FIELD_DESC = new TField("username", TType.STRING, (short)1);
    private static final TField PASSWORD_FIELD_DESC = new TField("password", TType.STRING, (short)2);

    public String username;
    public String password;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      USERNAME((short)1, "username"),
      PASSWORD((short)2, "password");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // USERNAME
            return USERNAME;
          case 2: // PASSWORD
            return PASSWORD;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.USERNAME, new FieldMetaData("username", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PASSWORD, new FieldMetaData("password", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(login_args.class, metaDataMap);
    }

    public login_args() {
    }

    public login_args(
      String username,
      String password)
    {
      this();
      this.username = username;
      this.password = password;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public login_args(login_args other) {
      if (other.isSetUsername()) {
        this.username = other.username;
      }
      if (other.isSetPassword()) {
        this.password = other.password;
      }
    }

    public login_args deepCopy() {
      return new login_args(this);
    }

    
    public void clear() {
      this.username = null;
      this.password = null;
    }

    public String getUsername() {
      return this.username;
    }

    public login_args setUsername(String username) {
      this.username = username;
      return this;
    }

    public void unsetUsername() {
      this.username = null;
    }

    /** Returns true if field username is set (has been asigned a value) and false otherwise */
    public boolean isSetUsername() {
      return this.username != null;
    }

    public void setUsernameIsSet(boolean value) {
      if (!value) {
        this.username = null;
      }
    }

    public String getPassword() {
      return this.password;
    }

    public login_args setPassword(String password) {
      this.password = password;
      return this;
    }

    public void unsetPassword() {
      this.password = null;
    }

    /** Returns true if field password is set (has been asigned a value) and false otherwise */
    public boolean isSetPassword() {
      return this.password != null;
    }

    public void setPasswordIsSet(boolean value) {
      if (!value) {
        this.password = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case USERNAME:
        if (value == null) {
          unsetUsername();
        } else {
          setUsername((String)value);
        }
        break;

      case PASSWORD:
        if (value == null) {
          unsetPassword();
        } else {
          setPassword((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case USERNAME:
        return getUsername();

      case PASSWORD:
        return getPassword();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case USERNAME:
        return isSetUsername();
      case PASSWORD:
        return isSetPassword();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof login_args)
        return this.equals((login_args)that);
      return false;
    }

    public boolean equals(login_args that) {
      if (that == null)
        return false;

      boolean this_present_username = true && this.isSetUsername();
      boolean that_present_username = true && that.isSetUsername();
      if (this_present_username || that_present_username) {
        if (!(this_present_username && that_present_username))
          return false;
        if (!this.username.equals(that.username))
          return false;
      }

      boolean this_present_password = true && this.isSetPassword();
      boolean that_present_password = true && that.isSetPassword();
      if (this_present_password || that_present_password) {
        if (!(this_present_password && that_present_password))
          return false;
        if (!this.password.equals(that.password))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(login_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      login_args typedOther = (login_args)other;

      lastComparison = Boolean.valueOf(isSetUsername()).compareTo(typedOther.isSetUsername());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUsername()) {
        lastComparison = TBaseHelper.compareTo(this.username, typedOther.username);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPassword()).compareTo(typedOther.isSetPassword());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPassword()) {
        lastComparison = TBaseHelper.compareTo(this.password, typedOther.password);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // USERNAME
            if (field.type == TType.STRING) {
              this.username = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PASSWORD
            if (field.type == TType.STRING) {
              this.password = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.username != null) {
        oprot.writeFieldBegin(USERNAME_FIELD_DESC);
        oprot.writeString(this.username);
        oprot.writeFieldEnd();
      }
      if (this.password != null) {
        oprot.writeFieldBegin(PASSWORD_FIELD_DESC);
        oprot.writeString(this.password);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("login_args(");
      boolean first = true;

      sb.append("username:");
      if (this.username == null) {
        sb.append("null");
      } else {
        sb.append(this.username);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("password:");
      if (this.password == null) {
        sb.append("null");
      } else {
        sb.append(this.password);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class login_result implements TBase<login_result, login_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("login_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(login_result.class, metaDataMap);
    }

    public login_result() {
    }

    public login_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public login_result(login_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public login_result deepCopy() {
      return new login_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public login_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof login_result)
        return this.equals((login_result)that);
      return false;
    }

    public boolean equals(login_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(login_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      login_result typedOther = (login_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("login_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getUserData_args implements TBase<getUserData_args, getUserData_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserData_args");

    private static final TField USERNAME_FIELD_DESC = new TField("username", TType.STRING, (short)1);
    private static final TField PASSWORD_FIELD_DESC = new TField("password", TType.STRING, (short)2);

    public String username;
    public String password;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      USERNAME((short)1, "username"),
      PASSWORD((short)2, "password");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // USERNAME
            return USERNAME;
          case 2: // PASSWORD
            return PASSWORD;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.USERNAME, new FieldMetaData("username", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.PASSWORD, new FieldMetaData("password", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getUserData_args.class, metaDataMap);
    }

    public getUserData_args() {
    }

    public getUserData_args(
      String username,
      String password)
    {
      this();
      this.username = username;
      this.password = password;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserData_args(getUserData_args other) {
      if (other.isSetUsername()) {
        this.username = other.username;
      }
      if (other.isSetPassword()) {
        this.password = other.password;
      }
    }

    public getUserData_args deepCopy() {
      return new getUserData_args(this);
    }

    
    public void clear() {
      this.username = null;
      this.password = null;
    }

    public String getUsername() {
      return this.username;
    }

    public getUserData_args setUsername(String username) {
      this.username = username;
      return this;
    }

    public void unsetUsername() {
      this.username = null;
    }

    /** Returns true if field username is set (has been asigned a value) and false otherwise */
    public boolean isSetUsername() {
      return this.username != null;
    }

    public void setUsernameIsSet(boolean value) {
      if (!value) {
        this.username = null;
      }
    }

    public String getPassword() {
      return this.password;
    }

    public getUserData_args setPassword(String password) {
      this.password = password;
      return this;
    }

    public void unsetPassword() {
      this.password = null;
    }

    /** Returns true if field password is set (has been asigned a value) and false otherwise */
    public boolean isSetPassword() {
      return this.password != null;
    }

    public void setPasswordIsSet(boolean value) {
      if (!value) {
        this.password = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case USERNAME:
        if (value == null) {
          unsetUsername();
        } else {
          setUsername((String)value);
        }
        break;

      case PASSWORD:
        if (value == null) {
          unsetPassword();
        } else {
          setPassword((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case USERNAME:
        return getUsername();

      case PASSWORD:
        return getPassword();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case USERNAME:
        return isSetUsername();
      case PASSWORD:
        return isSetPassword();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getUserData_args)
        return this.equals((getUserData_args)that);
      return false;
    }

    public boolean equals(getUserData_args that) {
      if (that == null)
        return false;

      boolean this_present_username = true && this.isSetUsername();
      boolean that_present_username = true && that.isSetUsername();
      if (this_present_username || that_present_username) {
        if (!(this_present_username && that_present_username))
          return false;
        if (!this.username.equals(that.username))
          return false;
      }

      boolean this_present_password = true && this.isSetPassword();
      boolean that_present_password = true && that.isSetPassword();
      if (this_present_password || that_present_password) {
        if (!(this_present_password && that_present_password))
          return false;
        if (!this.password.equals(that.password))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getUserData_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getUserData_args typedOther = (getUserData_args)other;

      lastComparison = Boolean.valueOf(isSetUsername()).compareTo(typedOther.isSetUsername());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetUsername()) {
        lastComparison = TBaseHelper.compareTo(this.username, typedOther.username);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetPassword()).compareTo(typedOther.isSetPassword());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPassword()) {
        lastComparison = TBaseHelper.compareTo(this.password, typedOther.password);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // USERNAME
            if (field.type == TType.STRING) {
              this.username = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PASSWORD
            if (field.type == TType.STRING) {
              this.password = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.username != null) {
        oprot.writeFieldBegin(USERNAME_FIELD_DESC);
        oprot.writeString(this.username);
        oprot.writeFieldEnd();
      }
      if (this.password != null) {
        oprot.writeFieldBegin(PASSWORD_FIELD_DESC);
        oprot.writeString(this.password);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getUserData_args(");
      boolean first = true;

      sb.append("username:");
      if (this.username == null) {
        sb.append("null");
      } else {
        sb.append(this.username);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("password:");
      if (this.password == null) {
        sb.append("null");
      } else {
        sb.append(this.password);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getUserData_result implements TBase<getUserData_result, getUserData_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getUserData_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public UserData success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, UserData.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getUserData_result.class, metaDataMap);
    }

    public getUserData_result() {
    }

    public getUserData_result(
      UserData success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getUserData_result(getUserData_result other) {
      if (other.isSetSuccess()) {
        this.success = new UserData(other.success);
      }
    }

    public getUserData_result deepCopy() {
      return new getUserData_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public UserData getSuccess() {
      return this.success;
    }

    public getUserData_result setSuccess(UserData success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((UserData)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getUserData_result)
        return this.equals((getUserData_result)that);
      return false;
    }

    public boolean equals(getUserData_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getUserData_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getUserData_result typedOther = (getUserData_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new UserData();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getUserData_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getServices_args implements TBase<getServices_args, getServices_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getServices_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getServices_args.class, metaDataMap);
    }

    public getServices_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getServices_args(getServices_args other) {
    }

    public getServices_args deepCopy() {
      return new getServices_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getServices_args)
        return this.equals((getServices_args)that);
      return false;
    }

    public boolean equals(getServices_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getServices_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getServices_args typedOther = (getServices_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getServices_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getServices_result implements TBase<getServices_result, getServices_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getServices_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,Map<String,String>> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING              , "PluginName"), 
              new MapMetaData(TType.MAP, 
                  new FieldValueMetaData(TType.STRING), 
                  new FieldValueMetaData(TType.STRING)))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getServices_result.class, metaDataMap);
    }

    public getServices_result() {
    }

    public getServices_result(
      Map<String,Map<String,String>> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getServices_result(getServices_result other) {
      if (other.isSetSuccess()) {
        Map<String,Map<String,String>> __this__success = new HashMap<String,Map<String,String>>();
        for (Map.Entry<String, Map<String,String>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          Map<String,String> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          Map<String,String> __this__success_copy_value = new HashMap<String,String>();
          for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {

            String other_element_value_element_key = other_element_value_element.getKey();
            String other_element_value_element_value = other_element_value_element.getValue();

            String __this__success_copy_value_copy_key = other_element_value_element_key;

            String __this__success_copy_value_copy_value = other_element_value_element_value;

            __this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
          }

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public getServices_result deepCopy() {
      return new getServices_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, Map<String,String> val) {
      if (this.success == null) {
        this.success = new HashMap<String,Map<String,String>>();
      }
      this.success.put(key, val);
    }

    public Map<String,Map<String,String>> getSuccess() {
      return this.success;
    }

    public getServices_result setSuccess(Map<String,Map<String,String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,Map<String,String>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getServices_result)
        return this.equals((getServices_result)that);
      return false;
    }

    public boolean equals(getServices_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getServices_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getServices_result typedOther = (getServices_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map172 = iprot.readMapBegin();
                this.success = new HashMap<String,Map<String,String>>(2*_map172.size);
                for (int _i173 = 0; _i173 < _map172.size; ++_i173)
                {
                  String _key174;
                  Map<String,String> _val175;
                  _key174 = iprot.readString();
                  {
                    TMap _map176 = iprot.readMapBegin();
                    _val175 = new HashMap<String,String>(2*_map176.size);
                    for (int _i177 = 0; _i177 < _map176.size; ++_i177)
                    {
                      String _key178;
                      String _val179;
                      _key178 = iprot.readString();
                      _val179 = iprot.readString();
                      _val175.put(_key178, _val179);
                    }
                    iprot.readMapEnd();
                  }
                  this.success.put(_key174, _val175);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
          for (Map.Entry<String, Map<String,String>> _iter180 : this.success.entrySet())
          {
            oprot.writeString(_iter180.getKey());
            {
              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter180.getValue().size()));
              for (Map.Entry<String, String> _iter181 : _iter180.getValue().entrySet())
              {
                oprot.writeString(_iter181.getKey());
                oprot.writeString(_iter181.getValue());
              }
              oprot.writeMapEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getServices_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class hasService_args implements TBase<hasService_args, hasService_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("hasService_args");

    private static final TField PLUGIN_FIELD_DESC = new TField("plugin", TType.STRING, (short)1);
    private static final TField FUNC_FIELD_DESC = new TField("func", TType.STRING, (short)2);

    public String plugin;
    public String func;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PLUGIN((short)1, "plugin"),
      FUNC((short)2, "func");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PLUGIN
            return PLUGIN;
          case 2: // FUNC
            return FUNC;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PLUGIN, new FieldMetaData("plugin", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "PluginName")));
      tmpMap.put(_Fields.FUNC, new FieldMetaData("func", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(hasService_args.class, metaDataMap);
    }

    public hasService_args() {
    }

    public hasService_args(
      String plugin,
      String func)
    {
      this();
      this.plugin = plugin;
      this.func = func;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public hasService_args(hasService_args other) {
      if (other.isSetPlugin()) {
        this.plugin = other.plugin;
      }
      if (other.isSetFunc()) {
        this.func = other.func;
      }
    }

    public hasService_args deepCopy() {
      return new hasService_args(this);
    }

    
    public void clear() {
      this.plugin = null;
      this.func = null;
    }

    public String getPlugin() {
      return this.plugin;
    }

    public hasService_args setPlugin(String plugin) {
      this.plugin = plugin;
      return this;
    }

    public void unsetPlugin() {
      this.plugin = null;
    }

    /** Returns true if field plugin is set (has been asigned a value) and false otherwise */
    public boolean isSetPlugin() {
      return this.plugin != null;
    }

    public void setPluginIsSet(boolean value) {
      if (!value) {
        this.plugin = null;
      }
    }

    public String getFunc() {
      return this.func;
    }

    public hasService_args setFunc(String func) {
      this.func = func;
      return this;
    }

    public void unsetFunc() {
      this.func = null;
    }

    /** Returns true if field func is set (has been asigned a value) and false otherwise */
    public boolean isSetFunc() {
      return this.func != null;
    }

    public void setFuncIsSet(boolean value) {
      if (!value) {
        this.func = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PLUGIN:
        if (value == null) {
          unsetPlugin();
        } else {
          setPlugin((String)value);
        }
        break;

      case FUNC:
        if (value == null) {
          unsetFunc();
        } else {
          setFunc((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PLUGIN:
        return getPlugin();

      case FUNC:
        return getFunc();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PLUGIN:
        return isSetPlugin();
      case FUNC:
        return isSetFunc();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof hasService_args)
        return this.equals((hasService_args)that);
      return false;
    }

    public boolean equals(hasService_args that) {
      if (that == null)
        return false;

      boolean this_present_plugin = true && this.isSetPlugin();
      boolean that_present_plugin = true && that.isSetPlugin();
      if (this_present_plugin || that_present_plugin) {
        if (!(this_present_plugin && that_present_plugin))
          return false;
        if (!this.plugin.equals(that.plugin))
          return false;
      }

      boolean this_present_func = true && this.isSetFunc();
      boolean that_present_func = true && that.isSetFunc();
      if (this_present_func || that_present_func) {
        if (!(this_present_func && that_present_func))
          return false;
        if (!this.func.equals(that.func))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(hasService_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      hasService_args typedOther = (hasService_args)other;

      lastComparison = Boolean.valueOf(isSetPlugin()).compareTo(typedOther.isSetPlugin());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPlugin()) {
        lastComparison = TBaseHelper.compareTo(this.plugin, typedOther.plugin);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFunc()).compareTo(typedOther.isSetFunc());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFunc()) {
        lastComparison = TBaseHelper.compareTo(this.func, typedOther.func);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PLUGIN
            if (field.type == TType.STRING) {
              this.plugin = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // FUNC
            if (field.type == TType.STRING) {
              this.func = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.plugin != null) {
        oprot.writeFieldBegin(PLUGIN_FIELD_DESC);
        oprot.writeString(this.plugin);
        oprot.writeFieldEnd();
      }
      if (this.func != null) {
        oprot.writeFieldBegin(FUNC_FIELD_DESC);
        oprot.writeString(this.func);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("hasService_args(");
      boolean first = true;

      sb.append("plugin:");
      if (this.plugin == null) {
        sb.append("null");
      } else {
        sb.append(this.plugin);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("func:");
      if (this.func == null) {
        sb.append("null");
      } else {
        sb.append(this.func);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class hasService_result implements TBase<hasService_result, hasService_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("hasService_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(hasService_result.class, metaDataMap);
    }

    public hasService_result() {
    }

    public hasService_result(
      boolean success)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public hasService_result(hasService_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
    }

    public hasService_result deepCopy() {
      return new hasService_result(this);
    }

    
    public void clear() {
      setSuccessIsSet(false);
      this.success = false;
    }

    public boolean isSuccess() {
      return this.success;
    }

    public hasService_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof hasService_result)
        return this.equals((hasService_result)that);
      return false;
    }

    public boolean equals(hasService_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(hasService_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      hasService_result typedOther = (hasService_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("hasService_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class call_args implements TBase<call_args, call_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("call_args");

    private static final TField INFO_FIELD_DESC = new TField("info", TType.STRUCT, (short)1);

    public ServiceCall info;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INFO((short)1, "info");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INFO
            return INFO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INFO, new FieldMetaData("info", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ServiceCall.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(call_args.class, metaDataMap);
    }

    public call_args() {
    }

    public call_args(
      ServiceCall info)
    {
      this();
      this.info = info;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public call_args(call_args other) {
      if (other.isSetInfo()) {
        this.info = new ServiceCall(other.info);
      }
    }

    public call_args deepCopy() {
      return new call_args(this);
    }

    
    public void clear() {
      this.info = null;
    }

    public ServiceCall getInfo() {
      return this.info;
    }

    public call_args setInfo(ServiceCall info) {
      this.info = info;
      return this;
    }

    public void unsetInfo() {
      this.info = null;
    }

    /** Returns true if field info is set (has been asigned a value) and false otherwise */
    public boolean isSetInfo() {
      return this.info != null;
    }

    public void setInfoIsSet(boolean value) {
      if (!value) {
        this.info = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INFO:
        if (value == null) {
          unsetInfo();
        } else {
          setInfo((ServiceCall)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INFO:
        return getInfo();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INFO:
        return isSetInfo();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof call_args)
        return this.equals((call_args)that);
      return false;
    }

    public boolean equals(call_args that) {
      if (that == null)
        return false;

      boolean this_present_info = true && this.isSetInfo();
      boolean that_present_info = true && that.isSetInfo();
      if (this_present_info || that_present_info) {
        if (!(this_present_info && that_present_info))
          return false;
        if (!this.info.equals(that.info))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(call_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      call_args typedOther = (call_args)other;

      lastComparison = Boolean.valueOf(isSetInfo()).compareTo(typedOther.isSetInfo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetInfo()) {
        lastComparison = TBaseHelper.compareTo(this.info, typedOther.info);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // INFO
            if (field.type == TType.STRUCT) {
              this.info = new ServiceCall();
              this.info.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.info != null) {
        oprot.writeFieldBegin(INFO_FIELD_DESC);
        this.info.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("call_args(");
      boolean first = true;

      sb.append("info:");
      if (this.info == null) {
        sb.append("null");
      } else {
        sb.append(this.info);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class call_result implements TBase<call_result, call_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("call_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)1);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)2);

    public String success;
    public ServiceDoesNotExists ex;
    public ServiceException e;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      EX((short)1, "ex"),
      E((short)2, "e");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // EX
            return EX;
          case 2: // E
            return E;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      tmpMap.put(_Fields.E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(call_result.class, metaDataMap);
    }

    public call_result() {
    }

    public call_result(
      String success,
      ServiceDoesNotExists ex,
      ServiceException e)
    {
      this();
      this.success = success;
      this.ex = ex;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public call_result(call_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetEx()) {
        this.ex = new ServiceDoesNotExists(other.ex);
      }
      if (other.isSetE()) {
        this.e = new ServiceException(other.e);
      }
    }

    public call_result deepCopy() {
      return new call_result(this);
    }

    
    public void clear() {
      this.success = null;
      this.ex = null;
      this.e = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public call_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ServiceDoesNotExists getEx() {
      return this.ex;
    }

    public call_result setEx(ServiceDoesNotExists ex) {
      this.ex = ex;
      return this;
    }

    public void unsetEx() {
      this.ex = null;
    }

    /** Returns true if field ex is set (has been asigned a value) and false otherwise */
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public ServiceException getE() {
      return this.e;
    }

    public call_result setE(ServiceException e) {
      this.e = e;
      return this;
    }

    public void unsetE() {
      this.e = null;
    }

    /** Returns true if field e is set (has been asigned a value) and false otherwise */
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ServiceDoesNotExists)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ServiceException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case EX:
        return getEx();

      case E:
        return getE();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case EX:
        return isSetEx();
      case E:
        return isSetE();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof call_result)
        return this.equals((call_result)that);
      return false;
    }

    public boolean equals(call_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(call_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      call_result typedOther = (call_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetEx()).compareTo(typedOther.isSetEx());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetEx()) {
        lastComparison = TBaseHelper.compareTo(this.ex, typedOther.ex);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetE()).compareTo(typedOther.isSetE());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetE()) {
        lastComparison = TBaseHelper.compareTo(this.e, typedOther.e);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // EX
            if (field.type == TType.STRUCT) {
              this.ex = new ServiceDoesNotExists();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // E
            if (field.type == TType.STRUCT) {
              this.e = new ServiceException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("call_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getAllInfo_args implements TBase<getAllInfo_args, getAllInfo_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getAllInfo_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getAllInfo_args.class, metaDataMap);
    }

    public getAllInfo_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getAllInfo_args(getAllInfo_args other) {
    }

    public getAllInfo_args deepCopy() {
      return new getAllInfo_args(this);
    }

    
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getAllInfo_args)
        return this.equals((getAllInfo_args)that);
      return false;
    }

    public boolean equals(getAllInfo_args that) {
      if (that == null)
        return false;

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getAllInfo_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getAllInfo_args typedOther = (getAllInfo_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getAllInfo_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getAllInfo_result implements TBase<getAllInfo_result, getAllInfo_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getAllInfo_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,Map<String,String>> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING              , "PluginName"), 
              new MapMetaData(TType.MAP, 
                  new FieldValueMetaData(TType.STRING), 
                  new FieldValueMetaData(TType.STRING)))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getAllInfo_result.class, metaDataMap);
    }

    public getAllInfo_result() {
    }

    public getAllInfo_result(
      Map<String,Map<String,String>> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getAllInfo_result(getAllInfo_result other) {
      if (other.isSetSuccess()) {
        Map<String,Map<String,String>> __this__success = new HashMap<String,Map<String,String>>();
        for (Map.Entry<String, Map<String,String>> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          Map<String,String> other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          Map<String,String> __this__success_copy_value = new HashMap<String,String>();
          for (Map.Entry<String, String> other_element_value_element : other_element_value.entrySet()) {

            String other_element_value_element_key = other_element_value_element.getKey();
            String other_element_value_element_value = other_element_value_element.getValue();

            String __this__success_copy_value_copy_key = other_element_value_element_key;

            String __this__success_copy_value_copy_value = other_element_value_element_value;

            __this__success_copy_value.put(__this__success_copy_value_copy_key, __this__success_copy_value_copy_value);
          }

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public getAllInfo_result deepCopy() {
      return new getAllInfo_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, Map<String,String> val) {
      if (this.success == null) {
        this.success = new HashMap<String,Map<String,String>>();
      }
      this.success.put(key, val);
    }

    public Map<String,Map<String,String>> getSuccess() {
      return this.success;
    }

    public getAllInfo_result setSuccess(Map<String,Map<String,String>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,Map<String,String>>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getAllInfo_result)
        return this.equals((getAllInfo_result)that);
      return false;
    }

    public boolean equals(getAllInfo_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getAllInfo_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getAllInfo_result typedOther = (getAllInfo_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map182 = iprot.readMapBegin();
                this.success = new HashMap<String,Map<String,String>>(2*_map182.size);
                for (int _i183 = 0; _i183 < _map182.size; ++_i183)
                {
                  String _key184;
                  Map<String,String> _val185;
                  _key184 = iprot.readString();
                  {
                    TMap _map186 = iprot.readMapBegin();
                    _val185 = new HashMap<String,String>(2*_map186.size);
                    for (int _i187 = 0; _i187 < _map186.size; ++_i187)
                    {
                      String _key188;
                      String _val189;
                      _key188 = iprot.readString();
                      _val189 = iprot.readString();
                      _val185.put(_key188, _val189);
                    }
                    iprot.readMapEnd();
                  }
                  this.success.put(_key184, _val185);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
          for (Map.Entry<String, Map<String,String>> _iter190 : this.success.entrySet())
          {
            oprot.writeString(_iter190.getKey());
            {
              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter190.getValue().size()));
              for (Map.Entry<String, String> _iter191 : _iter190.getValue().entrySet())
              {
                oprot.writeString(_iter191.getKey());
                oprot.writeString(_iter191.getValue());
              }
              oprot.writeMapEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getAllInfo_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getInfoByPlugin_args implements TBase<getInfoByPlugin_args, getInfoByPlugin_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getInfoByPlugin_args");

    private static final TField PLUGIN_FIELD_DESC = new TField("plugin", TType.STRING, (short)1);

    public String plugin;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      PLUGIN((short)1, "plugin");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // PLUGIN
            return PLUGIN;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.PLUGIN, new FieldMetaData("plugin", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING          , "PluginName")));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getInfoByPlugin_args.class, metaDataMap);
    }

    public getInfoByPlugin_args() {
    }

    public getInfoByPlugin_args(
      String plugin)
    {
      this();
      this.plugin = plugin;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getInfoByPlugin_args(getInfoByPlugin_args other) {
      if (other.isSetPlugin()) {
        this.plugin = other.plugin;
      }
    }

    public getInfoByPlugin_args deepCopy() {
      return new getInfoByPlugin_args(this);
    }

    
    public void clear() {
      this.plugin = null;
    }

    public String getPlugin() {
      return this.plugin;
    }

    public getInfoByPlugin_args setPlugin(String plugin) {
      this.plugin = plugin;
      return this;
    }

    public void unsetPlugin() {
      this.plugin = null;
    }

    /** Returns true if field plugin is set (has been asigned a value) and false otherwise */
    public boolean isSetPlugin() {
      return this.plugin != null;
    }

    public void setPluginIsSet(boolean value) {
      if (!value) {
        this.plugin = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case PLUGIN:
        if (value == null) {
          unsetPlugin();
        } else {
          setPlugin((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case PLUGIN:
        return getPlugin();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case PLUGIN:
        return isSetPlugin();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getInfoByPlugin_args)
        return this.equals((getInfoByPlugin_args)that);
      return false;
    }

    public boolean equals(getInfoByPlugin_args that) {
      if (that == null)
        return false;

      boolean this_present_plugin = true && this.isSetPlugin();
      boolean that_present_plugin = true && that.isSetPlugin();
      if (this_present_plugin || that_present_plugin) {
        if (!(this_present_plugin && that_present_plugin))
          return false;
        if (!this.plugin.equals(that.plugin))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getInfoByPlugin_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getInfoByPlugin_args typedOther = (getInfoByPlugin_args)other;

      lastComparison = Boolean.valueOf(isSetPlugin()).compareTo(typedOther.isSetPlugin());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetPlugin()) {
        lastComparison = TBaseHelper.compareTo(this.plugin, typedOther.plugin);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // PLUGIN
            if (field.type == TType.STRING) {
              this.plugin = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.plugin != null) {
        oprot.writeFieldBegin(PLUGIN_FIELD_DESC);
        oprot.writeString(this.plugin);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getInfoByPlugin_args(");
      boolean first = true;

      sb.append("plugin:");
      if (this.plugin == null) {
        sb.append("null");
      } else {
        sb.append(this.plugin);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getInfoByPlugin_result implements TBase<getInfoByPlugin_result, getInfoByPlugin_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getInfoByPlugin_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<String,String> success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getInfoByPlugin_result.class, metaDataMap);
    }

    public getInfoByPlugin_result() {
    }

    public getInfoByPlugin_result(
      Map<String,String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getInfoByPlugin_result(getInfoByPlugin_result other) {
      if (other.isSetSuccess()) {
        Map<String,String> __this__success = new HashMap<String,String>();
        for (Map.Entry<String, String> other_element : other.success.entrySet()) {

          String other_element_key = other_element.getKey();
          String other_element_value = other_element.getValue();

          String __this__success_copy_key = other_element_key;

          String __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    public getInfoByPlugin_result deepCopy() {
      return new getInfoByPlugin_result(this);
    }

    
    public void clear() {
      this.success = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(String key, String val) {
      if (this.success == null) {
        this.success = new HashMap<String,String>();
      }
      this.success.put(key, val);
    }

    public Map<String,String> getSuccess() {
      return this.success;
    }

    public getInfoByPlugin_result setSuccess(Map<String,String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<String,String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getInfoByPlugin_result)
        return this.equals((getInfoByPlugin_result)that);
      return false;
    }

    public boolean equals(getInfoByPlugin_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    
    public int hashCode() {
      return 0;
    }

    public int compareTo(getInfoByPlugin_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getInfoByPlugin_result typedOther = (getInfoByPlugin_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.MAP) {
              {
                TMap _map192 = iprot.readMapBegin();
                this.success = new HashMap<String,String>(2*_map192.size);
                for (int _i193 = 0; _i193 < _map192.size; ++_i193)
                {
                  String _key194;
                  String _val195;
                  _key194 = iprot.readString();
                  _val195 = iprot.readString();
                  this.success.put(_key194, _val195);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.success.size()));
          for (Map.Entry<String, String> _iter196 : this.success.entrySet())
          {
            oprot.writeString(_iter196.getKey());
            oprot.writeString(_iter196.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    
    public String toString() {
      StringBuilder sb = new StringBuilder("getInfoByPlugin_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
